{"meta":{"title":"Footprint","subtitle":"Jes' footprint","description":null,"author":"jes shaw","url":""},"pages":[{"title":"关于","date":"2017-08-09T10:03:29.000Z","updated":"2018-01-16T08:57:48.505Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"“好记性不如烂笔头”，这里是一些平时的经验积累和概括总结。","raw":null,"content":null}],"posts":[{"title":"为Spring设置restful基础路径","slug":"spring-restcontrooler-specific-basepath","date":"2018-11-26T05:54:44.936Z","updated":"2017-10-19T01:12:36.551Z","comments":true,"path":"2018/11/26/spring-restcontrooler-specific-basepath/","link":"","permalink":"/2018/11/26/spring-restcontrooler-specific-basepath/","excerpt":"由于某些原因，我们会把前端和后端的放在一个站点上，但如果前后端不做分离的话，随着时间推移代码会难以维护。因此就想把静态内容放和后端的接口分开放置，来达到分离的效果。","text":"由于某些原因，我们会把前端和后端的放在一个站点上，但如果前后端不做分离的话，随着时间推移代码会难以维护。因此就想把静态内容放和后端的接口分开放置，来达到分离的效果。 问题希望spring有如下URL结构 /index.html – 静态页/api/user – rest控制器的所有api放在api下 因为是针对所有的RestControllers增加api，而静态页不变，所以有以下两种思路： 基于RestController类增加Spring配置 重写RestController注解 解决方案基于RestController类增加Spring配置目录结构 1234567891011121314151617181920212223242526272829303132@Configurationpublic class WebConfig &#123; @Bean public WebMvcRegistrationsAdapter webMvcRegistrationsHandlerMapping() &#123; return new WebMvcRegistrationsAdapter() &#123; @Override public RequestMappingHandlerMapping getRequestMappingHandlerMapping() &#123; return new RequestMappingHandlerMapping() &#123; private final static String API_BASE_PATH = \"api\"; @Override protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) &#123; Class&lt;?&gt; beanType = method.getDeclaringClass(); if (AnnotationUtils.findAnnotation(beanType, RestController.class) != null) &#123; PatternsRequestCondition apiPattern = new PatternsRequestCondition(API_BASE_PATH) .combine(mapping.getPatternsCondition()); mapping = new RequestMappingInfo(mapping.getName(), apiPattern, mapping.getMethodsCondition(), mapping.getParamsCondition(), mapping.getHeadersCondition(), mapping.getConsumesCondition(), mapping.getProducesCondition(), mapping.getCustomCondition()); &#125; super.registerHandlerMethod(handler, method, mapping); &#125; &#125;; &#125; &#125;; &#125; &#125; 重写RestController注解12345678910111213141516171819202122@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@RestController@RequestMappingpublic @interface RestApiController &#123; @AliasFor(annotation = RequestMapping.class, attribute = \"value\") String[] value(); &#125;@RestApiController(\"user\")public class UserController &#123; @RequestMapping public User all() &#123; User user = new User(); User.setText(\"User api\"); return user; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,spring,restful,base path,基础路径","slug":"java-spring-restful-base-path-基础路径","permalink":"/tags/java-spring-restful-base-path-基础路径/"}]},{"title":"spring中如何穿透多层共享公用信息","slug":"spring-penetrate-layers","date":"2018-11-26T05:54:44.920Z","updated":"2017-11-13T06:07:10.219Z","comments":true,"path":"2018/11/26/spring-penetrate-layers/","link":"","permalink":"/2018/11/26/spring-penetrate-layers/","excerpt":"在实际应用中较多使用的还是是三层架构，主要是因为在程序员圈中，易理解，通用性高。不过各人理解不同使用起来存在差异，就比方说公用信息共享的问题，展示层共享较好理解，那业务层和数据层怎共享呢？","text":"在实际应用中较多使用的还是是三层架构，主要是因为在程序员圈中，易理解，通用性高。不过各人理解不同使用起来存在差异，就比方说公用信息共享的问题，展示层共享较好理解，那业务层和数据层怎共享呢？ 问题如何在各层之间共享公用信息？即要兼顾性能，还要考虑效率和易维护性。 解决方案先来说说疑虑，很长一段时间，因为三层都是以子项目来划分，共享公用信息就不自觉的使用方法传参的方式实现，随得需求和时间的增长，各个方法都会带上公用信息参数。如此一来，自上而下的公用信息从展示一直传递到数据层。问题解决了，但带来了一个新的重复的问题：即所有用到公用信息的地方都得增加该参数。 传参的方式还可以用继承基类的方式实现，即所有的参数继承某个基类，基类中有共享信息的引用，但此方案还是换汤不换药，仅是传参数少了，重复的问题依然存在。 以上两种方案都未能较好的解决共享公用信息的问题，以致于觉得问题出在架构层，把三层换成微内核心架构或者域驱动模型架构。但是无论架构怎么变，层之间的共享信息问题似乎总是存在，只是重复率高低问题。 最近从更高的层面来了看待这个问题，就迎刃而解了。一个程序启动于一个主进程，进程中可以启动多个线程。也就是主进程就是一直存在的，若主进程中共享公用信息，那么就可以达到穿透多层共享公用信息的问题。 spring中则是通过公用子项目，初始化一个对象到应用上下文（理解为主进程），在需要的任何层注入该对象即达到了共享公用信息的目的。","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,spring,share,base path,基础路径","slug":"java-spring-share-base-path-基础路径","permalink":"/tags/java-spring-share-base-path-基础路径/"}]},{"title":"Spring面试问题","slug":"spring-interview-questions","date":"2018-11-26T05:54:44.896Z","updated":"2017-10-30T07:04:24.223Z","comments":true,"path":"2018/11/26/spring-interview-questions/","link":"","permalink":"/2018/11/26/spring-interview-questions/","excerpt":"Spring框架是最受欢迎的Java企业级web应用框架。依赖注入和面象方面是Spring框架的核心。","text":"Spring框架是最受欢迎的Java企业级web应用框架。依赖注入和面象方面是Spring框架的核心。 我最近提交了许多Spring教程，它将有助于帮你详细的解释Spring面试问题的核心概念。 Spring面试问题列表 Spring框架是什么？ Spring框架有些什么重要的特性和优势？ 你对依赖注入的理解是什么？ Spring框架中怎么样实现依赖注入？ 使用Spring工具套件有什么好处？ 重要的Spring模块名称有哪些？ 你对面向切面编程的理解是什么？ AOP中的Aspect, Advice, Pointcut, JointPoint and Advice Arguments是什么？ Spring AOP 和AspectJ AOP有什么区别？ Spring IoC容器是什么？ Spring Bean是什么？ Spring Bean配置文件的重要性是什么？ 把一个类配置成Spring Bean有些什么不同方法？ Spring Bean有些什么不同作用域？ Spring Bean生命周期是什么？ 在Spring Bean中怎么获得ServletContext和ServletConfig对象 Bean装配和@Autowired注解是什么？ Spring Bean自动装配有几种不同类型？ Spring Bean是线程安全的吗？ 在Spring MVC的Controller是什么？ 在Spring中 @Component, @Repository 和 @Service注解有什么区别？ DispatcherServlet 和 ContextLoaderListener是什么？ 在Spring中的ViewResolver是什么？ MultipartResolver是什么？什么时候使用？ Spring MVC框架怎样处理异常？ 在Java程序中怎样创建ApplicationContext？ 能有多个Spring配置文件吗？ ContextLoaderListener是什么？ 为了创建Spring MVC应用，至少需要配置什么？ 相对与MVC架构，你对Spring MVC框架的理解是怎样的？ Spring MVC应用怎样实现平地化？ 使用Spring怎样创建Restful Web服务并返回JSON？ 你使用过哪些重要的Spring注解？ 我们可以发送一个Object作为Controller handler方法的响应吗？ Spring MVC应用怎样上传文件？ Spring Web MVC架构怎样验证表单数据？ Spring MVC拦截器（Interceptor）是什么？怎样使用？ Spring JdbcTemplate类是什么？怎样使用？ Spring Web应用中怎样使用Tomcat JNDI数据资源？ 在Spring中怎样实现事务管理？ Spring DAO是什么？ 怎样集成Spring和Hibernate框架？ Spring Security是什么？ 怎样注入一个java.util.Properties到Spring Bean？ Spring框架使用哪些设计模式？ Spring框架有些什么最佳实践？ Spring面试问题及答案1. Spring框架是什么？Spring是使用最为广泛的Java企业级框架。 Spring框架是“依赖注入”和“面向切面编程”。 Spring框架可以用于一般的java应用中。通过依赖注入的实现不同组件中的松耦合，使用Spring支持的面向切面编程我们可以像日志和认证那样跨截面执行任务。 我喜欢Spring是因它提供了许多特性和不同的功能模块，如Spring MVC和Spring JDBC。由于它是开源的，有许多在线资源和活跃的社区，使用Spring框架，在相同的时间内，工作起来更加的容易和有趣。 2. Spring框架有些什么重要的特性和优势？Spring框架是基于“依赖注入”和“面向切面编程”两个设计概念建立。 Spring框架有如下特性： 对开发来讲使用该框架有极少的开销，且它是一个轻量级的框架。 依赖注入和控制反转编写的组件是相互独立的，Spring容器负责一起装配组件，帮助实现我们的工作。 Spring IoC容器管理Spring Bean的生命周期和规划具体的配置，如JNDI查找。 Spring MVC框架可以用于创建web应用，也可以创建返回XML或JSON的web服务。 只需要非常少的配置便能支持事务管理，JDBC操作，文件上传，异常处理等。配置你可以使用注解或者配置文件实现。 使用Spring框架有如下优势： 减少在应用中两个不同组件的直接依赖，一般来说Spring IoC容器负责初始化资源或beans并注入它们的依赖。 在Spring框架中写单元测试更加容易。因为业务逻辑不直接依赖实际的资源实现类。可以容易的编写测试配置和注入测试目的模拟的beans。 减少了重复代码的数量，如初始化对象，打开或关闭资源。我很喜欢JdbcTemplate类，是因为它帮助我们移除了所有来自JDBC编程的重复代码。 Spring框架被分成多个模块，它帮助我们保证我们的应用变得轻量级。例如若不需要Spring事件管理特性，则可以不添加它的依赖到项目中。 Spring框架支持大部分Java企业级特性，甚至更多。它总是与时俱进，如它有Android的Spring项目，帮助我们写出更好的native android的应用。这些使得Spring框架更完整，不需要因为新需求再引入不同的框架。 3. 你对依赖注入的理解是什么？依赖注入设计模式允许我们移除硬编码依赖，确保应用松耦合，可扩展，可维护。把依赖解析从编译时移动运行时，我们就能够实现依赖注入模式。 使用依赖注入有这些好处：分享了关注点，减少了重复代码，组件可配置和更易单元测试。 4. Spring框架中怎么样实现依赖注入？在Spring应用中我们可以基于“Spring XML”以及“注解”配置实现依赖注入。更好的理解，请阅读Spring依赖注入实例。 5. 使用Spring工具套件有什么好处？安装扫描件到Eclipse将获得更多Spring工具套件的特性。无论如何，Eclipse中的Spring工具套件有诸如Maven支持，创建不同Spring项目类型的模板和更好Spring应用性能的tc服务。 我喜欢Spring工具套件，是因为在使用AOP切入点（pointcuts）和APO通知（advices）时，高亮显示了这些Spring组件。它清楚的显示了哪个方法将来自指定的切入点。因此相较与安装每一件小工具，在开发Spring应用时，我更喜欢使用Spring工具套件。 6. 重要的Spring模块名称有哪些？Spring框架一些重要的模块如下： Spring Context – 用于依赖注入。 Spring AOP –用于面向切面编程。 Spring DAO – 用于DAO模式的数据操作。 Spring JDBC – 用于JDBC和数据的支持。 Spring ORM – 用于ORM工具的支持，如Hibernate。 Spring Web Module – 用于创建web应用。 Spring MVC – 为创建web应用，web服务等的MVC实现。 7. 你对面向切面编程的理解是什么？企业级应用有一些对不同类型的对象和应用模块的公用横向关注点是合适必要的。例始日志，事务管理，数据验证，身份认证等。在面向切面编程中，应用模块是通过类实现的。如AOP应用模块是通过配置在不同类的方法上的模向关注点Aspects实现的。 AOP从类中分离了横向关注点任务的直接依赖，这在一般的面向对象编程中是不可做到的。例如，你可以把日志从类中分离，但这个类不午不将要调用这些方法记录日志数据（AOP就不需要）。 8. AOP中的连接点（Joinpoint）, 切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？ 连接点（Joinpoint）程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入通知。连接点由两个信息确定：第一是用方法表示的程序执行点；第二是用相对点表示的方位。连接点是在应用执行过程中能够插入切面的一个点。 以查电表为例子：电力公司为多个住户提供服务，连接点就是每一家的电表所在的位置（类中的方法的调用前、调用后…）。 切点（Pointcut）AOP通过“切点”定位特定的连接点。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。其实确切地说，不能称之为查询连接点，因为连接点是方法执行前、执行后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体连接点上，还需要提供方位信息。 电力公司为每一个抄表员都分别指定某一块区域的住户。切点就是划分的区域。 通知（Advice）切面的工作被称为通知。是织入到目标类连接点上的一段程序代码。Spring切面可以应用5种类型的通知：-前置通知（Before）：在目标方法被调用之前调用通知功能；-后置通知（After）：在目标方法完成之后调用通知，此时不会关心方 法的输出是什么；-返回通知（After-returning）：在目标方法成功执行之后调用通知；-异常通知（After-throwing）：在目标方法抛出异常后调用通知；-环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调 用之前和调用之后执行自定义的行为。 抄表员的本职工作是登记用电量，但他们还需要向电力公司汇报的信息。登记用电量是目标对象，汇报的信息就是通知。 引介（Introduction） 引入允许我们向现有的类添加新方法或属性，是一种特殊的通知。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。 切面（Aspect） 切面由切点和通知（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义。 抄表员的开始一天的工作时，他要知道从哪些区域（切点）收集信息，从而进行汇报（通知）。 织入（Weaving） 织入是把切面应用到目标对象并创建新的代理对象的过程。AOP有三种织入的方式：a、编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。b、类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。c、运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面的。 9. Spring AOP 和AspectJ AOP有什么区别？AspectJ是面向方向的一个工业标准级实现，而Spring仅实现了一些案例的AOP。Spring AOP 和AspectJ AOP主要有以下区别： 相较与AspectJ，Spring AOP使用更简单，因为不需要担心织入（weaving）处理。 Spring AOP支持AspectJ 注解,因此你熟悉AspectJ，使用Spring AOP也是容易的。 Spring AOP仅支持基于代理的AOP，因此它仅能应用到方法执行连接点上。AspectJ支持所有种类的切点。 Spring AOP缺点之一是它通过Spring上下文仅能应用到beans创建时。 10. Spring IoC容器是什么？控制反转（Inversion of Control）是在两对象依赖之间实现松耦合的机制。为了实现松耦合和在运行时对象的动态绑定，对象定义依赖是通过其他装配对象被注入的。Spring IoC容器是注入依赖到某个对象和待我们使用的一种程序。 Spring框架的IoC容器类由org.springframework.beans和org.springframework.context包组成。提供给我们多种不同的方式实现对象依赖的解耦。 一些常用的应用上下文实现如下： AnnotationConfigApplicationContext: 对于基于注角配置的独立java应用程序。 ClassPathXmlApplicationContext: 对于基于XML配置的独立java应用程序。 FileSystemXmlApplicationContext: 除xml配置可以在文件系统中的从任何地方加载之外，与ClassPathXmlApplicationContext类似。 AnnotationConfigWebApplicationContext 和 XmlWebApplicationContext：对于web应用程序。 11. Spring Bean是什么？Spring IoC容器初始化任何普通的java类被称为Spring Bean。我们使用Spring ApplicationContext得到Spring Bean实例. Spring IoC容器管理Spring Bean生命周期，bean作用域并在bean中注入任何所需要的依赖关系。 12. Spring Bean配置文件的重要性是什么？我们使用Spring Bean配置文件定义的所有beans将通过Spring Context初始化。在我们创建Spring ApplicationContext的实例时，它将读取spring bean xml文件和初始化所有的实例。一旦ApplicationContext初始化成功，我们就能够使用它得到不同的bean实例了。 除了Spring Bean配置外，该文件还包含Spring MVC拦截器，视图解析器和其他元素，以支持基于注释的配置。 13. 把一个类配置成Spring Bean有些什么不同方法？有以下三种方案配置Spring Bean： XML 配置: 这是非常受欢迎的配置方式，我们可以使用在context文件中的元素来配置Spring Bean。例如：1&lt;bean name=\"myBean\" class=\"com.journaldev.spring.beans.MyBean\"&gt;&lt;/bean&gt; 基于Java的配置：如果仅使用注释，则可以使用@Bean注释配置Spring Bean。 此注释与@Configuration类配合使用即配置成Spring bean。 示例配置如下：123456789@Configuration@ComponentScan(value=\"com.journaldev.spring.main\")public class MyConfiguration &#123; @Bean public MyService getService()&#123; return new MyService(); &#125;&#125; 为了从spring context得到这个bean，我们需要使用所以代码段： 123AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext( MyConfiguration.class);MyService service = ctx.getBean(MyService.class); 基于注解的配置：我们还可以使用@Component，@Service，@Repository和@Controller注释与类配置为spring bean。 对于这些，我们需要提供基本的包位置来扫描这些类。 例如：1&lt;context:component-scan base-package=\"com.journaldev.spring\" /&gt; 14. Spring Bean有些什么不同作用域？Spring Beans定义了5种作用域。 singleton: 将为每个容器创建一个Bean的一个实例。 这是Spring bean的默认作用域。 在使用此作用域时，确保spring bean没有共享实例变量，否则可能导致数据不一致性问题，因为它不是线程安全的。prototype: 每次请求bean时都会创建一个新的实例。request: 这与prototype作用域相同，但它意在用于Web应用程序。 将为每个HTTP请求创建一个新的bean实例。该作用域仅在基于web的Spring上下文中才有效。该作用域仅在基于web的Spring上下文中才有效。session: 将为容器的每个HTTP会话创建一个新的bean。该作用域仅在基于web的Spring上下文中才有效。global-session: 这用于为Portlet应用程序创建全局会话bean。该作用域仅在Portlet上下文中才有效。Spring框架是可扩展的，我们也可以创建我们自己的作用域，但是大多数时候，我们使用框架提供的作用域就够了。 要设置Spring bean作用域，我们可以在bean元素或@Scope注解中使用“scope”属性来进行基于注解的配置。 15. Spring Bean生命周期是什么？Spring Beans通过Spring容器被初始化并所有依赖也被注入。在上下文多销毁时，所有初始化的beans也销毁。这在大多数情况下运行良好，但有时我们希望初始化其他资源或进行一些验证，然后才能使我们的bean准备被使用。Spring框架提供了对Spring bean中的初始化后和销毁前方法的支持。 我们可以通过两种方法来实现 - 通过在Spring bean配置中实现InitializingBean和DisposableBean接口或使用init-method和destroy-method属性。有关更多详细信息，请参阅Spring Bean生命周期方法。 16. 在Spring Bean中怎么获得ServletContext和ServletConfig对象在Spring Bean中有两种方法获得容器指定的对象。 实现Spring * Aware接口。对于这些ServletContextAware和ServletConfigAware接口，有关这些aware接口的完整示例，请阅读Spring Aware Interfaces。 使用@Autowired注释与类型为ServletContext和ServletConfig的Bean变量。 它们只能在servlet容器的特定环境中工作。 12@AutowiredServletContext servletContext; 17. Bean装配和@Autowired注解是什么？spring bean依赖注入的处理，在初始化它时被称作spring bean装配。 通常来讲显示的装配所有的bean依赖是最佳实践，但spring框架也支持自动装配。我们也可以使用@Autowired注解和域或方法通过类型的方式自动装配。为了使此注解工作，我们还需要在spring bean配置文件中启用基于注释的配置。 这可以通过上下文来完成：annotation-config元素。 有关@Autowired注释的更多详细信息，请阅读Spring Autowire示例。 18. Spring Bean自动装配有几种不同类型？spring框架有4种类型的自动装配： 据名称自动装配 据类型自动装配 据构造类自动装配 据@Autowired和@Qualifier注解自动装配Prior to Spring 3.1, autowire by autodetect was also supported that was similar to autowire by constructor or byType. For more details about these options, please read Spring Bean Autowiring. 在Spring 3.1之前，据自动探测自动装配也被支持，它类似于构造器或按类型自动装配。有关这些选项的更多详细信息，请参阅Spring Bean自动装配。 19. Spring Bean是线程安全的吗？Spring bean的默认作用域是单例的，因此每个上下文只有一个实例。 这意味着所有类级别的变量在任何线程可以更新它，导致数据不一致。 因此，在默认模式下，spring bean不是线程安全的。 但是我们可以改变spring bean的作用域到request, prototype or session，在牺牲性能的基础上，来实现线程安全。 这是一个设计决策，并根据项目要求。 20. 在Spring MVC的Controller是什么？就像MVC设计模式一样，Controller是负责处理所有客户端请求的类，并将它们分发到配置的资源去处理它。在Spring MVC中，org.springframework.web.servlet.DispatcherServlet是基于spring bean配置初始化上下文的前端控制器类。 Controller类负责根据请求映射来处理不同类型的客户端请求。 我们可以使用@Controller注解创建一个控制器类。 通常它与@RequestMapping注释一起使用来指定特定URI映射的处理程序方法。 21. 在Spring中 @Component, @Repository 和 @Service注解有什么区别？@Component注解用于指示该类是一个组件。 当使用基于注解的配置时，这些类将自动检测并配置为bean被使用。 @Controller注解是一种特定类型的组件，用于MVC应用程序，大多与@RequestMapping注解一起使用。 @Repository注解用于指示组件用作存储库，以及用于存储/检索/搜索数据的机制。 我们可以使用DAO模式实现类应用此注解。 @Service注解用于表示该类是一个服务。 通常会提供一些服务的业务门面类使用该注解。 为了类可以自动检测到，我们可以使用任何以上注解，但不同的类型的注解被提供后，你可以轻松区分类的意图。 22. DispatcherServlet 和 ContextLoaderListener是什么？DispatcherServlet是Spring MVC应用程序中的前台控制器，它加载spring bean配置文件并初始化配置的所有bean。 如果注解已启用，它还会扫描程序包和配置使用@Component，@Controller，@Repository或@Service注解的任何bean。 ContextLoaderListener是启动和关闭Spring的根WebApplicationContext的侦听器。 重要的功能是将ApplicationContext的生命周期与ServletContext的生命周期结合起来，并自动创建ApplicationContext。 我们可以跨越不同spring上下文中,使用它定义共享bean。 23. 在Spring中的ViewResolver是什么？ViewResolver实现被用于按名称解析视图页面。 通常我们在spring bean配置文件中配置它。 例如：12345&lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt;&lt;beans:bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;beans:property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt; &lt;beans:property name=\"suffix\" value=\".jsp\" /&gt;&lt;/beans:bean&gt; InternalResourceViewResolver是ViewResolver接口的实现之一，我们通过bean属性提供了view pages目录和后缀位置。 因此，如果控制器处理程序方法返回“home”，则视图解析器将使用位于/WEB-INF/views/home.jsp的视图页面。 24. MultipartResolver是什么？什么时候使用？MultipartResolver接口用于上传文件 - CommonsMultipartResolver和StandardServletMultipartResolver是由spring框架提供的用于文件上传的两个实现。 默认情况下，没有配置多部分解析器，但是要使用它们来上传文件，我们需要在spring bean配置中定义一个名为“multipartResolver”的bean，其类型为MultipartResolver。 一旦配置完成后，任何多部分请求将由配置的MultipartResolver解析，并传递一个包装的HttpServletRequest。 然后在控制器类中使用它来获取文件并处理它。 这里提供一个完整的例子，请阅读Spring MVC文件上传示例。 25. Spring MVC框架怎样处理异常？Spring MVC框架提供了以下方法来帮助我们实现强大的异常处理。 基于控制器 - 我们可以在控制器类中定义异常处理程序方法。 我们需要的是使用@ExceptionHandler注解来注解这些方法。 全局异常处理程序 - 异常处理是一个横切关注的问题，Spring提供了@ControllerAdvice注解，让我们可以使用任何类来定义我们的全局异常处理程序。 HandlerExceptionResolver实现 - 对于一般异常，大多数时候我们提供静态页面。 Spring Framework提供了HandlerExceptionResolver接口，我们可以实现这个接口来创建全局异常处理程序。 这种额外的方法来定义全局异常处理程序的原因是Spring框架还提供了我们可以在spring bean配置文件中定义的默认实现类，以获得Spring框架异常处理的好处。 有关完整的示例，请参阅Spring异常处理示例。 26. 在Java程序中怎样创建ApplicationContext？在独立的java程序中创建ApplicationContext有以下几种方法。 AnnotationConfigApplicationContext：如果我们在独立的Java应用程序中使用Spring，并使用注解进行配置，那么我们可以使用它来初始化容器并获取bean对象。 ClassPathXmlApplicationContext：如果我们在独立应用程序中有spring bean配置xml文件，那么我们可以使用此类来加载文件并获取容器对象。 FileSystemXmlApplicationContext：类似于ClassPathXmlApplicationContext，除了可以从文件系统中的任何位置之外的任何地方加载xml配置文件。 27. 能有多个Spring配置文件吗？对于Spring MVC应用程序，我们可以通过contextConfigLocation定义多个Spring上下文配置文件。 该位置字符串可以由多个位置组成，并以任意数量的逗号和空格分隔。 例如;123456789&lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml,/WEB-INF/spring/appServlet/servlet-jdbc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 我们还可以定义多个根级Spring配置，并通过上下文参数加载它们。 例如;1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/root-context.xml /WEB-INF/spring/root-security.xml&lt;/param-value&gt;&lt;/context-param&gt; 另一个选择是在上下文配置文件中使用import元素来导入其他配置，例如：1&lt;beans:import resource=\"spring-jdbc.xml\"/&gt; 28. ContextLoaderListener是什么？ContextLoaderListener是用于加载根上下文的侦听器类，并定义将对所有其他上下文可见的spring bean配置。 它在web.xml文件中配置为：12345678&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 29. 为了创建Spring MVC应用，至少需要配置什么？要创建一个简单的Spring MVC应用程序，我们需要执行以下任务。 在项目中添加spring-context和spring-webmvc依赖项。 在web.xml文件中配置DispatcherServlet，以通过spring容器处理请求。 Spring bean配置文件来定义bean，如果使用注解，那么必须在这里配置。 此外，我们还需要为视图页面配置视图解析器。 控制器类与请求映射定义为处理客户端请求。以上步骤应该足以创建一个简单的Spring MVC Hello World应用程序。 30. 相对与MVC架构，你对Spring MVC框架的理解是怎样的？正如名称所示，Spring MVC建立在Model-View-Controller架构之上。 DispatcherServlet是Spring MVC应用程序中的前端控制器，负责处理所有传入的请求并将其委托给不同的控制器处理程序方法。 模型可以是Spring框架中的任何Java Bean，就像任何其他MVC框架Spring一样，提供了将表单数据自动绑定到java bean。 我们可以将模型bean设置为在视图页面中使用的属性。 查看页面可以是JSP，静态HTML等，视图解析器负责查找正确的视图页面。 一旦查看页面被识别到，控制将返回给DispatcherServlet控制器。 DispatcherServlet负责呈现视图，并向客户端返回最终响应。 31. Spring MVC应用怎样实现本地化？Spring通过资源包为本地化或i18n提供了极好的支持。 使我们的应用程序本地化所需的基本步骤是： 为不同的区域设置创建消息资源束，如messages_en.properties，messages_fr.properties等。 在ResourceBundleMessageSource或ReloadableResourceBundleMessageSource类型的spring bean配置文件中定义messageSource bean。 要更改区域设置支持，请定义类型为CookieLocaleResolver的localeResolver bean并配置LocaleChangeInterceptor拦截器。示例配置可以如下所示： 123456789101112131415161718&lt;beans:bean id=\"messageSource\"class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt;&lt;beans:property name=\"basename\" value=\"classpath:messages\" /&gt;&lt;beans:property name=\"defaultEncoding\" value=\"UTF-8\" /&gt;&lt;/beans:bean&gt; &lt;beans:bean id=\"localeResolver\" class=\"org.springframework.web.servlet.i18n.CookieLocaleResolver\"&gt; &lt;beans:property name=\"defaultLocale\" value=\"en\" /&gt; &lt;beans:property name=\"cookieName\" value=\"myAppLocaleCookie\"&gt;&lt;/beans:property&gt; &lt;beans:property name=\"cookieMaxAge\" value=\"3600\"&gt;&lt;/beans:property&gt;&lt;/beans:bean&gt; &lt;interceptors&gt; &lt;beans:bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"&gt; &lt;beans:property name=\"paramName\" value=\"locale\" /&gt; &lt;/beans:bean&gt;&lt;/interceptors&gt; 在具有键名称的视图页面中使用spring:message元素，DispatcherServlet选择相应的值，并将页面呈现在相应的区域设置中，并作为响应返回。 有关完整的示例，请阅读Spring本地化示例 。 32. 使用Spring怎样创建Restful Web服务并返回JSON？我们可以使用Spring Framework创建返回JSON数据的Restful Web服务。 Spring提供与Jackson JSON API的集成，我们可以使用它在安静的Web服务中发送JSON响应。 我们需要执行以下步骤来配置我们的Spring MVC应用程序以发送JSON响应： 添加Jackson JSON依赖项，如果您使用Maven，可以使用以下代码： 123456&lt;!-- Jackson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.databind-version&#125;&lt;/version&gt;&lt;/dependency&gt; 在Spring bean配置文件中配置RequestMappingHandlerAdapter bean，并将messageConverters属性设置为MappingJackson2HttpMessageConverter bean。 样品配置将是： 123456789101112&lt;!-- Configure to plugin JSON as request and response in method handler --&gt;&lt;beans:bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;beans:property name=\"messageConverters\"&gt; &lt;beans:list&gt; &lt;beans:ref bean=\"jsonMessageConverter\"/&gt; &lt;/beans:list&gt; &lt;/beans:property&gt;&lt;/beans:bean&gt;&lt;!-- Configure bean to convert JSON to POJO and vice versa --&gt;&lt;beans:bean id=\"jsonMessageConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt;&lt;/beans:bean&gt; 在控制器处理程序方法中，使用@ResponseBody注释返回Object作为响应。 示例代码： 123456@RequestMapping(value = EmpRestURIConstants.GET_EMP, method = RequestMethod.GET)public @ResponseBody Employee getEmployee(@PathVariable(\"id\") int empId) &#123; logger.info(\"Start getEmployee. ID=\"+empId); return empData.get(empId);&#125; 您可以通过任何API调用其余服务，但是如果要使用Spring，那么我们可以使用RestTemplate类来轻松实现。有关一个完整的例子，请阅读Spring Restful Webservice示例 。 33. 你使用过哪些重要的Spring注解？我在项目中使用的一些Spring注解是： @Controller - 用于Spring MVC项目中的控制器类。@RequestMapping - 用于在控制器处理程序方法中配置URI映射。 这是一个非常重要的注释。@ResponseBody - 用于发送Object作为响应，通常用于发送XML或JSON数据作为响应。@PathVariable - 用于将动态值从URI映射到处理程序方法参数。@Autowired - 用于spring bean的自动装配依赖。@Qualifier - 与@Autowired注解一起使用，以避免多个Bean类型的实例存在混淆。@Service - 用于服务类。@Scope - 用于配置spring bean的作用域。@Configuration， @ComponentScan和@Bean - 用于基于Java的配置。用于配置切面和通知的AspectJ注解， @Aspect ， @Before ， @After ， @Around ， @Pointcut等。 34. 我们可以发送一个Object作为Controller handler方法的响应吗？可以，我们可以使用@ResponseBody注解。 这就是我们如何在restful的Web服务中发送基于JSON或XML的响应。 35. Spring MVC应用怎样上传文件？Spring提供内置的支持，可通过MultipartResolver接口实现上传文件。 它非常易于使用，只需要配置更改才能使其正常工作。 显然，我们需要编写控制器处理程序方法来处理传入的文件并进行处理。 有关完整的示例，请参阅Spring文件上传示例 。 36. Spring Web MVC架构怎样验证表单数据？Spring支持基于JSR-303注释的验证，并提供我们可以实现的Validator接口来创建我们自己的自定义验证器。 对于使用基于JSR-303的验证，我们需要使用所需的验证来注释bean变量。 对于自定义验证器实现，我们需要在controller类中进行配置。 有关完整的示例，请参阅Spring MVC表单验证示例 。 37. Spring MVC拦截器（Interceptor）是什么？怎样使用？Spring MVC拦截器就像Servlet过滤器，允许我们拦截客户端请求并处理它。 我们可以在三个地方拦截客户端请求 - preHandle ， postHandle和afterCompletion 。 我们可以通过实现HandlerInterceptor接口或扩展抽象类HandlerInterceptorAdapter来创建spring拦截器。 我们需要在spring bean配置文件中配置拦截器。 我们可以定义拦截器来拦截所有的客户端请求，也可以为特定的URI映射进行配置。 有关详细的示例，请参考Spring MVC拦截器示例 。 38. Spring JdbcTemplate类是什么？怎样使用？Spring Framework提供与JDBC API的良好集成，并提供JdbcTemplate实用程序类，我们可以使用它来避免数据库操作逻辑（如打开/关闭连接，ResultSet，PreparedStatement等）的bolier-plate代码。 对于JdbcTemplate示例，请参考Spring JDBC示例 。 39. Spring Web应用中怎样使用Tomcat JNDI数据资源？对于使用servlet容器配置的JNDI DataSource，我们需要在spring bean配置文件中进行配置，然后将其注入spring beans作为依赖关系。 然后我们可以使用它与JdbcTemplate来执行数据库操作。 示例配置如下：123&lt;beans:bean id=\"dbDataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt; &lt;beans:property name=\"jndiName\" value=\"java:comp/env/jdbc/MyLocalDB\"/&gt;&lt;/beans:bean&gt; 有关完整的例子，请参考Spring Tomcat JNDI示例 。 40. 在Spring中怎样实现事务管理？Spring框架通过声明式事务管理以及编程式事务管理来提供事务管理支持。 声明式事务管理被广泛使用，因为它在大多数情况下易于使用和工作。 我们使用@Transactional注释的注释方法进行声明式事务管理。 我们需要在Spring bean配置文件中为DataSource配置事务管理器。1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 41. Spring DAO是什么？提供Spring DAO支持，以一致和简单的方式处理JDBC，Hibernate等数据访问技术。 例如，对于各自的技术，我们有JdbcDaoSupport ， HibernateDaoSupport ， JdoDaoSupport和JpaDaoSupport 。 Spring DAO还提供了异常层次结构的一致性，我们不需要捕获特定的异常。 42. 怎样集成Spring和Hibernate框架？我们可以使用Spring ORM模块来集成Spring和Hibernate框架，如果您正在使用Hibernate 3+，SessionFactory提供当前会话，那么您应该避免使用HibernateTemplate或HibernateDaoSupport类，并更好地使用依赖注入的DAO模式进行集成。 Spring ORM还提供对使用Spring声明性事务管理的支持，所以您应该利用这一点，而不是使用hibernate的锅炉代码进行事务管理。 为了更好地理解，您应该请阅读以下教程： Spring Hibernate集成示例Spring MVC Hibernate集成示例 43. Spring Security是什么？Spring Security框架关注的焦点是在java应用程序中提供身份验证和授权。 它解决了大多数常见的安全漏洞问题，如CSRF攻击。 通过使用注解,如@EnableWebSecurity ，在Web应用程序中使用Spring Security是很有好处的且易于使用。 您应该通过以下文章来了解如何使用Spring Security框架。 Servlet Web应用程序中的Spring SecuritySpring MVC和Spring Security集成示例 44. 怎样注入一个java.util.Properties到Spring Bean？我们需要定义propertyConfigurer bean，该bean将从给定的属性文件加载属性。 然后我们可以使用Spring EL支持将属性注入其他bean依赖关系。 例如;12345678&lt;bean id=\"propertyConfigurer\" class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\"&gt; &lt;property name=\"location\" value=\"/WEB-INF/application.properties\" /&gt;&lt;/bean&gt; &lt;bean class=\"com.journaldev.spring.EmployeeDaoImpl\"&gt; &lt;property name=\"maxReadResults\" value=\"$&#123;results.read.max&#125;\"/&gt;&lt;/bean&gt; 如果您使用注解来配置spring bean，则可以像下面那样注入属性。12@Value(\"$&#123;maxReadResults&#125;\") private int maxReadResults; 45. Spring框架使用哪些设计模式？Spring框架正在使用很多设计模式，其中一些常见的是： 单例模式：创建具有默认范围的bean。 工厂模式 ：Bean Factory类 原型模式 ：Bean作用域 适配器模式 ：Spring Web和Spring MVC 代理模式 ：Spring Aspect面向编程支持 模板方法模式 ：JdbcTemplate，HibernateTemplate等 前端控制器：Spring MVC DispatcherServlet 数据访问对象：Spring DAO支持 依赖注入和面向方面的编程 46. Spring框架有些什么最佳实践？Spring Framework的一些最佳实践是： 避免模​​式引用中的版本号，以确保我们有最新的配置。 根据spring-jdbc.xml，spring-security.xml等关注的问题来分隔spring bean配置。 对于在Spring MVC中的多个上下文中使用的spring bean，在根上下文中创建它们并使用listener进行初始化。 尽可能多地配置bean依赖关系，尽量避免自动装配。 对于应用程序级属性，最佳方法是创建一个属性文件，并在spring bean配置文件中读取它。 对于较小的应用程序，注解是有用的，但对于较大的应用程序注解可能会变得很痛苦。 如果我们在xml文件中有所有配置，维护它将会更容易。 为组件使用正确的注解，轻松了解其意图。 对于服务，使用@Service和DAO bean使用@Repository。 Spring框架有很多模块，使用你需要的。 删除通过Spring Tool Suite模板创建项目时添加的所有额外的依赖项。 如果您正在使用Aspects，请确保连接点范围尽可能的窄，以避免对不需要的方法的发送通知。 考虑更容易使用的自定义注解，可以避免任何问题。 当有实际利益时，使用依赖注入，只是为了松散耦合而不使用它，因为它更难维护。 这就是Spring Framework面试的问题。 我希望这些问题能帮助您进行Java EE面试。 一旦有新的面试问题我将即时更新！ 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,spring,interview,面试","slug":"java-spring-interview-面试","permalink":"/tags/java-spring-interview-面试/"}]},{"title":"Spring Boot热部署：spring-boot-devtools","slug":"spring-hot-deploy","date":"2018-11-26T05:54:44.878Z","updated":"2018-06-22T02:24:26.719Z","comments":true,"path":"2018/11/26/spring-hot-deploy/","link":"","permalink":"/2018/11/26/spring-hot-deploy/","excerpt":"spring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是热部署。","text":"spring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是热部署。 当我们修改了classpath下的文件（包括类文件、属性文件、页面等）时，会重新启动应用（由于其采用的双类加载器机制，这个启动会非常快，另外也可以选择使用jrebel）。 spring-boot-devtools使用了两个类加载器来实现重启（restart）机制： base类加载器（base ClassLoader）, restart类加载器（restart ClassLoader）。 base ClassLoader：用于加载不会改变的jar（eg.第三方依赖的jar） restart ClassLoader：用于加载我们正在开发的jar（eg.整个项目里我们自己编写的类）。当应用重启后，原先的restart ClassLoader被丢掉、重新new一个restart ClassLoader来加载这些修改过的东西，而base ClassLoader却不需要动一下。这就是devtools重启速度快的原因。 使用devtools，需要添加其依赖即可 : 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 默认情况下，/META-INF/maven，/META-INF/resources，/resources，/static，/templates，/public这些文件夹下的文件修改不会使应用重启，但是会重新加载（devtools内嵌了一个LiveReload server，当资源发生改变时，浏览器刷新）。 另外，使用Intellij的可能会遇到这个问题，即使项目使用了spring-boot-devtools，修改了类或者html、js等，idea还是不会自动重启，非要手动去make一下或者重启，就更没有使用热部署一样。出现这种情况，并不是你的配置问题，其根本原因是因为Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。 首先，IDEA设置里面Setting-&gt;Builder,Excution,Deployment-&gt;Compiler的Make project automatically，把这个选项打勾 然后 Shift+Ctrl+Alt+/(Mac: Shift+Command+Alt+/)，选择Registry把compiler.automake.allow.when.app.running 打勾 OK了，重启一下项目，然后改一下类里面的内容，IDEA就会自动去make了。","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,spring,spring boot,spring-boot-devtools,热部署","slug":"java-spring-spring-boot-spring-boot-devtools-热部署","permalink":"/tags/java-spring-spring-boot-spring-boot-devtools-热部署/"}]},{"title":"在Linux中后台运行进程的几种方法","slug":"run-backgroud-process-sereral-ways","date":"2018-11-26T05:54:44.871Z","updated":"2018-02-13T04:30:33.113Z","comments":true,"path":"2018/11/26/run-backgroud-process-sereral-ways/","link":"","permalink":"/2018/11/26/run-backgroud-process-sereral-ways/","excerpt":"第二次碰到需要在后台运行进程，主要解决用telnet/ssh登录Linux服务器后，让一些程序一直运行，不受关闭终端/网络断开连接影响而不能使用。以下给出了多种方法，分别适用于不同场景。","text":"第二次碰到需要在后台运行进程，主要解决用telnet/ssh登录Linux服务器后，让一些程序一直运行，不受关闭终端/网络断开连接影响而不能使用。以下给出了多种方法，分别适用于不同场景。 nohupnohup 的用途就是让提交的命令忽略 hangup 信号12345nohup ping lexiangmiao.com &amp; nohup ping lexiangmiao.com &gt;log.txt&gt;&amp;1 &amp;ps -ef |grep lexiangmiao.com setsid用一新的会话运行程序123setsid ping lexiangmiao.comps -ef |grep lexiangmiao.com &amp;使用()和&amp;小技巧可以实现后台稳定运行 ()可以运行多个命令 123456# 终端关闭（收到 HUP即hangup信号）后就其子进程也关闭了ping lexiangmiao.com &amp;# 新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了(ping lexiangmiao.com &amp;)ps -ef |grep lexiangmiao.com disown1234cp -r testLargeFile largeFile &amp;jobs# 指jobs查出的编号disown -h %1 screen已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？ 用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名） 123456screen -r Urumchiping www.ibm.com &amp;## 查看依赖关系树pstree -H 9488 总结综上所述，nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。 ref","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"/categories/linux/"}],"tags":[{"name":"linux,process,后台运行","slug":"linux-process-后台运行","permalink":"/tags/linux-process-后台运行/"}]},{"title":"研发人员的绩效考核","slug":"research-and-development-personnel-performance-appraisal","date":"2018-11-26T05:54:44.852Z","updated":"2018-01-17T03:11:09.813Z","comments":true,"path":"2018/11/26/research-and-development-personnel-performance-appraisal/","link":"","permalink":"/2018/11/26/research-and-development-personnel-performance-appraisal/","excerpt":"很多企业的绩效考核工作常常会面临这样的问题：相对其他部门，研发部门的考核指标提取、考核方式确定都有一定的难度。这也是人力资源专业人员和研发部门管理者困惑的难题。","text":"很多企业的绩效考核工作常常会面临这样的问题：相对其他部门，研发部门的考核指标提取、考核方式确定都有一定的难度。这也是人力资源专业人员和研发部门管理者困惑的难题。 曾经有企业试图对研发人员实行完全的定量考核，甚至提出以编写软件代码的行数作为一个重要考核指标，结果员工开始将一个命令可以解决的问题，拆分为几个命令，于是 “大家都很忙，疲于写程序，工作结果完全超过了预期目标，但是软件的功能却没有实现”，完全背离了绩效考核设计的初衷，考核不得不紧急叫停。虽然这种方式停止了，但如何公正客观地评价研发人员工作业绩的问题却依然摆在管理者面前。 研发人员考核难在哪里研发人员考核的困难主要集中于以下几点： 绩效指标提取困难，由于研发人员工作本身的独特性以及工作成果不易衡量，因此难以提炼直观量化的数字性指标； 工作内容界定困难，特别是预研人员，一些成果仅仅是证明某种试试验或测试方法可行与否，证实与证伪具有同样的价值，难以在任务下达之前予以明确； 定性内容较多，影响考核的公正性； 考核方式的选取问题，很多企业的研发管理者为了回避考核的难题，而采取背后打分、不沟通的方式。 面临如此多的问题，如何对研发人员进行业绩评价呢？其实，考核中最为关键的是指标和评价方式，这两者是员工工作的向导和公司的价值取向，出不得偏差，否则就可能事倍功半，甚至劳而无功了。这里，我们也从这两点出发，分析研发人员的指标提炼和评价方式。 怎样提炼绩效指标任何一项工作的展开必然是这样的思路：”正确的行为，沿着正确的道路，达成正确的结果”，提炼绩效指标也需要沿着这样的逻辑关系，从研发成果向前推出成功的路径以及正确的行为要求，具体见下图。 研发人员的考核指标可以界定为两个方面：一个是效益指标，一个是效率指标。效益指标是研发的成果在市场中产生的价值反映，如产品销售额、市场占有率等。效率指标则是指公司内部的研发效率和阶段成果完成情况，包括路径指标和行为指标，具体如产品开发周期、研发费用、产品规划符合度、批次整改率、单板/整机直通率、产品数据准确率等等。绩效指标提炼的过程实际上就是管理程序和工作流程的分析过程： 路径指标路径指标是衡量研发过程是否符合总体研发规划的过程检测指标。 从研发的整体流程环节看，虽然研发的成果不同，但是他们所遵循的程序是一致的，明确每一环节的关键监控点，也就可以形成考核的路径指标。这些路径指标的达成保证了最终结果的实现。 产品开发周期、研发费用等指标比较易于理解，产品规划符合度指标虽然不多见，却非常重要，下面是某公司对此的界定（见表一）。 统计方法:1.路标和0级计划、1级计划基本数据和经过更改认可后的数据。 2.在进行决策点评审（主要是概念决策评审）时，对照路标和0级计划、1级计划，检查是否在规划范围内以及时间偏差，在会议纪要中说明：(1) 本版本是否计入非正常增删版本数；(2) 本版本是否计入未按路标执行的版本数；(3) 本版本启动时间与规划的时间偏差（天）；(4) 本版本与路标偏差的情况分析（包括情况说明、反映出的问题、改进措施等）。 行为指标行为指标是研发过程中对正确职业行为的评价指标。 正确的路径还需要有正确的行为方式，许多公司重视研发过程性内容的积累和知识共享平台的搭建，这些内容就要求员工在研发的过程中关注文档的积累、数据的准确、程序的明晰记录等等。因此，可以设置文档完整率、项目报告完整性、数据差错分析等指标，以提出对研发人员具体行为的要求，这些也是许多职业化通道方案设计时需要分析的内容。如果公司已经建立了研发人员的职业发展路径标准，许多行为指标是可以从中提炼的。 效益指标作为经济性的组织，任何一个研发成果都必须在市场上实现价值，效益指标就是用来评价产品对公司带来的价值和客户对其的认同度，例如产品销售额、市场占有率、客户满意度、产品故障率等等。由于这些指标具有明显的滞后性，不能即期反映研发的成果，因此，这种指标的使用更多要和公司的中期激励方案相结合，具有明显的项目制考核指标的特点。 同时，效益指标不适用于研发部门的个人考核，因为研发成果往往是团队合作的产物，作为部门、事业部、项目开发团队的考核更为合适。 如何选择考核方式研发工作由于贡献特点和侧重点不同，在考核方式上可重点区分部门团队考核与员工个人考核两种。 部门团队考核在研发工作中，部门、团队为基本的业务单元，对直接产品和最终产品的市场价值负有责任。因此，对部门、团队考核侧重的要素为效益指标和路径指标。但因为效益指标的滞后性问题，在整体的考核周期的设计上需要认真考虑以下两点： 对于效益指标，采取按项目周期进行考核的方式。许多研发成果的好坏是在项目结束之后一段时间体现出来，这部分指标的考核要在这个周期之后进行。 对于路径指标，采取按固定时间段进行考核的方式，多数为季度，以保证产品的研发过程符合公司预定的目标。 其中，路径指标占整体考核成绩的50％～70％，甚至更高，以体现公司的业绩导向和市场导向。为此，公司在奖金分配制度上也需要做相应的考虑，以配合这样的考核方式。 员工个人由于研发成果更多属于团队合作的结果，每位研发人员只是负责最终成果的某个功能模块或某个环节，甚至有的研发人员不清楚自己的工作输出在最终产品中所起到的作用。他们的考核主要侧重点在于行为指标和路径指标。因此，结合这种工作特点和考核侧重点，可以采用PBC（Personal Business Commitment个人业绩承诺）评价方式。PBC的程序是：设定清晰的目标，并承诺为实现目标采取的具体策略和措施，以及对团队建设的贡献，并通过对这些承诺进行评价来考核研发人员。 PBC的重要特点就是将目标与实现的行为要素紧密结合起来，更像是一种计划考核，强调了行为和团队合作的重要性。其具体操作方式如下： 建立PBC目标考核周期（一般为季度）之初，直接主管或是项目组组长交流部门或是项目组的工作目标，然后员工根据团队目标制定个人的工作目标。这些目标应该是简洁、易于考核、基于结果的，一般通过WIN、EXECUTE、TEAM三个层次来表达: 赢的承诺：为了支持部门或是项目组工作目标的完成，你必须做些什么。指标主要是行为指标和路径指标的结合。 执行的承诺：通过什么方法完成你赢的承诺呢？必须分析为了达成目标，需要采取的策略、方法以及对工具的需求，形成清晰的执行方案，并且有明确的时间限制和规定，若承诺按照计划按时执行，就能保证实现赢的承诺。 团队的承诺：为了同团队成员更好地合作，更加高效地完成赢和执行的承诺，员工应该做些什么。高效的团队工作需要有好的交流、参与、理解和相互支持，以一个整体去完成工作，保证团队成果的实现。PBC的举例见表二。 过程辅导任何绩效考核工作都不是秋后算帐的评判，在工作的执行过程中，主管要即时给予员工支持和辅导，帮助员工解决问题和提升能力，这一点在一般的考核评价方式中都有介绍，在此不再赘述。 考核评价依据考核周期之初确定的业绩承诺，主管对员工的整个工作情况进行评价，员工的绩效考核以目标完成结果为依据，考核的等级将影响员工的价值回报。 部门团队与个人考核的关系部门团队的考核与员工个人的考核虽然在考核周期和侧重点上不同，但两者不是孤立的，只有员工个人的业绩达成了，才能保证整个组织绩效的实现。为此，针对部门团队绩效考核的中期激励方案必须体现出员工个人的价值回报，保证两者成为有机的整体。 原文","raw":null,"content":null,"categories":[{"name":"management","slug":"management","permalink":"/categories/management/"}],"tags":[{"name":"java,class loader,类加载器","slug":"java-class-loader-类加载器","permalink":"/tags/java-class-loader-类加载器/"}]},{"title":"如何快速搭建linux运行环境","slug":"quickly-set-up-linux-in-virtualbox","date":"2018-11-26T05:54:44.837Z","updated":"2018-02-09T14:54:36.963Z","comments":true,"path":"2018/11/26/quickly-set-up-linux-in-virtualbox/","link":"","permalink":"/2018/11/26/quickly-set-up-linux-in-virtualbox/","excerpt":"对于程序员来说，很可能用linux作为服务器运行环境，为了提前发现问题不可避免的需要搭建一套linux运行环境，此文给出一个可行、快速且经济的解决方案。","text":"对于程序员来说，很可能用linux作为服务器运行环境，为了提前发现问题不可避免的需要搭建一套linux运行环境，此文给出一个可行、快速且经济的解决方案。 目标 在VirtualBox中安装好CentOS 7 可实现主机到虚机的双向复制和文件共享 方案环境 win7 VirtualBox 5.2.6 CentOS 7 32位镜像 实施步骤1 下载VirtualBox打开virtualbox官网 ，选择windows hosts下载到本地，安装完成进行到下一步。 2 下载Linux镜像打开osboxes官网 ,打开CentOS链接，找到linux 32bit下载。也可以下载64bit据自身机器情况而定。 3 创建虚拟电脑打开VirtualBox-&gt;新建-&gt;CentOS-&gt;…-&gt;使用已有虚拟硬盘-&gt;选择已下载的Linux镜像*.vdi文件-&gt;..-&gt;直至完成。 4 系统初始化设置按提示进行系统设置，最后输入osboxes.org作为用户密码，登入Linux系统即完成搭建。 5 安装增强功能安装设备-&gt;安装增强功能-&gt;直至完成。 设置共享剪切板设备-&gt;共享剪切板-&gt;双向 设置共享目录设备-&gt;共享文件夹-&gt;设置共享目录。 1234--挂载mount -t vboxsf hostDirectoryName virtualDirectoryPath--解挂umount virtualDirectoryPath 挂载解决办法问题：/sbin/mount.vboxsf: mounting failed with the error: No such device 执行以下命令 12345678yum clean allyum updateyum install kernelyum install kernel-develyum install kernel-headersyum install gccyum install make reboot 参考 3 延伸阅读设置系统启动后进入文本界面：1systemctl set-default multi-user.target 设置系统启动后进入图形界面：1systemctl set-default graphical.target 重启系统：1systemctl reboot 以文本界面启动后，执行以下命令启动图形界面：1startx 快捷方式Ctrl + Alt + F2 切换到文本界面Ctrl + Alt + F1 切换到图形界面Ctrl + Alt + backspace 重启当前图形界面 参考 进入setting设置termial终端打开快捷键为alt+F12Setthings-&gt;Keyboard-&gt;add command-&gt;Name “Terminal” Command “/usr/bin/gnome-terminal”-&gt;Shortcuts-&gt;输入alt+F12。","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"/categories/linux/"}],"tags":[{"name":"linux,VirtualBox,VirtualBox image,CentOS","slug":"linux-VirtualBox-VirtualBox-image-CentOS","permalink":"/tags/linux-VirtualBox-VirtualBox-image-CentOS/"}]},{"title":"ORM常用的设计模式","slug":"orm-common-pattern","date":"2018-11-26T05:54:44.818Z","updated":"2018-01-12T09:16:20.151Z","comments":true,"path":"2018/11/26/orm-common-pattern/","link":"","permalink":"/2018/11/26/orm-common-pattern/","excerpt":"ORM(Object Relational Mapping)即对象关系映射，一种用于实现对象语言与不同类型的关系型数据之间的转换。","text":"ORM(Object Relational Mapping)即对象关系映射，一种用于实现对象语言与不同类型的关系型数据之间的转换。 我们讨论该问题目的在于如何让我们系统中的对象与数据库进行交互。由于数据库与对象之间存在着结构上的差异，Mapping是相当困难的。不推荐开发人员自己进行Mapping Layer的开发，这是危险的也是及其可能失败的。更加推荐购买专业的工具，虽然这些工具通常很昂贵。到目前为止，我所接触的项目确实有Mapping layer，但它并不是典型的Mapping layer between Relational Database and Object，它是处于JSP页面与Database之间的Mapping，用于自动地将用户在页面上填写的数据更新到数据库中。这在Web项目中是很好用的，但目前这个Mapping Layer还不能做到general，它只能适用与特定的Web Application架构。 下面开始与大家聊聊三种Database Mapping层的常用的系统架构。 1. 网关模式（Gateway）之所以称之“网关”，顾名思义，Mapping层扮演着一个代理的角色，应用逻辑层无需知道具体Mapping的细节，而只需通过网关的公共接口，提交数据更新或者数据加载请求，由网关去执行具体的Object到Record或者Record到Object的转换。从而实现了数据层的透明。应用逻辑层所要了解的只有网关的信息和其公共接口。使用公共接口同时有助应用逻辑代码在不同的数据层的复用：无需改变应用逻辑层的任何代码，只需为特定的数据层实现特定的网关。网关模式具体分为两种：Row Data Gateway &amp; Table Data Gateway 共同的特点： 对应于数据库中的每个Table，有一个Mapping Class，并且在这个class中每个column有其对应的字段；所有的数据库mapping代码都存在于在Mapping Class之中，使数据库访问代码与应用逻辑完全分离； Row Data GatewayMapping Class是一个对应于数据库中某张表格的一条记录。记录的每个字段对应于Class中的一个Field。所有访问数据的细节都被封装在这个接口中。Row Data Gateway与Transaction Script配合使用，效果很好 典型案例: Java中的SessionBean（Transaction Script）和EntityBean（Row Data Gateway） 适用情况：应用逻辑相对复杂，对象与对象之间交互繁多的大规模系统； Table Data Gateway：这个接口定义了关于某个Table的所有查询（find），更新，插入和删除代码。Table Data Gateway将输入的参数mapping成对应的SQL，并执行SQL，最后返回适当的数据结构。如何返回Query的信息是一个具有欺骗性的决策问题。当需要返回多个记录并且函数只允许返回一个结果时，你将面临着多种选择：Map &amp; Data Transfer Object &amp; Record Set。 Map：不是一个好方法，map中的Key常常是一种HardCode； Data Transfer Object：是避免map的一个方法，并且可以被重用； Record Set：虽然会使Business Logic Layer不能完全与数据库访问层相分离，但是如果我们的开发平台有很多基于Record Set的工具，采用它不失为一个好方法（.NET）。 典型案例：Window DNA架构； 适用情况：以显示信息，修改信息为功能的MIS（信息管理系统）； 2. 活动记录模式（Active Record）将Business Logic与数据库访问放置于同一个Business Object中。这种模式出现的原因是业务逻辑与数据库模型非常相似。Active Record同时负责数据库存取和基于这些数据的应用逻辑的执行。应用程序的所有逻辑可以都在Active Record中，也可以是部分。有一点是默认前提，Active Record的数据结构和数据库Schema必须保持一致（在我看来这是个缺点！） Active Record中通常有以下方法： 从SQL数据集创建Active Record的构建方法； 静态的finder方法用于封装SQL查询并且返回Active Record记录； 用Active Record中的数据更新数据库的方法； 所有字段getting和settting方法； 实现应用逻辑的方法； 活动记录模式的优点在于简单，其缺点在于没有隐藏数据库层，从而导致很难应用其他OR Mapping模式在活动记录模式之上。另外一方面，活动记录模式与Row Data Gateway的区别在于数据库存取代码是在Business Object中（Active Record）还是在一个单独的Mapping Class中（Row Data Gateway），当然也有同时存在于两者的情况；如果应用逻辑的复杂程度迫使你适用面向对象的一些机制（Direct relationships，collections and Inheritance），这时直接将数据库存取代码置于Business Object中，由于有大量的转换，会使事情变得混乱，这时应该适用Data Mapper。 但这并不是个好方法，因为它将面向对象设计和数据库设计紧密耦合在一起，这随着项目进展会使对设计的重构工作变得及其困难。通常我们会将数据库访问代码分离到一个Gateway中。有一种情况例外，当你对Transaction Script &amp; Row Data Gateway的架构进行重构的时候，为了去除Transaction Script中的重复代码，将其放进Row Data Gateway中，这是就转变成Active Record了。 适用情况：当应用逻辑不复杂，主要是创建，更新，插入，删除操作，而且操作主要是针对单条记录时； 3. 数据映射模式（Data Mapper）这是最复杂，但最灵活的一种架构模式。使用Data Mapper，Business Objects可以与数据库结构完全的分离，他们无需知道数据库的结构和数据更新的细节。Data Mapper对于那些无法在关系型数据库表示的对象系统特性非常有效，例如Collection成员结构和继承关系。Data Mapper是内存中对象与数据库之间的媒介。它负责双方之间的数据传输。数据映射模式（Data Mapper）与网关模式最大的（Gateway）最大的区别在于依赖和控制的位置相反。在网关模式中，应用逻辑层需要了解数据库中的数据结构，二在数据映射模式中，应用逻辑无需了解数据库设计，提高了应用层（business logic）和数据层（data source）的分离，便于两者的开发和测试。 面向对象的对象系统与面向关系的关系型数据库是两种异构的结构，因此在对象系统中的很多机制（collections, inheritance等）都无法在关系型数据库中得到直接的表示，这就是数据映射模式产生的原因。在这种情况下，在两种模式下的数据转换变得相当复杂，因此我们有必要将它分层，否则任何一方（对象系统和数据库）的改变都将波及对方。 数据映射层的最大目标就是将业务逻辑（domain）和数据层（data source）分离。整个数据映射层（Data Mapper）完全独立于系统其他部分，可以被完全替换或者允许一个逻辑层重用于不同的数据层上。但要实现它有很多重要的问题必须解决，而且不同人可以采用不同的方法实现这个数据映射模式（Data Mapper）。因此这里只介绍几个重要的实现问题。 ① Finder方法的处理处理方法： 在一个独立的Package中，为Finder方法定义一个接口，然后在数据映射层实现这个接口。逻辑层通过接口调用Finder方法，后者通过数据映射层加载数据。 原因：之所以使用接口的原因，在于使Finder方法标准化，这样应用逻辑层虽然可能在任何地方都会调用Finder方法取得带有数据的Business Object，但却不依赖于数据映射层。 Finder方法：将方法调用转换成SQL查询； 数据映射层：从数据集中获得数据并创建Business Object； 遗留问题： 数据映射层如何知道那些Object被更新了，哪些被创建，哪些被删除了？ 如何控制每次查询获得的记录数，以尽量减少查询的数目？ 其他模式如何用在数据映射层（Lazy Load, Registry, Identity Map）? ② 如何将数据映射到Business Object的字段中数据映射层需要访问Business Object的所有字段，因此这些方法必须被设置为public，但这不不是我们所预想的。这个问题没有明确的答案，几种可选的方法都有两面性。 将数据映射层于逻辑层放置于同一个包下 缺点：有可能使事情变得更混乱； 使用Reflection方法来访问Object的字段 缺点：速度慢； 增加状态标志来保证在数据库加载环境下访问这些字段 针对这个问题，在创建Business Object的时候，你有两个选择，使用胖构造函数（这个名词是我自己取的:^)）空构造函数。 胖构造函数（Rich Constructor） 优点：保证Object至少包含必须的数据；对于常量字段，无需setting方法； 缺点：必须考虑循环引用问题（cyclic reference）； 空构造函数（Empty Constructor） 优点：不会出现循环引用问题（cyclic reference）； 缺点：对于常量字段，仍然需要setting方法，可能引入潜在错误； ③ 基于元数据的映射（Metadata based Mapping） 显式代码：这要求每个Business Object有一个Mapping class； Metadata Mapping：元数据被存储在单独的class和文件中，我倾向于文件，随着xml的广泛使用，以XML形式存储元数据会增强移植性； 3种OR Mapping架构模式的取舍和选用OR Mapping架构取决于应用逻辑层的架构。如果使用表模式（Table Module）来组织应用逻辑，那么Table Data Gateway是你的最佳选择；如果使用Transaction Script模式来组织应用逻辑，那么如果开发平台提供了使用数据集的方便就采用Table Data Gateway，否则采用Row Data Gateway；如果是使用Domain Model来建立应用逻辑模型，那么对于复杂的大系统，颖毫不犹豫地选择数据映射模式，对于逻辑简单的小系统，Active Record也是一个可选方案。","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"orm,gateway pattern, active record pattern, data mapper pattern,对象关系映射， 网关模式, 活动记录模式 , 数据映射模式","slug":"orm-gateway-pattern-active-record-pattern-data-mapper-pattern-对象关系映射，-网关模式-活动记录模式-数据映射模式","permalink":"/tags/orm-gateway-pattern-active-record-pattern-data-mapper-pattern-对象关系映射，-网关模式-活动记录模式-数据映射模式/"}]},{"title":"nodejs常用命令","slug":"nodejs-usefully-command","date":"2018-11-26T05:54:44.809Z","updated":"2018-01-22T04:38:36.864Z","comments":true,"path":"2018/11/26/nodejs-usefully-command/","link":"","permalink":"/2018/11/26/nodejs-usefully-command/","excerpt":"收集平时常用的一些nodejs命令。","text":"收集平时常用的一些nodejs命令。 怎样升级node版本Linux/Mac12sudo npm install n -gsudo n 0.12.2 升级到稳定版本:1sudo n stable 升级到最近版本：1sudo n latest Windows从node官网下载.msi重新安装即可","raw":null,"content":null,"categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"nodejs,nodejs命令","slug":"nodejs-nodejs命令","permalink":"/tags/nodejs-nodejs命令/"}]},{"title":"mybatis列映射的几种方式","slug":"mybatis-columns-mapping","date":"2018-11-26T05:54:44.788Z","updated":"2018-01-12T09:20:30.837Z","comments":true,"path":"2018/11/26/mybatis-columns-mapping/","link":"","permalink":"/2018/11/26/mybatis-columns-mapping/","excerpt":"不同于hibernate实现活动记录模式，mybatis实现了数据映射模式，其中列的映射有多种实现方式，有简单的也有复杂的，分别适用不同的业务场景","text":"不同于hibernate实现活动记录模式，mybatis实现了数据映射模式，其中列的映射有多种实现方式，有简单的也有复杂的，分别适用不同的业务场景 1. 使用注解@Results和@Result1234567891011121314@Mapperpublic interface UserDao &#123; @Select(\"SELECT * FROM users\") @Results(&#123; @Result(property = \"firstName\", column = \"first_name\"), @Result(property = \"lastName\", column = \"last_name\") &#125;) List&lt;User&gt; findUsers(); @Select(\"SELECT * FROM users\") @ResultMap(\"BaseResultMap\") List&lt;User&gt; findUsers1();&#125; XML配置如下1234&lt;resultMap id=\"BaseResultMap\" type=\"package.for.User\"&gt; &lt;result property = \"firstName\", column = \"first_name\" jdbcType=\"VARCHAR\" /&gt; &lt;result property = \"lastName\", column = \"last_name\" jdbcType=\"VARCHAR\" /&gt; &lt;/resultMap&gt; 优点 映射关系简单明了 缺点 相同实体类型的返回变多之后，注解的工作量加大，容易不同步和出错 避免重复的话，需要与XML配置结合，如此一来，由于使用两种方式感觉麻烦了 2. 使用别名123456789101112@Mapperpublic interface UserDao &#123; @Select(\"SELECT first_name as firstName, last_name as lastName FROM users\") List&lt;User&gt; findUsers(); @Select(&#123; \"SELECT\", \" first_name as firstName,\", \" last_name as lastName\", \"FROM users\"&#125;) List&lt;User&gt; findUsers1();&#125; 优点 最直接，简单明了 缺点 多人开发，可能带来db命名的不规范 3. 使用全局配置在application.properties中，增加以下配置1mybatis.configuration.mapUnderscoreToCamelCase=true 或者使用自定义配置Bean12345678@BeanConfigurationCustomizer mybatisConfigurationCustomizer() &#123; return new ConfigurationCustomizer() &#123; public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;;&#125; 优点 全局设置之后，只要遵守下划线映射到驼峰命名规范，就省出了大量的手动映射工作 缺点 对已有老系统无按此规则的db，无法映射 4. 使用XML映射XML配置如下1234567891011&lt;resultMap id=\"BaseResultMap\" type=\"package.for.User\"&gt; &lt;result property = \"firstName\", column = \"first_name\" jdbcType=\"VARCHAR\" /&gt; &lt;result property = \"lastName\", column = \"last_name\" jdbcType=\"VARCHAR\" /&gt; &lt;/resultMap&gt;&lt;select id=\"findUsers\" resultMap=\"BaseResultMap\"&gt; SELECT * FROM users WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"findUsers1\" resultType=\"package.for.User\"&gt; SELECT * FROM users WHERE ID = #&#123;id&#125;&lt;/select&gt; java就不需要再一一配置了12345@Mapperpublic interface UserDao &#123; List&lt;User&gt; findUsers(); List&lt;User&gt; findUsers1();&#125; 优点 字段映射关系和对象完全分离 缺点 XML硬编码，维护内容多时容易出错 总结以上各种方法各有优劣，完全注解方式硬编码少，维护不容易出错。完全XML方式更加灵活，可以发布之后变动。具体使用单个或者混合方式取决于具体业务场景。 参考:MyBatis-Spring-Boot-Starter介绍","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,mybatis,columns mapping,列映射","slug":"java-mybatis-columns-mapping-列映射","permalink":"/tags/java-mybatis-columns-mapping-列映射/"}]},{"title":"model","slug":"model","date":"2018-11-26T05:54:44.759Z","updated":"2018-04-11T13:49:29.141Z","comments":true,"path":"2018/11/26/model/","link":"","permalink":"/2018/11/26/model/","excerpt":"model","text":"model 后台架构数据概述今日订单数总数 今日营业额 今日ip访问量 今日新增会员 今日新增代言人 今日新增合伙人 今日新增董事 今日已发货 累计营业额 累计订单数 累计用户人数 累计分公司数 累计董事数 累计合伙人数 累计代言人数 累计用户数 实时订单地图显示 订单管理待发货订单编号 姓名 时间 收货人 收货电话 收货地址 产品名称 产品数量 产品型号 订单留言 支付方式 支付宝 微信支付 银联支付 预付款支付 预付款支付不计算业绩 订单处理代理 规则 下级提交上级 同级提交上级 董事提交公司 订单提交第一个预存款级别扣除, 然后订单到仓库 预存款扣除金额 上级处理 未处理 已处理 发货状态 未发货 物流公司 无 快递单号 无 操作 修改 删除 仓库发货订单已发货已完成订单作废订单学习订单会务费 订单编号 姓名 时间 联系电话 产品数量 产品型号 订单留言 支付方式 支付宝 微信支付 银联支付 上级名字 订单详情 会务费 课程付费 操作 修改 删除 课程费 订单编号 姓名 时间 联系电话 产品数量 产品型号 订单留言 支付方式 支付宝 微信支付 银联支付 上级名字 订单详情 会务费 课程付费 操作 修改 删除 预存款管理预存款审核ID 名字 级别 上级董事或分公司 预存款金额 预存款时间 公司处理 已处理 通过审核则计算业绩 未处理 公司处理人 添加预存款ID 名字 级别 上级董事或分公司 预存款金额 添加预存款则计算业绩 预存款时间 公司添加人 预存款消费记录ID 名字 级别 上级董事或分公司 预存款金额剩余 预存款消费记录 代理管理代理管理添加代理备份代理搜索代理级别 代言人 合伙人 董事 名字/id/电话号码 代理信息ID号 姓名 电话 微信号 注册时间 级别 钱包 预存款 购买记录 可提现金额 预存款变现 营销收入 计算方法 有预存款 预存款减去进货金额 可提现金额出现支付金额 没有预存款 可提现金额出现支付金额 营销收入明细 个人销售收入 零售价减去进货价 代理销售 当前级别进货金额减去下级代理进货金额 公司返点 返点规则 董事级别 下级董事每销售一盒奖励6元 下级董事的下级董事销售一盒奖励6元 最多两级董事 成为董事业绩断开 合伙人级别 下级合伙人每销售一盒奖励6元 下级合伙人的下级合伙人销售一盒奖励6元 最多两级合伙人 成为董事业绩断开 每位合伙人返点一笔金额则上级董事返点金额里减去相等金额 代言人没有公司返点 月份收入记录 提现记录 上级董事 上级合伙人 邀请人数 下级代理树 下级代理/会员列表 画出关系树 状态 正常 冻结 不可以提现 待审核 会员主页 时间 历史时间 BMI 历史记录 体脂率 历史记录 体水分 历史记录 固含量 历史记录 基础代谢 历史记录 内脏脂肪 历史记录 身体年龄 历史记录 蛋白率 历史记录 标准体重 历史记录 脂肪量 历史记录 肌肉量 历史记录 蛋白量 历史记录 肥胖等级 历史记录 积分 操作 通过 修改 删除 代理审核（同上代理信息）代理关系代理树图 新晋代理新晋统计表格 代理发展统计每月新增代理发展统计曲线图 分公司管理分公司管理添加分公司备份分公司搜索代理级别 代言人 合伙人 董事 名字/id/电话号码 分公司信息ID号 姓名 电话 微信号 注册时间 级别 钱包 同前所述 上级董事 上级合伙人 邀请人数 下级代理树 下级代理/会员列表 画出关系树 状态 正常 冻结 不可以提现 待审核 健康数据 同前所述 分公司审核（同上代理信息）会员管理同前所述 （分公司管理） 业绩查询搜索查找时间 id号 名字 电话 分公司ID 名字 级别 上级董事或分公司 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 董事ID 名字 级别 上级董事或分公司 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 合伙人ID 名字 级别 上级董事或分公司 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 代言人ID 名字 级别 上级合伙人 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 商品管理商品管理添加商品商品名称 商品规格 商品型号 商品图片 商品详情 商品属性 正品销售 积分兑换 商品价格 统一零售价 代言人价格 合伙人价格 董事价格 是否计算业绩 是否扫码发货 是否上架下架 商品列表商品名称 商品规格 商品型号 商品属性 正品销售 积分兑换 商品价格 统一零售价 代言人价格 合伙人价格 董事价格 是否计算业绩 是否扫码发货 是否上架下架 库存数量 不可修改 操作 删除 修改 库存管理商品列表商品名称 商品规格 商品型号 商品价格 统一零售价 代言人价格 合伙人价格 董事价格 是否计算业绩 是否扫码发货 是否上架下架 库存数量 入库 出库发货记录每日订单发货详情 素材管理商学院添加素材 添加素材 音频 图文标题 作者 图文封面 上传图片 简介 销售模式 作为单篇销售 价格： 作为专栏内内容 选择专栏 代理专项 董事 合伙人 代言人 是否上架 完整音频 图文详情 视频 图文标题 作者 图文封面 上传图片 简介 销售模式 作为单篇销售 价格： 作为专栏内内容 选择专栏 代理专项 董事 合伙人 代言人 是否上架 完整视频 图文详情 添加专栏 专栏名称 作者 专栏封面 专栏介绍 价格 专栏详情介绍 素材列表 内容列表 内容名称 销售数量 状态 已上架 未上架 上架时间 操作 编辑 删除 专栏列表 专栏名称 已更新篇数 销售数量 状态 已上架 未上架 上架时间 操作 编辑 删除 一键转发朋友圈素材添加素材日期 文字 图片或视频 历史素材列表搜索 按日期 日期 文字 图片或视频 操作 删除 修改 晒场搜索 id 姓名 电话 列表 id 姓名 电话 粉丝 关注 评论 帖子内容 会员主页 同前所述 推荐精选 推荐 正常 状态 正常 举报 操作 删除 操作 是否推荐精选 正常 精选 精选列表 同前列表所述 口碑 口碑列表 同前列表所述 举报 精选列表 同前列表所述 积分管理积分获得记录ID号 姓名 电话 微信号 注册时间 级别 上级董事 上级合伙人 状态 正常 冻结 不可以提现 待审核 邀请人数积分 上称次数积分 购买商品获积分 获积分赏 积分 获积分规则 上称获积分 分享链接推荐新人注册获积分 积分打赏获积分 操作 修改 删除 积分兑换记录ID号 姓名 电话 微信号 注册时间 级别 上级董事 上级合伙人 状态 正常 冻结 不可以提现 待审核 打赏积分使用记录 兑换商品记录 积分结余 获积分规则 上称获积分 分享链接推荐新人注册获积分 积分打赏获积分 操作 修改 删除 财务管理总计月度营业额 详情 月度订单数 详情 月度可提现 详情 月度已打款 详情 月度盈利 详情 搜索查找时间 id号 名字 电话 分公司ID 名字 级别 上级董事或分公司 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 钱包 同前所述 可提现金额 申请提现金额 已经打款金额 打款记录 打款凭证 操作 修改 董事ID 名字 级别 上级董事或分公司 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 钱包 同前所述 可提现金额 申请提现金额 已经打款金额 打款记录 打款凭证 操作 修改 合伙人ID 名字 级别 上级董事或分公司 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 钱包 同前所述 可提现金额 申请提现金额 已经打款金额 打款记录 打款凭证 操作 修改修改 代言人ID 名字 级别 上级董事或分公司 个人销售业绩合计 订单列表 下级所有个人销售业绩合计 名字列表 预存款月总计 钱包 同前所述 可提现金额 申请提现金额 已经打款金额 打款记录 打款凭证 操作 修改 管理员管理添加管理员姓名 电话 身份证号码 职位 登陆账号 登陆密码 使用权限 管理员列表姓名 电话 职位 操作 修改 删除 商品防伪防伪码生成导出唯一防伪码一大箱一个大码 大编码下面N个小编码 已经入库编码扫码入库 未出库编码扫码出库 投诉建议会员投诉 代理投诉 系统管理积分设置上称一次获积分 消费1元获积分 打赏获积分 分享链接获积分 代理返利设置分公司奖励 董事平级奖励 升级门槛设置（千元）分公司 400k 董事 54k 合伙人 9k 代言人 1.28k 代理证书设置","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"/categories/linux/"}],"tags":[{"name":"model","slug":"model","permalink":"/tags/model/"}]},{"title":"maven常用命令","slug":"maven-usefully-command","date":"2018-11-26T05:54:44.750Z","updated":"2017-10-27T09:29:58.798Z","comments":true,"path":"2018/11/26/maven-usefully-command/","link":"","permalink":"/2018/11/26/maven-usefully-command/","excerpt":"收集平时常用的一些maven命令。","text":"收集平时常用的一些maven命令。 清除现有jar包1mvn clear 查看依赖关系maven存在a-&gt;b-&gt;c和e-&gt;f-&gt;c，但此时c的版本不一致时，就需要查看依赖关系。 123mvn dependency:tree -Dverbose -Dincludes=DESIRED-groupId:DESIRED-artifactIdmvn dependency:tree -Dverbose -Dincludes=javax.servlet:javax.servlet-api","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"maven,mvn,maven命令","slug":"maven-mvn-maven命令","permalink":"/tags/maven-mvn-maven命令/"}]},{"title":"maven中重复类冲突解决办法","slug":"maven-duplicate-classes","date":"2018-11-26T05:54:44.730Z","updated":"2017-10-27T09:28:29.728Z","comments":true,"path":"2018/11/26/maven-duplicate-classes/","link":"","permalink":"/2018/11/26/maven-duplicate-classes/","excerpt":"maven引入其他jar的时候常会碰到重得类冲突，一般解决思路是查看依赖关系，排出不需要的jar或类。","text":"maven引入其他jar的时候常会碰到重得类冲突，一般解决思路是查看依赖关系，排出不需要的jar或类。 解决步骤如下 哪两个jar包出现重复类了。 两个jar是依赖哪个组件引入的。 通过mvn命令查找依赖关系。 123mvn dependency:tree -Dverbose -Dincludes=DESIRED-groupId:DESIRED-artifactIdmvn dependency:tree -Dverbose -Dincludes=javax.servlet:javax.servlet-api 解决办法有以下3种： 两个jar包报重复类，如果其中有个jar包是不需要的，则可以通过的方式把它从依赖树中排除，这样重复类问题就被解决了。 如果两个jar包都是需要的，此时需要改造其中一个jar包，消除重复类问题（比如改变类名或者改变package）。如果是第三方组件测修改版本号。 还有一类，是不得以而为之的（不推荐），就是重复类的问题很难解决&amp;&amp;评估下来没必要解决，可通过添加白名单的方式略过重复类问题。","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"maven,mvn,maven命令","slug":"maven-mvn-maven命令","permalink":"/tags/maven-mvn-maven命令/"}]},{"title":"liquibase实现自动升级数据的步骤","slug":"liquibase-upgrade-db-step","date":"2018-11-26T05:54:44.709Z","updated":"2018-02-22T08:52:12.888Z","comments":true,"path":"2018/11/26/liquibase-upgrade-db-step/","link":"","permalink":"/2018/11/26/liquibase-upgrade-db-step/","excerpt":"数据库变化常常发生，怎样协调自动完成增量升级是个不少的挑战，以下方案可行","text":"数据库变化常常发生，怎样协调自动完成增量升级是个不少的挑战，以下方案可行 1 配置好mvn对比数据库1234567891011121314151617&lt;plugin&gt; &lt;groupId&gt;org.liquibase&lt;/groupId&gt; &lt;artifactId&gt;liquibase-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;liquibase.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;changeLogFile&gt;src/main/resources/config/liquibase/master.xml&lt;/changeLogFile&gt; &lt;diffChangeLogFile&gt;src/main/resources/config/liquibase/changelog/$&#123;maven.build.timestamp&#125;_changelog.xml&lt;/diffChangeLogFile&gt; &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt; &lt;url&gt;jdbc:mysql://localhost:3306/lexiangmiaoSite&lt;/url&gt; &lt;defaultSchemaName&gt;lexiangmiaoSite&lt;/defaultSchemaName&gt; &lt;username&gt;root&lt;/username&gt; &lt;password&gt;xxxxx&lt;/password&gt; &lt;referenceUrl&gt;hibernate:spring:com.lexiangmiao.site.domain?dialect=org.hibernate.dialect.MySQL5InnoDBDialect&amp;amp;hibernate.physical_naming_strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy&amp;amp;hibernate.implicit_naming_strategy=org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy&lt;/referenceUrl&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;logging&gt;debug&lt;/logging&gt; &lt;/configuration&gt;&lt;/plugin&gt; 创建支持emoji表情的MySQL数据库 utf8mb4 1CREATE DATABASE `lexiangmiao` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci 2 使用liquibase比较于当前文件与目标对象的差异1mvn liquibase:diff 生成的差异文档与实际需求存在差异，删除不需要的升级，并把升级文档用作升级即可 3 嵌入升级文档并运行升级运行应用即可升级 liquibase diff jhipster db upgrade","raw":null,"content":null,"categories":[{"name":"db","slug":"db","permalink":"/categories/db/"}],"tags":[{"name":"liquibase,db upgrade,数据库升级","slug":"liquibase-db-upgrade-数据库升级","permalink":"/tags/liquibase-db-upgrade-数据库升级/"}]},{"title":"linux常用命令","slug":"linux-usefully-command","date":"2018-11-26T05:54:44.684Z","updated":"2018-05-19T15:32:29.596Z","comments":true,"path":"2018/11/26/linux-usefully-command/","link":"","permalink":"/2018/11/26/linux-usefully-command/","excerpt":"收集平时常用的一些linux命令。","text":"收集平时常用的一些linux命令。 ssh几个超时参数客户端方案Host * ServerAliveInterval 60 服务器方案1vim /etc/ssh/sshd_config #ClientAliveInterval 0改为ClientAliveInterval 500 （每500秒往客户端发送会话请求，保持连接） #ClientAliveCountMax 3 （去掉注释即可，3表示重连3次失败后，重启SSH会话）1systemctl restart sshd #重启sshd服务 http://www.361way.com/ssh-autologout/4679.html 更改密码1$ passwd","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"/categories/linux/"}],"tags":[{"name":"linux,linux","slug":"linux-linux","permalink":"/tags/linux-linux/"}]},{"title":"JVM，JRE和JDK","slug":"jvm-jre-jdk","date":"2018-11-26T05:54:44.663Z","updated":"2017-09-26T04:32:36.622Z","comments":true,"path":"2018/11/26/jvm-jre-jdk/","link":"","permalink":"/2018/11/26/jvm-jre-jdk/","excerpt":"不要只从编程语言的角度来看Java，这只会看到“冰山一角”","text":"不要只从编程语言的角度来看Java，这只会看到“冰山一角” 这可以用Java SE Technologies中的图来印证： 如果你安装JDK，就会安装这全部的东西，而Java Language只是最左上角一小部份。 什么是JVM？在上图中，Platforms表示Solaris、Linux、Windows各种作业系统平台，在这些平台上架构了Java虚拟机，也就是JVM，JVM让Java可以跨平台，但是跨平台是怎么一回事？在这之前，你得先了解不能跨平台是怎么一回事。 对于电脑而言，只认识一种语言，也就是0、1序列组成的机器指令。 当你使用C/C++等高阶语言编写程序时，其实这些语言，是比较贴近人类可阅读的文法，也就是比较接近英语文法的语言。 这是为了方便人类阅读及编写，电脑其实看不懂C/C++这类语言，为了将C/C++翻译为0、1序列组成的机器指令，你必须有个翻译员，担任翻译员工作的就是编译器（Compiler）。 问题在于，每个平台认识的0、1序列并不一样。 某个指令在Windows上也许是0101，在Linux下也许是1010，因此必须使用不同的编译器为不同平台编译出可执行的机器码，在Windows平台上编译好的程序，不能直接拿到Linux等其它平台执行，也就是说，你的应用程序无法达到「编译一次，到处执行」的跨平台目的。 Java是个高级语言，要让电脑执行你编写的程序，也得通过编译器的翻译。 不过Java在编译时，并不直接编译为相依于某平台的0、1序列，而是翻译为中介格式的字节码（Byte code）。 Java源码扩展名为.java ，经过编译器翻译后为扩展名.class的字节码。 如果想要执行字节码文件，目标平台必须安装JVM（Java Virtual Machine）。 JVM会将字节码翻译为相应平台的机器码。 不同的平台必须安装专属该平台的JVM。 这就好比你讲中文（.java），Java编译器帮你翻译为英语（.class），之后这份英语文件，到各国家之后，再由当地看得懂英文的人（JVM）翻译为当地语言（机器码）。 所以 JVM担任的职责之一就是当地翻译员，将字节码文档翻译为当前平台看得懂的0、1序列，有了JVM，你的Java程序就可以达到「编译一次，到处到处执行」的跨平台目的。 除了了解JVM具有让Java程序跨平台的重要任务之外，编写Java程序时，对JVM的重要认知就是： 对Java程序而言，只认识一种作业系统，这个系统叫JVM，字节码文件（扩展名为.class的文件）就是JVM的可执行文件。 Java程序理想上，并不用理会真正执行于哪个平台，只要知道如何执行于JVM就可以了，至于JVM实际上如何与底层平台作沟通，则是JVM自己的事！ 由于JVM实际上就相当于Java程序的作业系统，JVM就负责了Java程序的各种资源管理。 JRE之后会学到的第一个Java程序，其中会有这么一段程序码： System.out.println(“Hello World”); 先前曾经谈过，Java是个标准，System、out、println这些名称，都是标准中所规范的名称，实际上必须要有人根据标准编写出System.java，编译为System.class，如此你才能在编写第一个Java程序时，使用System类别（Class）上out物件（Object）的println()方法（Method）。 谁来实现System.java？ 谁来编译为.class？ 可能是Oracle、IBM、Apache，无论如何，这些厂商必须根据相关的JSR标准文件，将标准程序库实现出来，如此你编写的第一个Java程序，在Oracle、IBM、Apache等厂商实现的JVM上运行时，引用如System这些标准API，你的第一个Java程序，才可能轻易地运行在不同的平台。 在上图中右边可以看到Java SE API ，涵盖了各式常用的程序库，像是通用的群集（Collection）、输入输出、连接数据库的JDBC、编写窗口程序的AWT与Swing等，这些都是在各个JSR标准文件规范之中， Java Runtime Environment就是Java执行环境，简称JRE， 包括了Java SE API与JVM。只要你使用Java SE API中的程序库，在安装有JRE的电脑上就可以直接运行，无需额外在你的程序中再包装标准程序库，而可以由JRE直接提供。 JDK先前说过，你要在.java中编写Java程序语言，使用编译器编译为.class文档，那么像编译器这样的工具程序是由谁提供？ 答案就是JDK，全名为Java Developer Killer ！ 呃！ 不对！ 是Java Development Kit ！ 正如上图所示，JDK包括了javac、appletviewer、javadoc等工具程序，对于要开发Java程序的人，必须安装的是JDK，如此才有这些工具程序可以使用，JDK本身包括了JRE，如此你才能执行Java程序，所以总结就是 JDK包括了Java程序语言、工具程序与JRE，JRE则包括了部署技术、Java SE API与JVM 。 编写Java程序的人才需要JDK，如果你的程序只是想让朋友执行呢？ 那他只要装JRE就可以了，不用安装JDK，因为他不需要javac这些工具程序，但他需要Java SE API与JVM。 对初学者来说，JDK确实很不友善，这大概是Java阵营的哲学，假设你懂得如何准备相关开发环境，因此装好JDK之后，该自己设定的变数或选项就要自己设定，JDK不会代劳，过去戏称JDK全名为Java Developer Killer其实是其来于这。","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"JVM,JRE, JDK,javv虚拟面,java运行时环境,java开发工具包","slug":"JVM-JRE-JDK-javv虚拟面-java运行时环境-java开发工具包","permalink":"/tags/JVM-JRE-JDK-javv虚拟面-java运行时环境-java开发工具包/"}]},{"title":"js对象创建：模式和最佳实践","slug":"js-object-creation-patterns-best-practises","date":"2018-11-26T05:54:44.648Z","updated":"2017-11-15T06:00:47.875Z","comments":true,"path":"2018/11/26/js-object-creation-patterns-best-practises/","link":"","permalink":"/2018/11/26/js-object-creation-patterns-best-practises/","excerpt":"js对象的创建是一个棘手的主题。 这种语言有很多创建对象的风格，新手和老手都会感到不知所措，不知道应该使用哪一种。 但是，尽管每种语法都有不同的语法，但是它们可能比您实现的更类似。 在这篇文章中，我将带您了解各种不同风格的对象创建，以及如何逐步建立对象。","text":"js对象的创建是一个棘手的主题。 这种语言有很多创建对象的风格，新手和老手都会感到不知所措，不知道应该使用哪一种。 但是，尽管每种语法都有不同的语法，但是它们可能比您实现的更类似。 在这篇文章中，我将带您了解各种不同风格的对象创建，以及如何逐步建立对象。 对象字面量（Object Literals）我们游览的第一站是创建对象的绝对最简单的方法，即对象字面量。 js宣称对象可以创建“ex nilo”，无中生有 - 没有类，没有模板，没有原型 - 只是poof，一个包含方法和数据的对象。123456var o = &#123; x: 42, y: 3.14, f: function() &#123;&#125;, g: function() &#123;&#125;&#125;; 但是缺点是：如果我们需要在其他地方创建相同类型的对象，那么我们最终会复制粘贴对象的方法，数据和初始化。 我们需要一种方法来创建不仅仅是一个对象，而是一个对象的家族。 工厂函数（Factory Functions）我们巡演的下一站是工厂函数。这是创建共享相同结构，接口和实现的对象族的绝对最简单的方法。 而不是直接创建对象字面量，而是从函数返回对象字面量。这样，如果我们需要多次或在多个地方创建相同类型的对象，我们只需要调用一个函数。12345678910function thing() &#123; return &#123; x: 42, y: 3.14, f: function() &#123;&#125;, g: function() &#123;&#125; &#125;;&#125;var o = thing(); 但是缺点是：这种方法会导致内存膨胀，因为每个对象都包含每个函数的唯一副本。 理想情况下，我们希望每个对象只能共享一个函数副本。 原型链（Prototype Chains）js为我们提供了一个内置的机制来共享跨对象的数据，称为原型链。当我们访问一个对象的属性时，它可以通过委托给其他对象来满足这个请求。我们可以使用它并更改我们的工厂函数，以便它创建的每个对象只包含该特定对象唯一的数据，并将所有其他属性请求委托给一个共享对象。123456789101112131415var thingPrototype = &#123; f: function() &#123;&#125;, g: function() &#123;&#125;&#125;;function thing() &#123; var o = Object.create(thingPrototype); o.x = 42; o.y = 3.14; return o;&#125;var o = thing(); 事实上，这是一种常见的模式，语言已经内置了对它的支持。我们不需要创建自己的共享对象（原型对象）。相反，我们会自动为每个函数创建一个原型对象，我们可以将共享数据放在那里。12345678910111213thing.prototype.f = function() &#123;&#125;;thing.prototype.g = function() &#123;&#125;;function thing() &#123; var o = Object.create(thing.prototype); o.x = 42; o.y = 3.14; return o;&#125;var o = thing(); 但是有一个缺点。 这将导致一些重复。“thing”函数的第一行和最后一行将在每个这样的委托原型工厂函数中几乎逐字地重复。 ES5类我们可以通过将重复行移动到自己的功能来隔离重复行。这个函数会创建一个委托给其他任意函数原型的对象，然后用新创建的对象作为参数来调用该函数，最后返回该对象。12345678910111213141516171819function create(fn) &#123; var o = Object.create(fn.prototype); fn.call(o); return o;&#125;// ...Thing.prototype.f = function() &#123;&#125;;Thing.prototype.g = function() &#123;&#125;;function Thing() &#123; this.x = 42; this.y = 3.14;&#125;var o = create(Thing); 实际上，这也是一种常见的模式，语言对它有一些内置的支持。我们定义的“create”函数实际上是“new”关键字的基本版本，我们可以用“new”代替“create”。123456789Thing.prototype.f = function() &#123;&#125;;Thing.prototype.g = function() &#123;&#125;;function Thing() &#123; this.x = 42; this.y = 3.14;&#125;var o = new Thing(); 现在我们已经到达了我们通常所说的ES5类。 它们是将共享数据委托给原型对象并依靠“新”关键字来处理重复性逻辑的对象创建函数。 但是有一个缺点。 它是冗长而丑陋的，实现继承更加冗长和丑陋。 ES6类相对而言，js最新增加的是ES6类 ，它为执行相同的操作提供了非常简洁的语法。1234567891011class Thing &#123; constructor() &#123; this.x = 42; this.y = 3.14; &#125; f() &#123;&#125; g() &#123;&#125;&#125;var o = new Thing(); 对照多年来，我们的js开发人与原型链有着一种关系，现在你可能遇到的两种最常见的风格是类语法（即：ES5类和ES6类），它严重依赖原型链，工厂函数语法，后者通常不依赖于原型链。 这两种风格在性能和功能上有所不同，但只是略有不同。 性能今天，js引擎已经非常优化，几乎不可能查看我们的代码和更快速的原因。 衡量至关重要。 但有时甚至测量可能会使我们失败。 通常情况下，每六个星期就会发布一次更新的js引擎，有时候性能会发生重大变化，我们之前采取的任何测量以及我们基于这些测量所做出的任何决定都会直接跳出窗口。所以，我的经验法则是支持最官方和最广泛使用的语法，假设它会受到最严格的审查，并且是大部分时间内性能最高的语法。 现在是类的语法，当我写这个时，类语法比返回文字的工厂函数大约快3倍。 特征在ES6中，类和工厂函数之间的功能差异很少。 今天，工厂函数和类都可以通过闭包和类地图来实现真正的私有数据工厂函数。 两者都可以通过将其他属性混合到其自己的对象中来实现多个继承工厂功能，并且还可以通过将其他属性混合到其原型，类工厂或代理中来实现多个继承工厂功能。 如果需要的话，工厂函数和类都可以返回任意的对象。 而且都提供了一个简单的语法。 结论综合考虑来看，我的首选是类语法。 这是标准的，它简单，干净，速度快，它提供了以前只有工厂才能提供的每一个功能。 原文","raw":null,"content":null,"categories":[{"name":"js","slug":"js","permalink":"/categories/js/"}],"tags":[{"name":"js,object create,js对象创建,js类,最佳实践","slug":"js-object-create-js对象创建-js类-最佳实践","permalink":"/tags/js-object-create-js对象创建-js类-最佳实践/"}]},{"title":"js日期格式化","slug":"js-date-format","date":"2018-11-26T05:54:44.640Z","updated":"2017-10-27T09:29:00.018Z","comments":true,"path":"2018/11/26/js-date-format/","link":"","permalink":"/2018/11/26/js-date-format/","excerpt":"js原生提供了不少的格式化，但因业务需要不能满足需求。因此下面给出一些新的格式化方法，作为原生日期格式化的补充。","text":"js原生提供了不少的格式化，但因业务需要不能满足需求。因此下面给出一些新的格式化方法，作为原生日期格式化的补充。 方法一使用以下占位符自定义格式化 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 。 123456789101112131415161718192021222324Date.prototype.format = function (fmt) &#123; //author: meizz var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"h+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt;&#125;// e.g.var now=new Date();console.log(now.format(\"yyyy年MM-dd\"));//print 2017年01-03console.log(now.format(\"yyyy-MM-dd HH:mm:ss\")); //print 2017-01-03 23:02:03 方法二使用以下占位符自定义格式化 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 123456789101112131415161718192021222324252627282930313233343536373839404142Date.prototype.pattern=function(fmt) &#123; var o = &#123; \"M+\" : this.getMonth()+1, //月份 \"d+\" : this.getDate(), //日 \"h+\" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 \"H+\" : this.getHours(), //小时 \"m+\" : this.getMinutes(), //分 \"s+\" : this.getSeconds(), //秒 \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \"S\" : this.getMilliseconds() //毫秒 &#125;; var week = &#123; \"0\" : \"/u65e5\", \"1\" : \"/u4e00\", \"2\" : \"/u4e8c\", \"3\" : \"/u4e09\", \"4\" : \"/u56db\", \"5\" : \"/u4e94\", \"6\" : \"/u516d\" &#125;; if(/(y+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); &#125; if(/(E+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? \"/u661f/u671f\" : \"/u5468\") : \"\")+week[this.getDay()+\"\"]); &#125; for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); &#125; &#125; return fmt; &#125; // e.g.var now=new Date();console.log(now.format(\"yyyy年MM-dd\"));//print 2017年01-03console.log(now.format(\"yyyy-MM-dd HH:mm:ss\")); //print 2017-01-03 23:02:03 方法三使用以下占位符自定义格式化 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(l)只能用 1 个占位符(是 1-3 位的数字) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119Date.prototype.format = function (mask) &#123; var d = this; var zeroize = function (value, length) &#123; if (!length) length = 2; value = String(value); for (var i = 0, zeros = ''; i &lt; (length - value.length); i++) &#123; zeros += '0'; &#125; return zeros + value; &#125;; return mask.replace(/\"[^\"]*\"|'[^']*'|/b ( ? : d &#123; 1, 4 &#125; | m &#123; 1, 4 &#125; | yy( ? : yy) ? | ([hHMstT]) / 1 ? | [lLZ]) / b / g, function ($0) &#123; switch ($0) &#123; case 'd': return d.getDate(); case 'dd': return zeroize(d.getDate()); case 'ddd': return ['Sun', 'Mon', 'Tue', 'Wed', 'Thr', 'Fri', 'Sat'][d.getDay()]; case 'dddd': return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][d.getDay()]; case 'M': return d.getMonth() + 1; case 'MM': return zeroize(d.getMonth() + 1); case 'MMM': return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][d.getMonth()]; case 'MMMM': return ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][d.getMonth()]; case 'yy': return String(d.getFullYear()).substr(2); case 'yyyy': return d.getFullYear(); case 'h': return d.getHours() % 12 || 12; case 'hh': return zeroize(d.getHours() % 12 || 12); case 'H': return d.getHours(); case 'HH': return zeroize(d.getHours()); case 'm': return d.getMinutes(); case 'mm': return zeroize(d.getMinutes()); case 's': return d.getSeconds(); case 'ss': return zeroize(d.getSeconds()); case 'l': return zeroize(d.getMilliseconds(), 3); case 'L': var m = d.getMilliseconds(); if (m &gt; 99) m = Math.round(m / 10); return zeroize(m); case 'tt': return d.getHours() &lt; 12 ? 'am' : 'pm'; case 'TT': return d.getHours() &lt; 12 ? 'AM' : 'PM'; case 'Z': return d.toUTCString().match(/[A-Z]+$/); // Return quoted strings with the surrounding quotes removed default: return $0.substr(1, $0.length - 2); &#125; &#125;);&#125;; // e.g.var now=new Date();console.log(now.format(\"yyyy年MM-dd\"));//print 2017年01-03console.log(now.format(\"yyyy-MM-dd HH:mm:ss\")); //print 2017-01-03 23:02:03","raw":null,"content":null,"categories":[{"name":"js","slug":"js","permalink":"/categories/js/"}],"tags":[{"name":"js,date,日期，格式化","slug":"js-date-日期，格式化","permalink":"/tags/js-date-日期，格式化/"}]},{"title":"Java Thread wait, notify and notifyAll 示例","slug":"java-thread-wait-notify-and-notifyall-example","date":"2018-11-26T05:54:44.620Z","updated":"2018-01-12T08:16:52.715Z","comments":true,"path":"2018/11/26/java-thread-wait-notify-and-notifyall-example/","link":"","permalink":"/2018/11/26/java-thread-wait-notify-and-notifyall-example/","excerpt":"java中的Object类包含三个允许线程就资源的锁定状态进行通信的最终（final）方法，。他们是wait()，notify()，和notifyAll() 。 今天我们将通过java程序来研究wait，notify和notifyAll。","text":"java中的Object类包含三个允许线程就资源的锁定状态进行通信的最终（final）方法，。他们是wait()，notify()，和notifyAll() 。 今天我们将通过java程序来研究wait，notify和notifyAll。 Java多线程面试问题 Java中的wait，notify和notifyAll1.1 wait1.2 notify1.3 notifyAll1.4 消息1.5 等待者1.6 通知者1.7 等待通知测试 1. Java中的wait，notify和notifyAll任何对象调用这些方法的当前线程应具有对象监视器，否则会抛出java.lang.IllegalMonitorStateException异常。 1.1 wait对象wait方法有三种实现，其中一种实现是等待任何其他线程无限期地调用对象的notify或notifyAll方法来唤醒当前线程。 其他两种实现会使当前线程在唤醒之前等待特定的时间。 1.2 notifynotify方法只唤醒等待对象的一个​​线程，并且该线程开始执行。所以如果有多个线程在等待一个对象，这个方法只会唤醒其中的一个。线程的选择取决于线程管理的OS实现。 1.3 notifyAllnotifyAll方法唤醒等待对象的所有线程，但哪一个将首先处理取决于OS实现。 这些方法可用于实现生产者消费者问题，其中消费者线程正在等待队列中的对象，生产者线程将对象放入队列中并通知等待的线程。 让我们来看一个例子，其中多个线程在同一个对象上工作，我们使用wait，notify和notifyAll方法。 1.4 消息Java bean将在线程上工作，并调用wait和notify方法。123456789101112131415public class Message &#123; private String msg; public Message(String str)&#123; this.msg=str; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String str) &#123; this.msg=str; &#125;&#125; 1.5 等待者将等待其他线程调用notify方法来完成处理的类。 请注意，等待者线程使用同步块方式在Message对象上拥有监视器。12345678910111213141516171819202122232425public class Waiter implements Runnable&#123; private Message msg; public Waiter(Message m)&#123; this.msg=m; &#125; @Override public void run() &#123; String name = Thread.currentThread().getName(); synchronized (msg) &#123; try&#123; System.out.println(name+\" waiting to get notified at time:\"+System.currentTimeMillis()); msg.wait(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(name+\" waiter thread got notified at time:\"+System.currentTimeMillis()); //process the message now System.out.println(name+\" processed: \"+msg.getMsg()); &#125; &#125;&#125; 1.6 通知者一个将要处理消息对象的类，然后调用notify方法来唤醒等待消息对象的线程。请注意，同步块用于拥有Message对象的监视器。123456789101112131415161718192021222324252627public class Notifier implements Runnable &#123; private Message msg; public Notifier(Message msg) &#123; this.msg = msg; &#125; @Override public void run() &#123; String name = Thread.currentThread().getName(); System.out.println(name+\" started\"); try &#123; Thread.sleep(1000); synchronized (msg) &#123; msg.setMsg(name+\" Notifier work done\"); msg.notify(); // msg.notifyAll(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.7 等待通知测试测试类将创建Waiter和Notifier的多个线程并启动它们。12345678910111213141516public class WaitNotifyTest &#123; public static void main(String[] args) &#123; Message msg = new Message(\"process it\"); Waiter waiter = new Waiter(msg); new Thread(waiter,\"waiter\").start(); Waiter waiter1 = new Waiter(msg); new Thread(waiter1, \"waiter1\").start(); Notifier notifier = new Notifier(msg); new Thread(notifier, \"notifier\").start(); System.out.println(\"All the threads are started\"); &#125;&#125; 当我们调用上面的程序的时候，我们会看到下面的输出，但是程序不会完成，因为有两个线程在等待Message对象，而notify（）方法只唤醒其中的一个，另一个线程还在等待通知。 123456waiter waiting to get notified at time:1356318734009waiter1 waiting to get notified at time:1356318734010All the threads are startednotifier startedwaiter waiter thread got notified at time:1356318735011waiter processed: notifier Notifier work done 如果我们注释notify（）调用并不注释Notifier类中的notifyAll（）调用，则下面将生成输出。12345678waiter waiting to get notified at time:1356318917118waiter1 waiting to get notified at time:1356318917118All the threads are startednotifier startedwaiter1 waiter thread got notified at time:1356318918120waiter1 processed: notifier Notifier work donewaiter waiter thread got notified at time:1356318918120waiter processed: notifier Notifier work done 由于notifyAll（）方法唤醒所有Waiter线程和程序完成，并在执行后终止。 这就是所有在Java的wait，notify和notifyAll方法。 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java, Thread, wait, notify, notifyAll, 等待, 通知, 通知所有","slug":"java-Thread-wait-notify-notifyAll-等待-通知-通知所有","permalink":"/tags/java-Thread-wait-notify-notifyAll-等待-通知-通知所有/"}]},{"title":"java字符串面试问题","slug":"java-string-interview-questions","date":"2018-11-26T05:54:44.603Z","updated":"2017-10-11T09:29:51.120Z","comments":true,"path":"2018/11/26/java-string-interview-questions/","link":"","permalink":"/2018/11/26/java-string-interview-questions/","excerpt":"","text":"字符串是广泛使用的Java类之一。这里我列出了一些重要的Java字符串面试问题及答案。 这将极大的帮助我们获取字符串相关的全面知识，在面试中回答有关字符串的任何问题。 Java字符串面试问题列表 Java中的字符串是什么？它是数据类型的吗？ 创建字符串对象有哪些不同的方式？ 写一个方法检查输入的字符串是否是回文？ 写一个方法从字符串中移出给定的字符？ 怎以确保字符串是大写或者小写？ 字符串的subSequence方法是什么？ Java编程时怎样比较两个字符串？ 怎样转换字符串到字符？反过来呢？ 怎样转换字符串到字节数据？反过来呢？ swicth case语句中能使用字符串类型吗？ 写一个程序打印所有字符串排列？ 写一个方法找出给出字符串中最长的回文？ String, StringBuffer and StringBuilder有什么区别？ Java中为什么字符串是永恒不变和拒绝继承的？ Java中怎样分隔字符串？ 为什么存储密码字符数组比字符串更合适？ Java中怎样检测两个字符串是否相等？ 字符串常量池是什么？ 字符串的intern()方法做了什么？ Java中的字符串是线程安全的吗？ Java中为什么字符串是受欢迎的Hasmap key？ 字符串编程？ Java字符串面试问题及答案1. Java中的String是什么？它是数据类型的吗？String是一个定义在java.lang包中的Java类。它不是像int或long类似的原始数据类型。字符串(String)类表示了一个字符串。字符串被使用在几乎所有的Java就应用中，这里有一个我们应当知道的有趣的特性。Java中的字符串是不可变的且无法扩展的。JVM使用字符串常量池存储所有字符串对象。其他有趣的是关于使用双引号初始化字符串的方式和“+”操作符重载。 2. 创建字符串对象有哪些不同的方式？可以使用new操作符或者双引号初始化一个字符串对象。也可以使用char数组, byte数组, StringBuffer或StringBuilder构造器初始化后，获取字符串对象。 12String str1 = \"abc\";String str = new String(\"abc\"); 在我们使用双引号创建字符串时，JVM将从字符串常量池中查找，若找到相同的字符串，将直接返回引用，并直接指向它，否则重新创建一个字符串对象，存储在字符串常量池中，并指向它。 在使用new操作符时，JVM创建了字符串对象，但不存储在字符串常量池中。我们可以使用intern()方法存储它到字符串常量池，若池中存在相等的字符串，将直接返回引用。 3. 写一个方法检查输入的字符串是否是回文？如果字符串反向后与反向前的值相等，则字符串是回文。如“aba”就是回文。 字符串类没有提供任何反向字符串的方法，但是StringBuffer和StringBuilder类提供，可以用于检测是否是回文。 1234567private static boolean isPalindrome(String str) &#123; if (str == null) return false; StringBuilder strBuilder = new StringBuilder(str); strBuilder.reverse(); return strBuilder.toString().equals(str);&#125; 有时面试官会问还有其他方式吗？这时你可以比较字符串中的字符方式来检测是否是回文。 123456789101112private static boolean isPalindrome(String str) &#123; if (str == null) return false; int length = str.length(); System.out.println(length / 2); for (int i = 0; i &lt; length / 2; i++) &#123; if (str.charAt(i) != str.charAt(length - i - 1)) return false; &#125; return true;&#125; 4. 写一个方法从字符串中移出给定的字符？可以使用replaceAll方法把字符串多次替换成其他字符串。重点要提出的是接受的参数是字符串类型的，因此我们要使用Character类创建一个字符串类，然后替换成空字符串。 12345private static String removeChar(String str, char c) &#123; if (str == null) return null; return str.replaceAll(Character.toString(c), \"\");&#125; 5. 怎以确保字符串是大写或者小写？使用toUpperCase和toLowerCase方法就可以得到大写和小写字符串。这两个方法还有带本地参数的变种方法。 6. 字符串的subSequence方法是什么？Java 1.4 引入了CharSequence接口，字符串类实现了该接口。内部它是调用字符串类的substring方法。 7. Java编程时怎样比较两个字符串？Java字符串实现了Comparable接口，它有两个变种的compareTo()方法。 compareTo(String anotherString)方法是按字典顺序比较字符串和入参字符串的。如果字符串先于输入参，则返回负整数，若字符串在入参之后。则返回正整数，若相等值则返回0，在这种情形时equals(String str)返回true。 compareToIgnoreCase(String str)方法与第一个相似，但忽略了大小写。 8. 怎样转换字符串到字符？反过来呢？这是一个狡猾的问题，因为字符串是一亿字符序列，我们不能转换它到单个字符串。可以给出索引使用charAt方法得到指定位置的字符，也可以使用toCharArray()转换成字符数组。 使用new关键字就可以把字符数组转换成字符串。使用Character.toString(char c)转换字符到字符串。 9. 怎样转换字符串到字节数据？反过来呢？使用字符串的getBytes()方法转换字符串到字节数组，使用字符串构造器new String(byte[] arr)转换字节数组到字符串。 10. swicth case语句中能使用字符串类型吗？java 7引入的新特性之一，switch case语句中可以使用字符串类型。因此java 7或更高版本可以使用。 11. 写一个程序打印给出字符串的所有的排列方式？这是一个狡猾的问题，我们需要递归找出所有的排列，如“AAB”的所有排列是“AAB”，“ABA”和“BAA”。我们需要Set来确保不重复的值。 首先要获取首个字符与剩下的字符排列做交集。如“ABC”，首字符是A，剩下字符排列是“BC”和“CB”。我们可以把剩下不同的排例插入到首字符。BC -&gt; ABC, BAC, BCACB -&gt; ACB, CAB, CBA依此类推，递归就实现了以上算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package test;import java.util.HashSet;import java.util.Set;/** * Java Program to find all permutations of a String * @author xxx * */public class StringHelper &#123; public static Set&lt;String&gt; permutationFinder(String str) &#123; Set&lt;String&gt; perm = new HashSet&lt;String&gt;(); //Handling error scenarios if (str == null) &#123; return null; &#125; else if (str.length() == 0) &#123; perm.add(\"\"); return perm; &#125; char initial = str.charAt(0); // first character String rem = str.substring(1); // Full string without first character Set&lt;String&gt; words = permutationFinder(rem); for (String strNew : words) &#123; for (int i = 0;i&lt;=strNew.length();i++)&#123; perm.add(charInsert(strNew, initial, i)); &#125; &#125; return perm; &#125; public static String charInsert(String str, char c, int j) &#123; String begin = str.substring(0, j); String end = str.substring(j); return begin + c + end; &#125; public static void main(String[] args) &#123; String s = \"AAC\"; String s1 = \"ABC\"; String s2 = \"ABCD\"; System.out.println(\"\\nPermutations for \" + s + \" are: \\n\" + permutationFinder(s)); System.out.println(\"\\nPermutations for \" + s1 + \" are: \\n\" + permutationFinder(s1)); System.out.println(\"\\nPermutations for \" + s2 + \" are: \\n\" + permutationFinder(s2)); &#125;&#125; 12. 写一个方法找出给出字符串中最长的回文？关键点是任何回文从中间开始左右各移动1位，字符相等。若是奇数长度则中间为1位，若是偶数长度中间为2位。 12345678910111213141516171819202122232425262728293031323334353637383940414243package test;public class LongestPalindromeFinder &#123; public static void main(String[] args) &#123; System.out.println(longestPalindromeString(\"1234\")); System.out.println(longestPalindromeString(\"12321\")); System.out.println(longestPalindromeString(\"9912321456\")); System.out.println(longestPalindromeString(\"9912333321456\")); System.out.println(longestPalindromeString(\"12145445499\")); System.out.println(longestPalindromeString(\"1223213\")); System.out.println(longestPalindromeString(\"abb\")); &#125; static public String intermediatePalindrome(String s, int left, int right) &#123; if (left &gt; right) return null; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left--; right++; &#125; return s.substring(left + 1, right); &#125; // O(n^2) public static String longestPalindromeString(String s) &#123; if (s == null) return null; String longest = s.substring(0, 1); for (int i = 0; i &lt; s.length() - 1; i++) &#123; //odd cases like 121 奇数长度中间为1位。 String palindrome = intermediatePalindrome(s, i, i); if (palindrome.length() &gt; longest.length()) &#123; longest = palindrome; &#125; //even cases like 1221 偶数长度中间为2位 palindrome = intermediatePalindrome(s, i, i + 1); if (palindrome.length() &gt; longest.length()) &#123; longest = palindrome; &#125; &#125; return longest; &#125;&#125; 13. String, StringBuffer and StringBuilder有什么区别？String是永不变化且拒绝扩展的。因此在做String操作时，创建了新的字符串。由于String操作有资源消耗，因此提供了String操作的助手类–StringBuffer和StringBuilder。 StringBuffer和StringBuilder都是可变的类。因加了同步锁，所以StringBuffer操作时是线程安全的，而StringBuilder不是。因此在多线程操作同一字符串时应当使用StringBuffer，但单线程环境我们应当使用StringBuilder。 StringBuilder性能优于StringBuffer是因为StringBuilder未加同步锁。 14. Java中为什么字符串是永恒不变和拒绝继承的？字符是永恒不变和拒绝继承有如下好处： 字符串不可变才使得线程池变为可能。 因为在存储诸如用户名和密码等第三信息时，任何黑客不能改变它的值。增强了安全性！ 由于字符串不可变，它就可以安全用于多线程中，不需要任何同步。 字符串不可变性，使得java类加载器可以准确的加载。 15. Java中怎样分隔字符串？基于正规表达式的方式，使用split(String regex)分隔转换成字符串数组。 16. 为什么存储密码字符数组比字符串更合适？ 因为字符串是不可变对象，如果作为普通文本存储密码，那么它会一直存在内存中直至被垃圾收集器回收。因为字符串从字符串池中取出的（如果池中有该字符串就直接从池中获取，否则new 一个出来，然后把它放入池中），这样有很大的机会长期保留在内存中，这样会引发安全问题。因为任何可以访问内存的人能以明码的方式把密码dump出来。另外你还应该始终以加密而不是普通的文本来表示密码。因为字符串是不可变，因此没有任何方法可以改变其内容，任何改变都将产生一个新的字符串，而如果使用char[]，你就可以设置所有的元素为空或者为零（这里意思是说，让认证完后该数组不再使用了，就可以用零或者null覆盖原来的密码，防止别人从内存中dump出来）。所以存储密码用字符数组可以明显的减轻密码被盗的危险。 Java官方本身也推荐字符数组，JpasswordField的方法getPassword()就是返回一个字符数组，而由于安全原因getText()方法是被废弃掉的，因为它返回一个纯文本字符串。跟随Java 团队的步伐吧，没有错。 字符串以普通文本打印在log文件或控制台中也易引起危险，但是如果使用数组你不能打印数组的内容，而是它的内存地址。尽管这不是它的真正原因，但仍值得注意。 17. Java中怎样检测两个字符串是否相等？有equal和==操作符实现。使用==操作符除了检查值之外还要检查是否是同一引用，更多时候我们是检查值是否相等。因此我们应当使用equal检查两个字符串是否相等。 18. 字符串常量池是什么？正如名字所示，字符串常量池是存储在Java堆内存中的一个字符串的常量池。 19. 字符串的intern()方法做了什么？在做intern调用时，如果字符串池中存在相等值（equals(Object)）的字符串对象，则返回引用。否则创建后添加到字符串池，并引用它。 20. Java中的字符串是线程安全的吗？字符串是不可变的，因此程序中不能改变这个值。因此是编程安全的，可以被安全的用于多线程环境。 21. Java中为什么字符串是受欢迎的Hasmap key？由于字符串不可变，它的hascode是在创建时缓存的，它也不需要再次计算。也使得他在处理时比其他key对象更快。这也是为什么字符串最常用来当做HasMap key的原因。 22. 字符串编程？1. 如下程序的输出?1234567891011package test;public class StringTest &#123; public static void main(String[] args) &#123; String s1 = new String(\"pankaj\"); String s2 = new String(\"PANKAJ\"); System.out.println(s1 = s2); &#125;&#125; 这是一个简单但狡猾的问题，不要忘记==操作符。 2. 如下程序的输出?1234567891011121314151617package test;public class Test &#123; public void foo(String s) &#123; System.out.println(\"String\"); &#125; public void foo(StringBuffer sb)&#123; System.out.println(\"StringBuffer\"); &#125; public static void main(String[] args) &#123; new Test().foo(null); &#125;&#125; 出现编译错误“The method foo(String) is ambiguous for the type Test”。入参没有明确类型。 3. 如下代码段将输出什么?123String s1 = new String(\"abc\");String s2 = new String(\"abc\");System.out.println(s1 == s2); 输出“false”，因为new操作符强行创建了引用，==操作会比较引用。 4. 如下代码段将输出什么?123String s1 = \"abc\";StringBuffer s2 = new StringBuffer(s1);System.out.println(s1.equals(s2)); 输出“false”，因为equals方法实现会使用instanceof操作检查类型，相同类型且值相等则返回true，否返回false。 5. 如下代码段将输出什么?1234String s1 = \"abc\";String s2 = new String(\"abc\");s2.intern();System.out.println(s1 ==s2); 输出“false”，intern()返回了引用，但需再次分配给s2，若s2 = s2.intern()，则输出“true”。 6. 如下代码段创建了多少个String对象？12String s1 = new String(\"Hello\"); String s2 = new String(\"Hello\"); 答案是3个。第1个 - 第1行, 存储在字符串常量池的“Hello” 对象。第2个 - 第1行, 在堆内存的“Hello”字符串对象。第3个 - 第2行, 在堆内存的“Hello”字符串对象（内存地址与上一行的不一样），这里的“Hello”字符重用了字符串常量中的字符串。 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,String,interview,字符串,面试","slug":"java-String-interview-字符串-面试","permalink":"/tags/java-String-interview-字符串-面试/"}]},{"title":"java编程面试问题","slug":"java-programming-interview-questions","date":"2018-11-26T05:54:44.584Z","updated":"2017-09-25T08:09:11.350Z","comments":true,"path":"2018/11/26/java-programming-interview-questions/","link":"","permalink":"/2018/11/26/java-programming-interview-questions/","excerpt":"在任何java面试中，编程面试总是起决定性影响。最近我参加了许多的面试，因此我搜集了一些有点狡猾的java编程面试题","text":"在任何java面试中，编程面试总是起决定性影响。最近我参加了许多的面试，因此我搜集了一些有点狡猾的java编程面试题 先给出问题，可以自己做个小测验，最后与给出的答案和说明对照下，评估下自己掌握的java知识点。 1. java编程面试问题1如下语句将输出什么？ 123String s1 = \"abc\";String s2 = \"abc\";System.out.println(\"s1 == s2 is:\" + s1 == s2); 2. java编程面试问题2如下语句将输出什么？ 12345String s3 = \"JournalDev\";int start = 1;char end = 5;System.out.print(start + end);System.out.print(s3.substring(start, end)); 3. java编程面试问题3如下语句将输出什么？ 123456HashSet shortSet = new HashSet();for (short i = 0; i &lt; 100; i++) &#123; shortSet.add(i); shortSet.remove(i - 1);&#125;System.out.println(shortSet.size()); 4. java编程面试问题4布尔值flag为什么值可以到达finally语句块 12345678910try &#123; if (flag) &#123; while (true) &#123; &#125; &#125; else &#123; System.exit(1); &#125;&#125; finally &#123; System.out.println(\"In Finally\");&#125; 5. java编程面试问题5如下语句将输出什么？ 123String str = null;String str1=\"abc\";System.out.println(str1.equals(\"abc\") | str.equals(null)); 6. java编程面试问题6如下语句将输出什么？ 1234String x = \"abc\";String y = \"abc\";x.concat(y);System.out.print(x); 7. java编程面试问题7如下程序的将输出什么？ 123456public class MathTest &#123; public void main(String[] args) &#123; int x = 10*10-10; System.out.println(x); &#125;&#125; 8. java编程面试问题8如下程序在编译和执行时，将输出什么？ 123456789public class Test &#123; public static void main(String[] args) &#123; try &#123; throw new IOException(\"Hello\"); &#125;catch(IOException | Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; 希望你在看答案和解决之前先把上面的问题看一下1. java编程面试问题1答案和说明将输出“false”。“+”操作符优先于“==”操作符运逄，最终将输出”s1 == s2 is:abc” == “abc”的结果即false。 2. java编程面试问题2答案和说明将输出“6ourn”。首先字符类型会转换成int型，之后字符串的字符数组是从0开始的，substring函数功能截取的从startIndex开始的，endIndex-startIndex长度的字符串。 3. java编程面试问题3答案和说明将输出“100”。java自动装箱的特性在JDK5被引入，当我们在添加一个short类型值到HashSet时，short原始类型自动装箱转换成Short对象。当在执行i-1将被转换成int原始类型，在做删除时会被自动装箱成Integer对象，然而HashSet中并没有Integer对象，因此不能移除任何东西，所以最终列表的总数为100。 4. java编程面试问题4答案和说明finally代码块将不可达。如果falg值为TRUE，将无限循环，若为FALSE，将退出JVM。 5. java编程面试问题5答案和说明将输出抛出空指针异常java.lang.NullPointerException。在做“|”操作时str为null，null在做.equals()方法将会抛出异常。一般使用“||”和“&amp;&amp;”操作符做短路逻辑操作。 6. java编程面试问题6答案和说明将输出“abc”。注意x.concat(y)将创建一个新字符串，但是并没有分配给x，因此x并未改变。 7. java编程面试问题7答案和说明将产生运行时错误，main方法必须时static 8. java编程面试问题8答案和说明不能输出“Hello”，将产生编译时错误，IOException继承自Exception，因此需要分层捕获，更具体的异常在前。 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,programming, interview,编程,面试","slug":"java-programming-interview-编程-面试","permalink":"/tags/java-programming-interview-编程-面试/"}]},{"title":"java多线程、并发常见面试问题","slug":"java-multithreading-concurrency-interview-questions","date":"2018-11-26T05:54:44.568Z","updated":"2017-12-28T07:19:42.045Z","comments":true,"path":"2018/11/26/java-multithreading-concurrency-interview-questions/","link":"","permalink":"/2018/11/26/java-multithreading-concurrency-interview-questions/","excerpt":"今天我们将通过研究java多线程面试问题同时也研究并发面试问题，因为多线程和并发密不可分。线程是Java面试中的热门话题之一。在这里我从面试的角度列出了大部分重要的java多线程面试问题，不过您应该对java线程有很好的了解，才能应付以下问题。","text":"今天我们将通过研究java多线程面试问题同时也研究并发面试问题，因为多线程和并发密不可分。线程是Java面试中的热门话题之一。在这里我从面试的角度列出了大部分重要的java多线程面试问题，不过您应该对java线程有很好的了解，才能应付以下问题。 Java多线程面试问题 进程和线程有什么区别？ 多线程编程有哪些好处？ 用户线程和守护线程有什么区别？ 我们如何在Java中创建一个线程？ 线程生命周期中有什么不同的状态？ 我们可以调用Thread类的run()方法吗？ 我们如何在特定时间暂停线程执行？ 你对线程优先级有什么了解？ 什么是线程计划和时间切片？ 什么是多线程中的上下文切换？ 我们如何确保main()是Java程序中完成的最后一个线程？ 线程如何相互通信？ 为什么线程通信方法wait()，notify()和notifyAll()都在Object类中？ 为什么wait()，notify()和notifyAll()方法必须从synchronized方法或块调用？ 为什么线程sleep()和yield()方法是静态的？ 我们如何在Java中实现线程安全？ 在Java中的volatile关键字是什么？ 同步方法或同步块哪个是更优选择？ 如何在Java中创建守护进程线程？ 什么是ThreadLocal？ 什么是线程组？ 为什么建议不要使用它？ 什么是Java线程Dump，我们如何获得程序的Java线程Dump？ 什么是死锁？ 如何分析和避免死锁的情形？ 什么是Java时间类？ 如何安排任务在特定间隔时间后运行？ 什么是线程池？ 我们如何在Java中创建线程池？ 如果我们不覆盖线程类run()方法，会发生什么？ Java并发访问问题 什么是原子操作？ Java并发API中的原子类是什么？ 什么是Java并发API中的锁接口？ 与同步相比有什么好处？ 什么是Executors框架？ 什么是阻塞队列？ 我们如何使用阻塞队列实现生产者-消费者问题？ 什么是Callable和Future？ 什么是FutureTask类？ 什么是Concurrent Collection类？ 什么是Executors类？ Java 8中的并发API的一些改进是什么？ Java多线程面试问题答案1. 进程和线程有什么区别？进程是一个自包含的执行环境，它可以被看作一个程序或应用程序，而线程是一个单独的执行任务。 Java运行时环境作为单个进程运行，它包含不同的类和作为进程运行的程序。线程可以称为轻量级进程。 线程需要较少的资源来创建并存在于进程中，线程共享进程资源。 2. 多线程编程有哪些好处？在多线程编程中，多个线程同时执行，提高了性能，是因为CPU不空闲，一些线程正在等待获取一些资源。 多个线程共享堆内存，因此创建多个线程来执行某些任务比创建多个进程更好。 例如，Servlet的性能比CGI更好，因为Servlet支持多线程，但CGI不支持。 3. 用户线程和守护线程有什么区别？当我们在java程序中创建一个线程时，它被称为用户线程。 守护线程在后台运行，不会阻止JVM终止。 当没有用户线程运行时，JVM关闭程序并退出。 从守护线程创建的子线程也是一个守护线程。 4. 我们如何在Java中创建一个线程？在Java中创建线程有两种方法 - 第一种方式是实现Runnable接口，然后从中创建线程对象，第二种方法是扩展Thread类。 阅读这篇文章了解更多关于在java中创建线程 。 5. 线程生命周期中有什么不同的状态？当我们在java程序中创建一个线程时，它的状态是New。 然后我们启动将其状态更改为Runnable的线程。 线程调度器负责将CPU分配给Runnable线程池中的线程，并将其状态更改为Running。 其他线程状态是 Waiting, Blocked和Dead。 阅读这篇文章，了解线程生命周期的更多信息。 6. 我们可以调用Thread类的run()方法吗？可以，我们可以调用Thread类的run()方法，但它的行为就像一个普通的方法。 要在一个线程中执行它时，我们需要先使用Thread.start()方法启动它。 7. 我们如何在特定时间暂停线程执行？我们可以使用Thread类sleep()方法暂停执行线程一段时间。 请注意，线程在特定时间内不会停止处理，一旦线程从睡眠状态唤醒，状态变为可运行，并且基于线程调度计划，它将被执行。 8. 你对线程优先级有什么了解？每个线程都有一个优先级，通常较高优先级的线程在执行时优先，但这取决于依赖于操作系统的Thread Scheduler实现。 我们可以指定线程的优先级，但不能保证较高优先级的线程在低优先级线程之前被执行。 线程优先级是一个int，其值从1到10，其中1是最低优先级线程，10是最高优先级线程。 9. 什么是线程计划和时间切片？线程调度程序（Thread Scheduler）是将CPU时间分配给可用的可运行线程的操作系统服务。 一旦我们创建和启动一个线程，它的执行取决于Thread Scheduler的实现。时间切片是将可用CPU时间划分为可用的可运行线程的过程。 CPU时间到线程的分配可以基于线程优先级，或线程等待更长时间将获得CPU时间的优先级。 线程调度不能由java控制，因此从应用程序本身控制它总是更好。 10. 什么是多线程中的上下文切换？上下文切换（Context Switching）是存储和恢复CPU状态的过程，以便可以在稍后时间点从同一点恢复线程执行。 上下文切换（Context Switching）是多任务操作系统的基本特性，并支持多线程环境。 11. 我们如何确保main()是Java程序中完成的最后一个线程？我们可以使用线程join()方法来确保程序创建的所有线程在完成主函数之前都已经结束。join()方法用于指定指定的线程结束后，才执行当前线程。这是一篇关于线程join方法的文章。 12. 线程间如何通信？当线程共享资源时，线程之间的通信对协调其工作很重要。 Object类中的wait()，notify()和notifyAll()方法允许线程通过资源的锁进行通信。 查看这篇文章了解更多关于 线程wait()，notify()和notifyAll()。 13. 为什么线程通信方法wait()，notify()和notifyAll()都在Object类中？在Java中，每个对象都有一个监视器和wait，notify方法用于等待对象监视器或通知其他线程对象监视器现在是空闲的。 java中的线程没有监视器，同步可以用于任何对象，这就是为什么它是Object类的一部分的原因，所以java中的每个类都有这些线程间通信的基本方法。 14. 为什么wait()，notify()和notifyAll()方法必须从synchronized方法或块调用？当一个线程在任何对象上调用wait（）时，它必须在该对象上有监视器，它将离开并进入等待状态，直到任何其他线程调用该对象的notify（）为止。 同样，当一个线程在任何对象上调用notify（）时，它将把该监视器留在该对象上，其他等待的线程可以获得该对象上的监视器。 由于所有这些方法都要求线程具有对象监视器，这只能通过同步来实现，所以它们需要从同步方法或块中调用。 15. 为什么线程sleep()和yield()方法是静态的？线程sleep()和yield()方法工作在当前正在执行的线程。 因此，在等待状态的其他线程上调用这些方法没有意义。 这就是为什么这些方法是静态的，所以当这种方法被静态调用时，它可以在当前执行的线程上运行，并可避免混淆程序员，否则他们可能认为他们可以在一些非运行的线程上调用这些方法。 16. 我们如何在Java中实现线程安全？有几种方法可以实现java中的线程安全 - 同步，原子并发类，实现并发Lock接口，使用volatile关键字，使用不可变类和线程安全类。 了解更多线程安全教程。 17. 在Java中的volatile关键字是什么？当我们将volatile关键字与变量一起使用时，所有的线程都直接从内存中读取它的值，并且不缓存它。这可确保读取的值与内存中的值相同。 18. 同步方法或同步块哪个是更优选择？同步块是更优选择，因为它不锁定对象，同步方法锁定对象，并且如果类中有多个同步块，即使它们不相关，为了获取对象锁，也会阻止它们执行并使它们处于等待状态。 19. 如何在Java中创建守护进程线程？在调用start()方法之前，使用Thread类setDaemon(true)方法创建守护线程。否则它将抛出IllegalThreadStateException。 20. 什么是ThreadLocal？Java ThreadLocal用于创建线程局部变量。 我们知道一个对象的所有线程都共享它的变量，所以如果变量不是线程安全的，我们可以使用同步，但如果我们想避免同步，我们可以使用ThreadLocal变量。 每个线程都有自己的ThreadLocal变量，它们可以使用它的get()和set()方法来获取默认值，或者将它的本地值更改为Thread。 ThreadLocal实例通常是希望将状态与线程关联的类中的私有静态字段。 查看小示例程序ThreadLocal示例。 21. 什么是线程组？ 为什么建议不要使用它？线程组(ThreadGroup)是一个类，旨在提供有关线程组的信息。 ThreadGroup API很弱，并没有任何Thread提供的功能。 它的主要特点是获取线程组中的活动线程列表，并为线程设置未捕获的异常处理程序。 但Java 1.5添加了setUncaughtExceptionHandler（UncaughtExceptionHandler eh）方法，我们可以向线程添加未捕获的异常处理程序。 所以ThreadGroup已经过时了，因此不建议再使用了。12345678t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler()&#123;@Overridepublic void uncaughtException(Thread t, Throwable e) &#123; System.out.println(\"exception occured:\"+e.getMessage());&#125; &#125;); 22. 什么是Java线程Dump，我们如何获得程序的Java线程Dump？线程Dump是JVM中活动的所有线程的列表，线程Dump非常有助于分析应用程序中的瓶颈并分析死锁情况。有很多方法可以为我们生成线程Dump - 使用Profiler，Kill -3命令，jstack工具等。我喜欢jstack工具来生成程序的线程Dump，因为它易于使用，并附带JDK安装。由于它是一个基于终端的工具，我们可以创建脚本来定期生成线程Dump，以便稍后进行分析。 阅读这篇文章了解更多关于在java中生成线程Dump。 23. 什么是死锁？ 如何分析和避免死锁的情形？死锁是一种编程情况，其中两个或多个线程被永久阻塞，这种情况出现在至少两个线程和两个或更多资源中。 为了分析一个死锁，我们需要查看应用程序的java线程Dump，我们需要注意线程的状态为BLOCKED，然后是资源等待锁定，每个资源都有一个唯一的ID，我们可以找到哪个线程已经在对象上保持锁定。 避免嵌套锁定，仅需要锁定什么是必需的，并且避免无限期地等待是避免死锁情况的常见方法，请阅读本文以了解如何使用示例程序分析java中的死锁。 24. Java Timer类是什么？ 如何安排任务在特定间隔时间后运行？java.util.Timer是一个实用工具类，可用于安排在将来某个特定时间执行的线程。 Java Timer类可用于计划一次运行的任务或定期运行的任务。 java.util.TimerTask是一个实现Runnable接口的抽象类 ，我们需要扩展这个类来创建可以使用java Timer类调度的我们自己的TimerTask。 查看这篇文章java定时器的例子 。 25. 什么是线程池？ 我们如何在Java中创建线程池？线程池是管理工作线程的池子，它包含一个队列，可以让任务等待执行。 线程池是管理Runnable线程和从队列中执行Runnable的工作线程。 java.util.concurrent.Executors提供java.util.concurrent.Executor接口的实现，用以在java中创建线程池。 线程池示例程序显示如何在java中创建和使用Thread Pool。 或者读取ScheduledThreadPoolExecutor示例来了解如何在一定的延迟之后执行任务。 26. 如果我们不覆盖线程类run()方法，会发生什么？线程类run()方法的代码如下所示。12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 以上目标设置在Thread类的init()方法中，如果我们创建一个Thread类的实例作为new TestThread() ，它设置为null。 所以如果我们不覆盖run()方法，就不会发生任何事情。 下面是一个简单的例子来说明这一点。123456789101112public class TestThread extends Thread &#123; //not overriding Thread.run() method //main method, can be in other class too public static void main(String args[])&#123; Thread t = new TestThread(); System.out.println(\"Before starting thread\"); t.start(); System.out.println(\"After starting thread\"); &#125;&#125; 它将仅打印输出和终止。12Before starting threadAfter starting thread Java并发访问问题答案1. 什么是原子操作？ Java并发API中的原子类是什么？原子操作在单个任务单元中执行，而不受其他操作的干扰。 原子操作在多线程环境中是必需的，以避免数据不一致。 int++不是原子操作。 所以当一个线程读取它的值并将其增加一个时，其他线程读取旧的值导致错误的结果。 为了解决这个问题，我们必须确保在count上的增量操作是原子的，我们可以使用Synchronization来实现，但是Java 5 java.util.concurrent.atomic为int和long提供了可以用来实现这个原子的包装类不使用同步。 转到这篇文章了解更多关于原子并发类 。 2. 什么是Java并发API中的锁接口？ 与同步相比有什么好处？锁定界面提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的Condition对象。锁的优点是 有可能使他们公平 在等待Lock对象时，可以使线程响应中断。 有可能尝试获取锁定，但如果无法获取锁定，则立即返回或超时后返回 可以在不同的范围内以不同的顺序获取和释放锁阅读更多Java Lock示例 。 3. 什么是Executors框架？在Java 5中，Executor框架被引入了java.util.concurrent.Executor接口。 执行器框架是根据一组执行策略来标准化异步任务的调用，调度，执行和控制的框架。 创建许多线程没有限制到最大阈值可能导致应用程序用尽堆内存。 所以，创建一个ThreadPool是一个更好的解决方案，因为有限数量的线程可以被汇集和重用。 执行器框架促进了在Java中创建线程池的过程。 查看这篇文章，学习使用Executors框架创建线程池的示例代码。 4. 什么是阻塞队列？ 我们如何使用阻塞队列实现生产者-消费者问题？java.util.concurrent.BlockingQueue是一个队列，支持在检索和删除元素时等待队列变为非空的操作，并在添加元素时等待队列中的空间变得可用。 如果尝试在队列中存储空值，BlockingQueue不接受空值并抛出NullPointerException。 BlockingQueue实现是线程安全的。 所有排队方法本质上都是原子的，并使用内部锁或其他形式的并发控制。 BlockingQueue接口是java集合框架的一部分，它主要用于实现生产者消费者问题。使用BlockingQueue检查此帖子的生产者 - 消费者问题实现 。 5. 什么是Callable和Future？Java 5在Concurrency包中引入了类似于Runnable接口的java.util.concurrent.Callable接口，但它可以返回任何Object并且能够抛出异常。 可调用接口使用Generic来定义Object的返回类型。 执行器类提供了有用的方法来在线程池中执行Callable。 由于可调用任务并行运行，我们必须等待返回的对象。 可调用任务返回java.util.concurrent.Future对象。 使用未来，我们可以找到可调用任务的状态并获取返回的对象。 它提供可以等待Callable完成的get（）方法，然后返回结果。检查这个帖子可以调用未来的例子 。 6. 什么是FutureTask类？FutureTask是Future接口的基本实现类，我们可以使用Executors进行异步处理。 大多数情况下，我们不需要使用FutureTask类，但如果我们想覆盖Future接口的某些方法并希望保留大部分的基本实现，那么它将非常方便。 我们只能扩展这个类，并根据我们的要求重写方法。 查看Java FutureTask示例文章，了解如何使用它，以及其具有的不同方法。 7. 什么是Concurrent Collection类？Java集合类是故障快速的，这意味着如果在某些线程使用迭代器遍历它时，集合将被更改，则iterator.next（）将抛出ConcurrentModificationException。 并发收集类支持检索的完全并发性和可更新的可预期并发性。主要类是ConcurrentHashMap，CopyOnWriteArrayList和CopyOnWriteArraySet，请检查此帖子，以了解如何在使用迭代器时避免ConcurrentModificationException异常 。 8. 什么是Executors类？Executors类为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供实用程序方法。 执行器类可以用来轻松地在java中创建Thread Pool，这也是支持Callable实现的唯一类。 9. Java 8中的并发API的一些改进是什么？一些重要的并发API增强功能是： ConcurrentHashMap compute（），forEach（），forEachEntry（），forEachKey（），forEachValue（），merge（），reduce（）和search（）方法。可以明确完成的CompletableFuture（设置其值和状态）。执行者newWorkStealingPool（）方法创建使用所有可用处理器作为其目标并行级别的工作窃取线程池。 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java, Multithreading, Concurrency, interview,多线程, 并发, 面试","slug":"java-Multithreading-Concurrency-interview-多线程-并发-面试","permalink":"/tags/java-Multithreading-Concurrency-interview-多线程-并发-面试/"}]},{"title":"Java（JVM）内存模型 - Java中的内存管理","slug":"java-jvm-memory-model-memory-management","date":"2018-11-26T05:54:44.549Z","updated":"2017-12-20T03:47:34.365Z","comments":true,"path":"2018/11/26/java-jvm-memory-model-memory-management/","link":"","permalink":"/2018/11/26/java-jvm-memory-model-memory-management/","excerpt":"了解JVM内存模型 ， Java内存管理是非常重要的，如果你想了解Java垃圾回收的工作。 今天，我们将研究java中的内存管理，JVM内存的不同部分以及如何监视和执行垃圾回收调优。","text":"了解JVM内存模型 ， Java内存管理是非常重要的，如果你想了解Java垃圾回收的工作。 今天，我们将研究java中的内存管理，JVM内存的不同部分以及如何监视和执行垃圾回收调优。本文目录 Java（JVM）内存模型 Java中的内存管理 - 年轻一代 Java中的内存管理 - 老一代&nbsp;&nbsp;&nbsp;&nbsp; 3.1. Stop the World事件&nbsp;&nbsp;&nbsp;&nbsp; 3.2. Java内存模型 - 永久生成&nbsp;&nbsp;&nbsp;&nbsp; 3.3. Java内存模型 - 方法区域&nbsp;&nbsp;&nbsp;&nbsp; 3.4. Java内存模型 - 内存池&nbsp;&nbsp;&nbsp;&nbsp; 3.5. Java内存模型 - 运行时常量池&nbsp;&nbsp;&nbsp;&nbsp; 3.6. Java内存模型 - Java堆栈内存&nbsp;&nbsp;&nbsp;&nbsp; 3.7. Java中的内存管理 - Java堆内存开关&nbsp;&nbsp;&nbsp;&nbsp; 3.8. Java中的内存管理 - Java垃圾回收&nbsp;&nbsp;&nbsp;&nbsp; 3.9. Java中的内存管理 - Java垃圾回收类型&nbsp;&nbsp;&nbsp;&nbsp; 3.10. Java中的内存管理 - Java垃圾回收监控&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.10.1. jstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.10.2. 使用Visual GC的Java VisualVM&nbsp;&nbsp;&nbsp;&nbsp; 3.11. Java垃圾回收调整 Java（JVM）内存模型 如上图所示，JVM内存分为不同的部分。 从广义上讲，JVM堆内存在物理上分为两个部分 - 年轻一代和旧一代 。 Java中的内存管理 - 年轻一代年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。年轻代被分为3个部分——Enden区和两个Survivor区。 年轻代空间的要点： 大多数新建的对象都位于Eden区。 当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。 Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。 经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。 Java中的内存管理 - 老一代年老代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾回收叫做Major GC。Major GC会花费更多的时间。 Stop the World事件所有的垃圾回收都是“Stop the World”事件，因为所有的应用线程都会停下来直到操作完成（所以叫“Stop the World”）。 因为年轻代里的对象都是一些临时（short-lived ）对象，执行Minor GC非常快，所以应用不会受到（“Stop the World”）影响。 由于Major GC会检查所有存活的对象，因此会花费更长的时间。应该尽量减少Major GC。因为Major GC会在垃圾回收期间让你的应用反应迟钝，所以如果你有一个需要快速响应的应用发生多次Major GC，你会看到超时错误。 垃圾回收时间取决于垃圾回收策略。这就是为什么有必要去监控垃圾回收和对垃圾回收进行调优。从而避免要求快速响应的应用出现超时错误。 Java内存模型 - 永久代永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分。 永久代存放JVM运行时使用的类。永久代同样包含了Java SE库的类和方法。永久代的对象在full GC时进行垃圾回收。 Java内存模型 - 方法区域方法区是永久代空间的一部分，并用来存储类型信息（运行时常量和静态变量）和方法代码和构造函数代码。 Java内存模型 - 内存池如果JVM实现支持，JVM内存管理会为创建内存池，用来为不变对象创建对象池。字符串池就是内存池类型的一个很好的例子。内存池可以属于堆或者永久代，这取决于JVM内存管理的实现。 Java内存模型 - 运行时常量池运行时常量池是每个类常量池的运行时代表。它包含了类的运行时常量和静态方法。运行时常量池是方法区的一部分。 Java内存模型 - Java堆栈内存Java栈内存用于运行线程。它们包含了方法里的临时数据、堆里其它对象引用的特定数据。你可以阅读栈内存和堆内存的区别。 Java内存管理 - Java堆内存开关Java提供了大量的内存开关（参数），我们可以用它来设置内存大小和它们的比例。下面是一些常用的开关： VM 开关 VM开关描述 -Xms 设置JVM启动时堆的初始化大小。 -Xmx 设置堆最大值。 -Xmn 设置年轻代的空间大小，剩下的为老年代的空间大小。 -XX:PermGen 设置永久代内存的初始化大小。 -XX:MaxPermGen 设置永久代的最大值。 -XX:SurvivorRatio 提供Eden区和survivor区的空间比例。比如，如果年轻代的大小为10m并且VM开关是-XX:SurvivorRatio=2，那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。 -XX:NewRatio 提供年老代和年轻代的比例大小。默认值是2。 大多数时候，上面的选项已经足够使用了。但是如果你还想了解其他的选项，那么请查看JVM选项官方网页。 Java中的内存管理 - Java垃圾回收Java垃圾回收会找出没用的对象，把它从内存中移除并释放出内存给以后创建的对象使用。Java程序语言中的一个最大优点是自动垃圾回收，不像其他的程序语言那样需要手动分配和释放内存，比如C语言。 垃圾回收器是一个后台运行程序。它管理着内存中的所有对象并找出没被引用的对象。所有的这些未引用的对象都会被删除，回收它们的空间并分配给其他对象。 一个基本的垃圾回收过程涉及三个步骤： 标记：这是第一步。在这一步，垃圾回收器会找出哪些对象正在使用和哪些对象不在使用。 正常清除：垃圾回收器清会除不在使用的对象，回收它们的空间分配给其他对象。 压缩清除：为了提升性能，压缩清除会在删除没用的对象后，把所有存活的对象移到一起。这样可以提高分配新对象的效率。 简单标记和清除方法存在两个问题： 效率很低。因为大多数新建对象都会成为“没用对象”。 经过多次垃圾回收周期的对象很有可能在以后的周期也会存活下来。 上面简单清除方法的问题在于Java垃圾回收的分代回收的，而且在堆内存里有年轻代和年老代两个区域。我已经在上面解释了Minor GC和Major GC是怎样扫描对象，以及如何把对象从一个分代空间移到另外一个分代空间。 Java中的内存管理 - Java垃圾回收类型这里有五种可以在应用里使用的垃圾回收类型。仅需要使用JVM开关就可以在我们的应用里启用垃圾回收策略。让我们一起来逐一了解： Serial GC（-XX:+UseSerialGC）：Serial GC使用简单的标记、清除、压缩方法对年轻代和年老代进行垃圾回收，即Minor GC和Major GC。Serial GC在client模式（客户端模式）很有用，比如在简单的独立应用和CPU配置较低的机器。这个模式对占有内存较少的应用很管用。 Parallel GC（-XX:+UseParallelGC）：除了会产生N个线程来进行年轻代的垃圾回收外，Parallel GC和Serial GC几乎一样。这里的N是系统CPU的核数。我们可以使用 -XX:ParallelGCThreads=n 这个JVM选项来控制线程数量。并行垃圾回收器也叫throughput回收器。因为它使用了多CPU加快垃圾回收性能。Parallel GC在进行年老代垃圾回收时使用单线程。 Parallel Old GC（-XX:+UseParallelOldGC）：和Parallel GC一样。不同之处，Parallel Old GC在年轻代垃圾回收和年老代垃圾回收时都使用多线程回收。 并发标记清除（CMS）回收器（-XX:+UseConcMarkSweepGC)：CMS回收器也被称为短暂停顿并发回收器。它是对年老代进行垃圾回收的。CMS回收器通过多线程并发进行垃圾回收，尽量减少垃圾回收造成的停顿。CMS回收器对年轻代进行垃圾回收使用的算法和Parallel回收器一样。这个垃圾回收器适用于不能忍受长时间停顿要求快速响应的应用。可使用 -XX:ParallelCMSThreads=n JVM选项来限制CMS回收器的线程数量。 G1垃圾回收器（-XX:+UseG1GC) G1（Garbage First）：垃圾回收器是在Java 7后才可以使用的特性，它的长远目标时代替CMS回收器。G1回收器是一个并行的、并发的和增量式压缩短暂停顿的垃圾回收器。G1回收器和其他的回收器运行方式不一样，不区分年轻代和年老代空间。它把堆空间划分为多个大小相等的区域。当进行垃圾回收时，它会优先回收存活对象较少的区域，因此叫“Garbage First”。你可以在Oracle Garbage-FIrst回收器文档找到更多详细信息。 Java中的内存管理 - Java垃圾回收监控我们可以使用命令行和图形工具来监控监控应用垃圾回收。例如，我使用Java SE下载页中的一个demo来实验。 如果你想使用同样的应用，可以到Java SE下载页面下载JDK 7和JavaFX演示和示例。我使用的示例应用是Java2Demo.jar，它位于 jdk1.7.0_55/demo/jfc/Java2D 目录下。这只是一个可选步骤，你可以运行GC监控命令监控任何Java应用。 我用来启动演示应用程序的命令是： pankaj @ Pankaj：〜/ Downloads / jdk1.7.0_55 / demo / jfc / Java2D $ java -Xmx120m -Xms30m -Xmn10m -XX：PermSize = 20m -XX：MaxPermSize = 20m -XX：+ UseSerialGC -jar Java2Demo.jar jstat可以使用jstat命令行工具监控JVM内存和垃圾回收。标准的JDK已经附带了jstat，所以不需要做任何额外的事情就可以得到它。 要运行jstat你需要知道应用的进程id，你可以使用 ps -eaf | grep java 命令获取进程id。 pankaj @ Pankaj：〜$ ps -eaf | grep Java2Demo.jar 501 9582 11579 0 9:48 PM ttys000 0：21.66 / usr / bin / java -Xmx120m -Xms30m -Xmn10m -XX：PermSize = 20m -XX：MaxPermSize = 20m -XX：+ UseG1GC -jar Java2Demo.jar 501 14073 14045 0 9:48 PM ttys002 0：00.00 grep Java2Demo.jar 从上面知道，我的Java应用进程id是9582。现在可以运行jstat命令了，就像下面展示的一样： pankaj @ Pankaj：〜$ jstat -gc 9582 1000 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 1024.0 1024.0 0.0 0.0 8192.0 7933.3 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.654 1024.0 1024.0 0.0 0.0 8192.0 8026.5 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.654 1024.0 1024.0 0.0 0.0 8192.0 8030.0 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.654 1024.0 1024.0 0.0 0.0 8192.0 8122.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.654 1024.0 1024.0 0.0 0.0 8192.0 8171.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.654 1024.0 1024.0 48.7 0.0 8192.0 106.7 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.656 1024.0 1024.0 48.7 0.0 8192.0 145.8 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.656 jstat命令的最后一个参数是每个输出的时间间隔。每隔一秒就会打印出内存和垃圾回收数据。 让我们一起来对每一列的意义进行逐一了解： S0C和S1C：这一列展示了Survivor0和Survivor1区的当前大小（单位KB）。 S0U和S1U：这一列展示了当前Survivor0和Survivor1区的使用情况（单位KB）。注意：无论任何时候，总会有一个Survivor区是空着的。 EC和EU：这些列展示了Eden区当前空间大小和使用情况（单位KB）。注意：EU的大小一直在增大。而且只要大小接近EC时，就会触发Minor GC并且EU将会减小。 OC和OU：这些列展示了年老代当前空间大小和当前使用情况（单位KB）。 PC和PU：这些列展示了Perm Gen（永久代）当前空间大小和当前使用情况（单位KB）。 YGC和YGCT：YGC这列显示了发生在年轻代的GC事件的数量。YGCT这列显示了在年轻代进行GC操作的累计时间。注意：在EU的值由于minor GC导致下降时，同一行的YGC和YGCT都会增加。 FGC和FGCT：FGC列显示了发生Full GC事件的次数。FGCT显示了进行Full GC操作的累计时间。注意：相对于年轻代的GC使用时间，Full GC所用的时间长很多。 GCT：这一列显示了GC操作的总累计时间。注意：总累计时间是YGCT和FGCT两列所用时间的总和（GCT=YGCT+FGCT）。 jstat的优点，我们同样可以在没有GUI的远程服务器上运行jstat。注意：我们是通过 -Xmn10m 选项来指定S0C、S1C和EC的总和为10m的。 Java VisualVM与Visual GC插件如果你想在GUI里查看内存和GC，那么可以使用jvisualvm工具。Java VisualVM同样是JDK的一部分，所以你不需要单独去下载。 在终端运行jvisualvm命令启动Java VisualVM程序。一旦启动程序，你需要从Tools-&gt;Plugins选项安装Visual GC插件，就像下面图片展示的。 安装完Visual GC插件后，从左边栏打开应用并把视角转到Visual GC部分。你将会得到关于JVM内存和垃圾回收详情，如下图所示。 Java垃圾回收调优Java垃圾回收调优应该是提升应用吞吐量的最后一个选择。在你发现应用由于长时间垃圾回收导致了应用性能下降、出现超时的时候，应该考虑Java垃圾回收调优。 如果你在日志里看到 java.lang.OutOfMemoryError: PermGen space错误，那么可以尝试使用 -XX:PermGen 和 -XX:MaxPermGen JVM选项去监控并增加Perm Gen内存空间。你也可以尝试使用-XX:+CMSClassUnloadingEnabled并查看使用CMS垃圾回收器的执行性能。 如果你看到了大量的Full GC操作，那么你应该尝试增大老年代的内存空间。 全面垃圾回收调优要花费大量的努力和时间，这里没有一尘不变的硬性调优规则。你需要去尝试不同的选项并且对这些选项进行对比，从而找出最适合自己应用的方案。 这就是所有的Java内存模型和垃圾回收内容。希望对你理解JVM内存和垃圾回收过程有所帮助。 引用 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"memory,memory mode,memory management,内存,内存模型,内存管理,垃圾回收","slug":"memory-memory-mode-memory-management-内存-内存模型-内存管理-垃圾回收","permalink":"/tags/memory-memory-mode-memory-management-内存-内存模型-内存管理-垃圾回收/"}]},{"title":"Java堆VS栈-Java中的内存分配","slug":"java-heap-space-vs-stack-memory","date":"2018-11-26T05:54:44.535Z","updated":"2017-12-20T04:32:24.908Z","comments":true,"path":"2018/11/26/java-heap-space-vs-stack-memory/","link":"","permalink":"/2018/11/26/java-heap-space-vs-stack-memory/","excerpt":"前些时候，在我写了一些关于Java垃圾回收和Java是按价值传递的文章之后，收到了很多电子邮件说解释一下Java堆空间 ， Java栈内存，Java内存分配以及它们之间的区别。","text":"前些时候，在我写了一些关于Java垃圾回收和Java是按价值传递的文章之后，收到了很多电子邮件说解释一下Java堆空间 ， Java栈内存，Java内存分配以及它们之间的区别。在Java EE书籍和java教程中都能看到很多关于堆和栈的描述，从程序运行时的角度如何理解堆内存和栈到底是什么呢？ 本文目录 Java堆空间 Java堆栈内存 Java程序中堆和栈内存的分配 Java堆空间和栈内存的区别 Java堆空间Java运行时使用Java堆空间将内存分配给对象和JRE类。 每当我们创建任何对象，它总是在堆空间中创建。 垃圾回收器在堆内存上运行以释放没有任何引用的对象所使用的内存。 在堆空间中创建的任何对象都具有全局访问权限，并且可以从应用程序的任何位置引用。 Java堆栈内存Java堆栈内存用于执行线程。 它们包含特定于方法的值，这些值是短暂的，并引用堆中从该方法引用的其他对象。 堆栈内存始终以LIFO（后进先出）顺序引用。 无论何时调用方法，都会在堆栈内存中为方法创建一个新的块，以保存本地原始值并引用该方法中的其他对象。 一旦方法结束，该块将变为未使用状态，并可用于下一个方法。与堆内存相比，堆栈内存的大小非常小。 Java程序中堆和栈内存的分配让我们用一个简单的程序来理解堆和堆栈的内存使用情况。 1234567891011121314151617package com.journaldev.test;public class Memory &#123; public static void main(String[] args) &#123; // Line 1 int i=1; // Line 2 Object obj = new Object(); // Line 3 Memory mem = new Memory(); // Line 4 mem.foo(obj); // Line 5 &#125; // Line 9 private void foo(Object param) &#123; // Line 6 String str = param.toString(); //// Line 7 System.out.println(str); &#125; // Line 8&#125; 下面的图片显示了参考上述程序的堆栈和堆内存以及它们如何被用来存储原类型值，对象和引用变量。 让我们来看看执行程序的步骤。 一旦我们运行该程序，它将所有运行时类加载到堆空间中。 当在第1行找到main（）方法时，Java运行时将创建堆栈内存以供main（）方法线程使用。 我们在第2行创建了原始局部变量，所以它被创建并存储在main（）方法的堆栈内存中。 由于我们在第3行创建了一个对象，因此它在堆内存中创建，并且堆栈内存包含它的引用。 当我们在第4行创建Memory对象时会发生类似的过程。 现在当我们在第5行中调用foo（）方法时，堆栈顶部的一个块被创建，以供foo（）方法使用。由于Java是按值传递的，因此在第6行的foo（）堆栈块中创建了对Object的新引用。 在第7行中创建一个字符串，它将进入堆空间中的字符串池 ，并在foo（）堆栈空间中为其创建引用。 foo（）方法在第8行终止，此时为堆栈中的foo（）分配的内存块变为空闲。 在第9行中，main（）方法终止，为main（）方法创建的堆栈内存被销毁。 程序也结束在这一行，因此Java运行时释放所有内存并结束程序的执行。 Java堆空间和栈内存的区别基于上面的解释，我们可以很容易地得出堆和堆内存之间的差异。 堆内存由应用程序的所有部分使用，而堆栈内存仅由一个执行线程使用。 每当创建一个对象时，它总是存储在堆空间中，并且堆栈存储器包含对它的引用。 堆栈内存只包含局部基本变量和引用变量到堆空间中的对象。 存储在堆中的对象是全局可访问的，而堆栈存储器不能被其他线程访问。 堆栈中的内存管理以LIFO方式完成，而堆内存中的内存管理更为复杂，因为它是全局使用的。 在Java垃圾收集中 ，堆内存分为年轻一代，旧一代等。 堆栈内存是短暂的，而堆内存从开始到应用程序执行结束。 我们可以使用-Xms和-Xmx JVM选项来定义堆内存的启动大小和最大大小。 我们可以使用-Xss来定义堆栈的内存大小。 当堆栈内存已满时，Java运行时会抛出java.lang.StackOverFlowError而如果堆内存已满，则会抛出java.lang.OutOfMemoryError: Java Heap Space错误。 与堆内存相比，堆栈内存的大小非常小。由于内存分配（LIFO）简单，与堆内存相比，堆栈内存非常快。 这是所有的堆空间和堆栈内存在java应用程序中的对比，希望能消除你关于Java程序执行时内存分配的疑虑。 引用 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"heap space, stack memory, memory allocation，堆空间,堆栈,栈内存,内存分配","slug":"heap-space-stack-memory-memory-allocation，堆空间-堆栈-栈内存-内存分配","permalink":"/tags/heap-space-stack-memory-memory-allocation，堆空间-堆栈-栈内存-内存分配/"}]},{"title":"Java异常面试问题","slug":"java-exception-interview-questions","date":"2018-11-26T05:54:44.517Z","updated":"2018-01-15T09:00:47.483Z","comments":true,"path":"2018/11/26/java-exception-interview-questions/","link":"","permalink":"/2018/11/26/java-exception-interview-questions/","excerpt":"Java提供了一种强大的、面向对象的途径，用于处理异常的场景，它即被称为Java异常处理。","text":"Java提供了一种强大的、面向对象的途径，用于处理异常的场景，它即被称为Java异常处理。以前我写过一篇关于Java异常处理的文章，今天我列出了一些重要的Java异常问题和答案，以帮助你顺利通过面试。 Java中的异常是什么？ Java中的异常处理关键字是什么？ 解释Java异常层次结构？ 什么是Java异常类的重要方法？ 说明Java 7 ARM功能和多catch块？ Java中的Checked和Unchecked Exception之间有什么区别？ 在Java中throw和throws关键字有什么区别？ Java中编写自定义异常？ 什么是Java中的OutOfMemoryError？ 导致“主线程中的异常”的不同情况是什么？ 在Java中final，finally和finalize有什么区别？ 当main方法抛出异常时会发生什么？ 我们可以有一个空的catch块吗？ 提供一些Java异常处理最佳实践？ 下面的程序有什么问题，我们如何解决？ 1. Java中的异常是什么？异常是在执行程序期间可能发生的错误事件，并中断它的正常流程。异常情况可能由用户输入的错误数据，硬件故障，网络连接故障等不同情况引起。 每当执行Java语句时发生任何错误，都会创建一个异常对象，然后JRE尝试查找异常处理程序来处理异常。如果找到合适的异常处理程序，则将异常对象传递给处理程序代码以处理异常，即捕获异常。如果没有找到处理程序，则应用程序将该异常抛出到运行时环境，JRE终止程序。 Java异常处理框架仅用于处理运行时错误，编译时错误不由异常处理框架处理。 2. Java中的异常处理关键字是什么？在java异常处理中使用了四个关键字。 throw ：有时我们明确地想要创建异常对象，然后抛出它来停止程序的正常处理。使用throw关键字来抛出异常来处理它。 throws ：当我们在方法中抛出任何检查的异常而不处理它时，我们需要在方法签名中使用throws关键字来让调用者程序知道可能由方法抛出的异常。调用者方法可能会处理这些异常或使用throws关键字将其传播给它的调用方法。我们可以在throws子句中提供多个异常，也可以在main()方法中使用。 try-catch ：我们在代码中使用try-catch块进行异常处理。try是块的开始，catch是在try块的结尾来处理异常。我们可以有一个try的多个catch块，try-catch块也可以嵌套。catch块需要一个类型为Exception的参数。 finally ：finally块是可选的，只能用于try-catch块。由于异常暂停执行的过程，我们可能会打开一些资源不会关闭，所以我们可以使用finally块。finally块总是被执行，无论是否发生异常。 3. 解释Java异常层次结构？Java异常是有层次的，继承被用来区分不同类型的异常。Throwable是Java异常分层的父类，它有两个子对象 - Error和Exception 。异常进一步被分为检查异常和运行时异常。 错误是超出应用程序范围的特殊情况，不可能预测并从中恢复，例如硬件故障，JVM崩溃或内存不足错误。 检查异常是我们可以在程序中预料到的例外情况，并尝试从中恢复，例如FileNotFoundException。我们应该抓住这个异常，并为用户提供有用的信息并进行正确记录以便调试。Exception是所有检查异常的父类。 运行时异常是由不良编程引起的，例如试图从数组中检索一个元素。在尝试检索元素之前，我们应该先检查数组的长度，否则可能会在运行时抛出ArrayIndexOutOfBoundException 。RuntimeException是所有运行时异常的父类。 4. 什么是Java异常类的重要方法？异常和所有的子类没有提供任何具体的方法，所有的方法在基类Throwable中定义。 String getMessage() - 此方法返回Throwable的消息String，通过构造函数创建异常时可以提供消息。 String getLocalizedMessage() - 提供此方法，以便子类可以覆盖它以向调用程序提供特定于语言环境的消息。此方法的可执行类实现只是使用getMessage()方法来返回异常消息。 synchronized Throwable getCause() - 此方法返回异常的原因或空id，原因未知。 String toString() - 此方法以字符串格式返回有关Throwable的信息，返回的String包含Throwable类和本地化消息的名称。 void printStackTrace() - 此方法将堆栈跟踪信息打印到标准错误流，此方法被重载，我们可以传递PrintStream或PrintWriter作为参数，以将堆栈跟踪信息写入文件或流。 5. 说明Java 7 ARM功能和多catch块？如果您在单个try块中捕获了很多异常，您将注意到catch块代码看起来非常难看，主要由冗余代码组成，以记录错误，记住Java 7的一个特性是多catch块我们可以在一个catch块中捕获多个异常。具有此功能的catch块如下所示： 1234catch(IOException | SQLException | Exception ex)&#123; logger.error(ex); throw new MyException(ex.getMessage());&#125; 大多数情况下，我们使用finally块来关闭资源，有时我们会忘记关闭它们，并在资源耗尽时获取运行时异常。这些异常很难调试，我们可能需要查看每个地方我们正在使用该类型的资源，以确保我们正在关闭它。所以Java 7的一个改进就是try-with-resources ，我们可以在try语句中创建一个资源，并在try-catch块中使用它。当try-catch块执行时，运行时环境会自动关闭这些资源。带有这种改进的try-catch块的示例是： 12345try (MyResource mr = new MyResource()) &#123; System.out.println(\"MyResource created in try-with-resources\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 在Java 7 ARM上阅读更多信息。 6. Java中的Checked和Unchecked Exception之间有什么区别？ 应该使用try-catch块在代码中处理检查异常，否则main()方法应该使用throws关键字来让JRE知道可能从程序抛出的异常。未检查的异常不需要在程序中处理，或者在throws子句中提及它们。 Exception是所有检查异常的超类，而RuntimeException是所有未检查异常的超类。 检查异常是指不是由程序引起的错误情况，例如在读取不存在的文件时的FileNotFoundException，而未检查的异常大部分是由于编程不良造成的，例如，当在对象引用上调用方法时没有确定是否为NullPointerException不为null。 7. 在Java中throw和throws关键字有什么区别？throws关键字与方法签名一起使用来声明方法可能抛出的异常，而throw关键字用于中断程序流并将异常对象移交给运行时处理。 8. 如何在Java中编写自定义异常？我们可以扩展Exception类或它的任何子类来创建我们的自定义异常类。自定义异常类可以拥有自己的变量和方法，我们可以使用这些变量和方法将错误代码或其他异常相关信息传递给异常处理程序。 自定义异常的一个简单示例如下所示。 123456789101112131415161718192021package com.lexiangmiao.exceptions;import java.io.IOException;public class MyException extends IOException &#123; private static final long serialVersionUID = 4664456874499611218L; private String errorCode=\"Unknown_Exception\"; public MyException(String message, String errorCode)&#123; super(message); this.errorCode=errorCode; &#125; public String getErrorCode()&#123; return this.errorCode; &#125; &#125; 9. 什么是Java中的OutOfMemoryError？Java中的OutOfMemoryError是java.lang.VirtualMachineError的一个子类，当JVM在堆内存中运行时，它将被抛出。我们可以通过增加更多的内存，通过java选项运行java应用程序来解决这个错误。 $&gt;java MyProgram -Xms1024m -Xmx1024m -XX:PermSize=64M -XX:MaxPermSize=256m 10. 导致“主线程中的异常”的不同情况是什么？一些常见的主线程异常情况是： 主线程中的java.lang.UnsupportedClassVersionError异常：当您的java类从另一个JDK版本编译并且您正试图从另一个java版本运行时，会出现此异常。 主线程中的java.lang.NoClassDefFoundError异常 ：这个异常有两种变体。第一个是你提供扩展名为.class的类全名的地方。第二种情况是没有找到类时。 主线程中的java.lang.NoSuchMethodError：main异常 ：当您尝试运行一个没有main方法的类时，会发生此异常。 主线程中的java.lang.ArithmeticException异常 ：每当从main方法抛出任何异常时，它将打印出控制台的异常。第一部分说明从main方法抛出异常，第二部分打印异常类名，然后在冒号后打印异常消息。 了解更多，请阅读此文主线程中的Java异常。 11. 在Java中final，finally和finalize有什么区别？final，finally是在java中的关键字，而finalize是一种方法。 final关键字可以和类变量一起使用，这样它们就不能被重新分配，类可以避免通过类和方法扩展来避免被子类覆盖，finally关键字和try-catch块一起使用，以提供总是被执行的语句即使出现一些异常，通常最终也是用来关闭资源的。垃圾收集器在对象被销毁前执行finalize（）方法，这是确保所有全局资源都关闭的好方法。 在三者中，只有finally才涉及到java异常处理。 12. 当main方法抛出异常时会发生什么？当main()方法抛出异常时，Java Runtime会终止程序并在系统控制台中打印异常消息和堆栈跟踪。 13. 我们可以有一个空的catch块吗？我们可以有一个空的catch块，但这是最糟糕的编程例子。我们不应该有空的catch块，因为如果这个块被异常捕获了，我们将没有关于异常的信息，调试它将是一个噩梦。应至少有一个日志记录语句来记录控制台或日志文件中的异常详细信息。 14. 提供一些Java异常处理最佳实践？一些与Java异常处理有关的最佳实践是： 使用特定的例外以方便调试。 在程序中尽早抛出异常（Fail-Fast）。 在程序后期捕获异常，让调用者处理异常。 使用Java 7 ARM功能来确保资源已关闭或使用finally块来正确关闭它们。 总是记录异常消息以进行调试。 使用多个catch块来清理关闭。 使用自定义异常从应用程序API中引发单一类型的异常。 按照命名约定，总是以Exception结束。 记录在javadoc中使用@throws方法抛出的异常。 例外是昂贵的，所以只有当它是有道理的。否则你可以抓住他们，并提供空或空的答复。 了解更多，请阅读此文Java异常处理最佳实践。 15. 下面的程序有什么问题，我们如何解决？在本节中，我们将研究一些与java异常有关的编程问题。 1. 下面的程序有什么问题？123456789101112131415161718192021package com.lexiangmiao.exceptions;import java.io.FileNotFoundException;import java.io.IOException;public class TestException &#123; public static void main(String[] args) &#123; try &#123; testExceptions(); &#125; catch (FileNotFoundException | IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void testExceptions() throws IOException, FileNotFoundException&#123; &#125;&#125; 上面的程序不会编译，你会得到错误信息为 “The exception FileNotFoundException is already caught by the alternative IOException”。这是因为FileNotFoundException是IOException的子类，有两种方法可以解决这个问题。 第一种方法是对于这两个例外都使用单个catch块。1234567try &#123; testExceptions();&#125;catch(FileNotFoundException e)&#123; e.printStackTrace();&#125;catch (IOException e) &#123; e.printStackTrace();&#125; 另一种方法是从multi-catch块中删除FileNotFoundException。12345try &#123; testExceptions();&#125;catch (IOException e) &#123; e.printStackTrace();&#125; 你可以根据你的catch代码选择这些方法。 2. 下面的程序有什么问题？12345678910111213141516171819202122232425package com.lexiangmiao.exceptions;import java.io.FileNotFoundException;import java.io.IOException;import javax.xml.bind.JAXBException;public class TestException1 &#123; public static void main(String[] args) &#123; try &#123; go(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (JAXBException e) &#123; e.printStackTrace(); &#125; &#125; public static void go() throws IOException, JAXBException, FileNotFoundException&#123; &#125;&#125; 程序不会编译，因为FileNotFoundException是IOException的子类，因此FileNotFoundException的catch块无法访问，您将得到错误消息为“Unreachable catch block for FileNotFoundException. It is already handled by the catch block for IOException” 你需要修正catch块的顺序来解决这个问题。123456789try &#123; go();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (JAXBException e) &#123; e.printStackTrace();&#125; 请注意，JAXBException与IOException或FileNotFoundException无关，可以放在上面的catch块层次结构中的任何地方。 3. 下面的程序有什么问题？1234567891011121314151617181920212223242526package com.lexiangmiao.exceptions;import java.io.IOException;import javax.xml.bind.JAXBException;public class TestException2 &#123; public static void main(String[] args) &#123; try &#123; foo(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;catch(JAXBException e)&#123; e.printStackTrace(); &#125;catch(NullPointerException e)&#123; e.printStackTrace(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void foo() throws IOException&#123; &#125;&#125; 程序不会编译，因为JAXBException是一个检查的异常，foo（）方法应该抛出这个异常来捕获调用方法。您将收到错误消息为“Unreachable catch block for JAXBException. This exception is never thrown from the try statement body”。 要解决这个问题，你必须删除JAXBException的catch块。 注意捕获NullPointerException是有效的，因为它是一个未经检查的异常。 4. 下面的程序有什么问题？123456789101112131415161718192021222324package com.lexiangmiao.exceptions;public class TestException3 &#123; public static void main(String[] args) &#123; try&#123; bar(); &#125;catch(NullPointerException e)&#123; e.printStackTrace(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; foo(); &#125; public static void bar()&#123; &#125; public static void foo() throws NullPointerException&#123; &#125;&#125; 这是一个技巧性的问题，代码没有问题，它会成功编译。即使它不在方法的throws子句中，我们也总是可以捕获Exception或任何未经检查的异常。 同样，如果一个方法（foo）在throws子句中声明了未检查的异常，那么在程序中处理这个异常并不是强制性的。 5. 下面的程序有什么问题？1234567891011121314151617181920212223package com.lexiangmiao.exceptions;import java.io.IOException;public class TestException4 &#123; public void start() throws IOException&#123; &#125; public void foo() throws NullPointerException&#123; &#125;&#125;class TestException5 extends TestException4&#123; public void start() throws Exception&#123; &#125; public void foo() throws RuntimeException&#123; &#125;&#125; 上面的程序不会编译，因为start()方法签名在子类中不一样。为了解决这个问题，我们可以将子类中的方法singnature改为与superclass完全相同，或者我们可以从子类方法中删除throws子句，如下所示。123@Overridepublic void start()&#123;&#125; 6. 下面的程序有什么问题？123456789101112131415161718192021222324package com.lexiangmiao.exceptions;import java.io.IOException;import javax.xml.bind.JAXBException;public class TestException6 &#123; public static void main(String[] args) &#123; try &#123; foo(); &#125; catch (IOException | JAXBException e) &#123; e = new Exception(\"\"); e.printStackTrace(); &#125;catch(Exception e)&#123; e = new Exception(\"\"); e.printStackTrace(); &#125; &#125; public static void foo() throws IOException, JAXBException&#123; &#125;&#125; 上面的程序不会编译，因为multi-catch块中的异常对象是final的，我们不能改变它的值。编译时错误是“多个catch块的参数e不能被赋值”。 我们必须删除“e”赋值给新的异常对象来解决这个错误。 阅读更多请阅读Java 7多捕获块。 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,exception,interview,异常,面试","slug":"java-exception-interview-异常-面试","permalink":"/tags/java-exception-interview-异常-面试/"}]},{"title":"Java集合面试问题","slug":"java-collections-interview-questions","date":"2018-11-26T05:54:44.497Z","updated":"2017-12-26T05:57:59.449Z","comments":true,"path":"2018/11/26/java-collections-interview-questions/","link":"","permalink":"/2018/11/26/java-collections-interview-questions/","excerpt":"Java集合框架是Java编程语言的基本方面。 他是java面试问题的重要话题之一。 在这里，我列出了一些重要的java集合面试问题和答案，以帮助你面试。 这些直接来自我在Java编程方面10多年的经验。","text":"Java集合框架是Java编程语言的基本方面。 他是java面试问题的重要话题之一。 在这里，我列出了一些重要的java集合面试问题和答案，以帮助你面试。 这些直接来自我在Java编程方面10多年的经验。 Java多线程面试问题 Java 8中新增与集合相关的功能是什么？ Java集合框架是什么？ 列出它的好处？ 泛型在集合框架中的好处是什么？ Java集合框架的基本接口有哪些？ 为什么Collection接口不能扩展Cloneable和Serializable接口？ 为什么Map接口不能扩展Collection接口？ 什么是迭代器？ 枚举和Iterator接口有什么区别？ 为什么没有类似Iterator.add（）的方法来添加元素到集合中？ 为什么迭代器没有一个方法直接得到下一个元素而不移动光标？ Iterator和ListIterator有什么不同？ 迭代列表有什么不同的方法？ 你怎么理解迭代器失败的快速属性？ 故障快速和故障安全有什么区别？ 如何在迭代集合时避免ConcurrentModificationException？ 为什么没有Iterator接口的具体实现？ 什么是UnsupportedOperationException？ HashMap如何在Java中工作？ hashCode()和equals()方法有何重要性？ 我们可以使用任何类作为Map键吗？ Map接口提供了哪些不同的集合视图？ HashMap和Hashtable有什么区别？ 如何决定HashMap和TreeMap？ ArrayList和Vector有什么相似之处？ Array和ArrayList有什么区别？ 你什么时候使用Array Array ArrayList？ ArrayList和LinkedList有什么区别？ 哪些集合类提供随机访问它的元素？ 什么是EnumSet？ 哪些集合类是线程安全的？ 什么是并发的集合类？ 什么是BlockingQueue？ 什么是队列和堆栈，列出他们的区别？ 什么是集合类？ 什么是Comparable和Comparator接口？ Comparable和Comparator接口有什么不同？ 我们如何排序对象列表？ 在将Collection作为参数传递给一个函数的时候，我们如何确保函数不能修改呢？ 我们如何从给定的集合创建一个同步的集合？ 在Collections Framework中实现的常用算法是什么？ 什么是大O符号？ 举一些例子？ 什么是与Java集合框架相关的最佳实践？ 什么是Java优先级队列？ 为什么我们不能把代码写成List&lt;Number&gt; numbers = new ArrayList&lt;Integer&gt;(); ？ 为什么我们不能创建泛型数组？ 或者将代码编写为List&lt;Integer&gt;[] array = new ArrayList&lt;Integer&gt;[10]; Java集合面试问题和答案1. Java 8中新增与集合相关的功能是什么？Java 8在Collection API中带来了重大变化。 一些变化是： 用于集合类的Java Stream API ，用于支持顺序以及并行处理 可迭代接口用forEach（）默认的方法扩展，我们可以使用它来遍历集合。在使用lambda表达式时非常有用，因为它的参数Consumer是一个函数接口 。 Miscellaneous Collection API改进，如Iterator接口中的forEachRemaining(Consumer action)方法，Map的replaceAll() ， compute() ， merge()方法。 2. Java集合框架是什么？ 列出它的好处？每种编程语言都会使用集合，最初的java版本包含 Vector，Stack，Hashtable，Array几个集合的类。 但是考虑到更大范围使用，Java 1.2提出集合框架由集合接口、实现（类）和算法组成。Java集合已经通过使用泛型和并发集合类来进行线程安全操作。 它还包括在java并发包中的阻塞接口及其实现。 集合框架有如下好处： 通过使用核心集合类而不是实现我们自己的集合类来减少开发工作量。 通过使用经过良好测试的集合框架类来提高代码质量。 通过使用JDK附带的集合类减少了代码维护的工作量。 可重用性和互操作性 3. 泛型在集合框架中的好处是什么？Java 1.5引入泛型，所有的集合接口和实现都大量使用它。 泛型允许我们提供一个指定Object类型的类型集合，所以如果你尝试添加其他类型的元素，它会引发编译时错误。 因为编译时会出现错误，从而可以避免运行时出现ClassCastException。此外，泛型使代码更简洁，因为我们不需要使用casting和instanceof操作符。 4. Java集合框架的基本接口有哪些？Collection是集合层次结构的根。集合表示一组元素的对象。Java平台不提供此接口的任何直接实现。 Set是一个不能包含重复元素的集合。这个接口模拟数学集合抽象，并用来表示集合，例如一副牌。 List是一个有序的集合，可以包含重复的元素。 您可以从索引中访问任何元素。List更像是动态长度的数组。 Map是一个将键映射到值的对象。 Map不能包含重复键：每个键最多只能映射一个值。 其他一些接口是Queue，Dequeue，Iterator，SortedSet，SortedMap和ListIterator。 5. 为什么Collection接口不能扩展Cloneable和Serializable接口？Collection接口指定了一组被称为元素的对象。元素如何维护取决于Collection的具体实现。例如，像List这样的一些Collection实现允许重复的元素，而像Set这样的其他实现不这样做。 很多集合实现都有一个公共的克隆方法。但是，将其包含在Collection的所有实现中并没有任何意义。这是因为Collection是一个抽象表示。 重要的是实现。 在处理实际的实现时，克隆或序列化的语义和含义起作用; 所以具体的实现应该决定如何克隆或序列化，甚至可以克隆或序列化。 因此，在所有实现中强制克隆和序列化实际上不那么灵活和更具限制性。 具体实施应该做出是否可以克隆或序列化的决定。 6. 为什么Map接口不能扩展Collection接口？虽然Map接口和它的实现是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map对扩展Collection是没有意义的，反之亦然。 如果Map扩展了Collection接口，那么元素在哪里？Map包含键值对，它提供了将键或值列表作为集合检索的方法，但它不适合“元素组”范例。 7. 什么是Iterator接口？Iterator接口提供了迭代任何Collection的方法。 我们可以使用iterator（）方法从一个Collection中获取迭代器实例。迭代器代替Java集合框架中的枚举。迭代器允许调用者在迭代期间从底层集合中移除元素。Java集合迭代器提供了一种遍历集合元素的通用方法，并实现了Iterator设计模式 。 8. Enumeration接口和Iterator接口有什么区别？Enumeration接口的速度是Iterator接口的两倍，而且使用的内存很少。 Enumeration接口非常基本，适合基本需求。但是与Enumeration接口相比，Iterator接口更安全，因为它总是拒绝其他线程修改正在迭代的集合对象。 Iterator接口代替Java集合框架中的Enumeration接口。Iterator接口允许调用者从底层集合中删除元素，但Enumeration接口中不能。 Iterator方法名称已被改进，以使其功能清晰。 9. 为什么没有类似Iterator.add（）的方法来添加元素到集合中？语义不清楚，因为Iterator的合约不能保证迭代的顺序。但是请注意，ListIterator确实提供了一个添加操作，因为它确保了迭代的顺序。 10. 为什么Iterator没有一个方法直接得到下一个元素而不移动光标？它可以在当前的Iterator接口之上实现，但是由于它的使用很少，所以将它包含在每个人都必须实现的接口中是没有意义的。 11. Iterator和ListIterator有什么不同？ ListIterator继承自Iterator接口，并附带额外的功能，如添加元素，替换元素，获取前一个元素和下一个元素的索引位置。 我们可以使用Iterator遍历Set和List集合，而ListIterator只能用于List。 Iterator只能沿正向移动，而ListIterator可以沿两个方向移动。 12. 迭代列表有什么不同的方法？我们可以用两种不同的方式迭代列表 - 使用iterator和for-each循环。12345678910111213List&lt;String&gt; strList = new ArrayList&lt;&gt;();//using for-each loopfor(String obj : strList)&#123; System.out.println(obj);&#125;//using iteratorIterator&lt;String&gt; it = strList.iterator();while(it.hasNext())&#123; String obj = it.next(); System.out.println(obj);&#125; 使用iterator是更线程安全的，因为如果基础列表元素被修改，它将抛出ConcurrentModificationException。 13. 你怎么理解iterator fail-fast属性？每当我们尝试获取下一个元素时，iterator fail-fast属性检查底层集合的结构中的任何修改。如果找到任何修改，则抛出ConcurrentModificationException。Collection类中的Iterator的所有实现都是按设计fail-fast执行的，除了ConcurrentHashMap和CopyOnWriteArrayList等并发集合类。 14. fail-fast和fail-safe有什么区别？iterator fail-safe属性与底层集合的克隆一起工作，因此它不受集合中任何修改的影响。 通过设计，java.util包中的所有集合类都是fail-fast的，而java.util.concurrent中的集合类是fail-safe的。 fail-fast iterator抛出ConcurrentModificationException，而fail-safe iterator永远不抛出ConcurrentModificationException。 15. 如何在迭代集合时避免ConcurrentModificationException？我们可以使用并发集合类来避免ConcurrentModificationException迭代集合，例如CopyOnWriteArrayList而不是ArrayList。 16. 为什么没有Iterator接口的具体实现？Iterator接口声明迭代一个集合的方法，但它的实现是集合具体类的责任。每个返回遍历iterator的集合类都有自己的Iterator实现嵌套类。 这允许集合类选择迭代器是fail-fast还是 fail-safe的。例如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。 17. 什么是UnsupportedOperationException？UnsupportedOperationException是用于指示操作不支持的异常。 它在JDK类中广泛使用，在集合框架java.util.Collections.UnmodifiableCollection对所有add和remove操作引发此异常。 18. HashMap如何在Java中工作？HashMap在Map.Entry静态嵌套类实现中存储键值对。HashMap基于哈希算法进行工作，在put和get方法中使用hashCode（）和equals（）方法。 当我们通过传递键值对来调用put方法时，HashMap使用Key hashCode（）和hash来找出存储键值对的索引。 Entry存储在LinkedList中，所以如果已经存在，则使用equals（）方法检查传递的键是否已经存在，如果是则覆盖该值，否则会创建一个新Entry并保存。 当我们通过传递Key来调用get方法时，它再次使用hashCode（）来查找数组中的索引，然后使用equals（）方法来查找正确的Entry并返回它的值。 其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。 HashMap初始默认容量为16 ，负载因子为0.75。 阈值是容量乘以负载因子，每当我们尝试添加entry时，如果映射大小大于阈值，则HashMap将映射的内容重新映射到具有更大容量的新数组中。 容量始终为2，所以如果你知道你需要存储大量的键值对，例如从数据库中缓存数据，最好用正确的容量和负载因子来初始化HashMap。 19. hashCode()和equals()方法有何重要性？HashMap使用Key对象的hashCode（）和equals（）方法确定放置键值对的索引。 当我们试图从HashMap获取值时，也使用这些方法。 如果这些方法没有正确实现，两个不同的Key可能产生相同的hashCode（）和equals（）输出，在这种情况下，而不是将其存储在不同的位置，HashMap会认为它们相同并覆盖它们。 同样，所有不存储重复数据的集合类都使用hashCode（）和equals（）来查找重复项，所以正确实现它们非常重要。equals（）和hashCode（）的实现应遵循这些规则。 如果o1.equals(o2) ，那么o1.hashCode() == o2.hashCode()应该总是为true。 如果o1.hashCode() == o2.hashCode为true，那么并不意味着o1.equals(o2)将为true。 20. 我们可以使用任何类作为Map键吗？我们可以使用任何类作为Map Key，但在使用它们之前应考虑以下几点。 如果类重写equals（）方法，它也应该重写hashCode（）方法。 该类应遵循与所有实例的equals（）和hashCode（）相关的规则。 请参阅前面的问题了解这些规则。 如果在equals（）中没有使用类字段，则不应在hashCode（）方法中使用它。 用户定义密钥类的最佳做法是使其不可变，以便可以高速缓存hashCode（）值以实现快速性能。 另外不可变的类确保hashCode（）和equals（）在将来不会改变，这将解决任何可变性问题。 例如，假设我有一个用于HashMap键的类MyKey 。123456789101112//传递的MyKey name参数用于equals（）和hashCode（）MyKey key = new MyKey（“Pankaj”）; //假定hashCode = 1234myHashMap.put（key，“Value”）;//下面的代码将改变密钥hashCode（）和equals（）//但是它的位置没有改变key.setName（ “阿米特”）; //假定新的hashCode = 7890//下面将返回null，因为HashMap将尝试查找关键字//与它存储在同一个索引中，但是由于密钥发生了变化， //将不会有匹配，它将返回null。myHashMap.get（new MyKey（“Pankaj”））; 这就是为什么String和Integer主要用作HashMap键的原因。 21. Map接口提供了哪些不同的集合视图？Map界面提供了三种集合视图： Set&lt;K&gt; keySet()：返回包含在此映射中的键的Set视图。 该集合受Map支持，所以对地图的更改反映在集合中，反之亦然。 如果在对集合进行迭代的过程中修改了映射（除了通过迭代器自己的删除操作），迭代的结果是未定义的。该Set支持元素删除，通过Iterator.remove，Set.remove，removeAll，retainAll和clear操作从映射中删除相应的映射。 但它不支持add或addAll操作。 Collection&lt;V&gt; values()：返回此映射中包含的值的Collection视图。该集合受Map支持，所以对地图的更改反映在集合中，反之亦然。如果在迭代集合的过程中修改了映射（除了通过迭代器自己的删除操作），迭代的结果是未定义的。该集合支持元素删除，通过Iterator.remove，Collection.remove，removeAll，retainAll和Clear操作从映射中删除相应的映射。 但它不支持add或addAll操作。 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()：返回此映射中包含的映射的Set视图。该集合受Map支持，所以对地图的更改反映在集合中，反之亦然。 如果在对集合进行迭代的过程中修改了映射（除了通过迭代器自己的删除操作，或者通过迭代器返回的映射条目上的setValue操作），迭代的结果是未定义的。该Set支持元素删除，通过Iterator.remove，Set.remove，removeAll，retainAll和Clear操作从映射中删除相应的映射。但它不支持add或addAll操作。 22. HashMap和Hashtable有什么区别？HashMap和Hashtable都实现了Map接口并且看起来很相似，但是HashMap和Hashtable之间存在以下区别。 HashMap允许空键和值，而Hashtable不允许空键和值。 Hashtable是同步的但HashMap不同步。所以HashMap对单线程环境更好，Hashtable适用于多线程环境。 LinkedHashMap是在Java 1.4中作为HashMap的子类引入的，所以如果你想要迭代次序，你可以很容易地从HashMap切换到LinkedHashMap，但是迭代顺序不可预测的Hashtable并不是这样。 HashMap提供了一组密钥来迭代，因此它是fail-fast的，但Hashtable提供了不支持这个特性的密钥枚举。 Hashtable被认为是遗留类，如果您在迭代时正在寻找Map的修改，则应该使用ConcurrentHashMap。 23. 如何决定HashMap和TreeMap？为了插入，删除和定位Map中的元素，HashMap提供了最好的选择。但是，如果您需要按排序顺序遍历键，那么TreeMap是您更好的选择。 根据集合的大小，将元素添加到HashMap可能会更快，然后将映射转换为TreeMap以进行排序的键遍历。 24. ArrayList和Vector有什么相似之处？ArrayList和Vector在很多方面都是类似的类。 两者都是基于索引的，并由内部数组进行备份。 两者都保持插入顺序，我们可以按照插入顺序获取元素。 ArrayList和Vector的迭代器实现都是fail-fast设计的。 ArrayList和Vector都允许空值和使用索引随机访问元素。 这些是ArrayList和Vector之间的区别。 Vector是同步的，而ArrayList不同步。但是，如果您在迭代时正在查找列表修改，则应该使用CopyOnWriteArrayList。 ArrayList比Vector快，因为它没有任何开销，因为同步。 ArrayList更通用，因为我们可以使用Collections实用程序类轻松地获得同步列表或只读列表。 25. Array和ArrayList有什么区别？ 你什么时候使用Array Array ArrayList？Array可以包含原始类型或对象，而ArrayList只能包含对象。Array是固定大小，而ArrayList大小是动态的。Array不提供很多像ArrayList一样的功能，比如addAll，removeAll，iterator等 虽然ArrayList是我们在列表上工作的首选，但是Array有如下几个使用场景。 列表的大小是固定的，并且主要用于存储和遍历。 对于原始类型的列表，尽管集合使用自动装箱来减少编码工作，但是当处理固定大小的原始数据类型时，它仍会变慢。 如果您正在处理固定的多维情况，使用[] []比List &lt;List &lt;&gt;&gt;要容易得多。 26. ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，但是它们之间有一些区别。 ArrayList是一个由Array支持的基于索引的数据结构，因此它提供对性能为O（1）的元素的随机访问，但LinkedList将数据存储为节点列表，其中每个节点都链接到它的上一个节点和下一个节点。所以即使有一个方法来获取使用索引的元素，内部它从开始到达索引节点然后返回元素，所以性能是O（n）比ArrayList慢。 在LinkedList中插入，添加或删除元素比ArrayList更快，因为在中间添加元素时，没有调整数组大小或更新索引的概念。 LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点都存储了前一个元素和下一个元素的引用。 27. 哪些集合类提供随机访问它的元素？ArrayList，HashMap，TreeMap，Hashtable类提供随机访问它的元素。 28. 什么是EnumSet？java.util.EnumSet被设置为与枚举类型一起使用。 枚举集合中的所有元素必须来自单个枚举类型，在创建集合时显式或隐式指定。 EnumSet不同步，不允许空元素。 它还提供了一些有用的方法，如copyOf（Collection c），（E first，E … rest）和complementOf（EnumSet s）。 29. 哪些集合类是线程安全的？Vector，Hashtable，Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境中使用。 Java 1.5 并发API包含一些集合类，允许在迭代时修改集合，因为它们工作在集合的克隆上，所以它们可以安全地在多线程环境中使用。 30. 什么是并发的集合类？Java 1.5并发包（ java.util.concurrent ）包含线程安全的集合类，允许集合在迭代时被修改。 通过设计， java.util包中的迭代器实现fail-fast并引发ConcurrentModificationException。 但是java.util.concurrent包中的Iterator实现是自动安全的，我们可以在迭代时修改集合。 其中一些类是CopyOnWriteArrayList ， ConcurrentHashMap ， CopyOnWriteArraySet 。 31. 什么是BlockingQueue？java.util.concurrent.BlockingQueue是一个队列，它支持在检索和删除元素时等待队列变为非空的操作，并且在添加元素时等待队列中的空间变为可用。 BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者消费者问题。 BlockingQueue中的消费者可以使用BlockingQueue的实现类来处理生产者或对象的空间。 Java提供了几个BlockingQueue实现，如ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue，SynchronousQueue等 32. 什么是Queue和Stack，列出他们的区别？Queue和Stack都用于在处理数据之前存储数据。 java.util.Queue是一个接口，其实现类在java并发包中。 队列允许以先进先出（FIFO）顺序检索元素，但情况并非总是如此。 还有一个Deque接口，允许从队列的两端检索元素。 堆栈与队列相似，只不过它允许以后进先出（LIFO）顺序检索元素。 Stack是一个扩展Vector的类，而Queue则是一个接口。 33. 什么是Collections类？java.util.Collections是一个实用工具类，它只包含对集合进行操作或返回集合的静态方法。 它包含对集合进行操作的多态算法，“包装器”，返回由指定集合支持的新集合，以及其他一些可能性和结束。 这个类包含用于收集框架算法的方法，例如二进制搜索，排序，混淆，反转等。 34. 什么是Comparable和Comparator接口？Java提供了Comparable接口，如果我们想使用Arrays或Collections排序方法，应该由任何自定义类来实现。 可比较的接口有排序方法使用的compareTo（T obj）方法。如果“this”对象小于，等于或大于作为参数传递的对象，我们应该以这样的方式覆盖此方法，即返回负整数，零或正整数。 但是，在大多数现实生活场景中，我们希望根据不同的参数进行排序。比如，作为首席执行官，我想根据薪水对员工进行排序，人力资源部门会根据年龄对他们进行排序。 这是我们需要使用Comparator接口的情况，因为Comparable.compareTo(Object o)方法实现只能根据一个字段进行排序，而我们不能选择我们想要对该对象进行排序的字段。 Comparator接口中的compare(Object o1, Object o2)方法需要实现两个Object参数，它应该以这样的方式实现：如果第一个参数小于第二个参数，则返回负值int，如果相等则返回零如果第一个参数大于第二个参数，则为正值。 35. Comparable和Comparator接口有什么不同？Comparable和Comparator接口用于排序集合或对象数组。 Comparable接口用于提供对象的自然排序，我们可以使用它来提供基于单一逻辑的排序。 （实体类实现）Comparator接口用于提供不同的排序算法，我们可以选择我们想要用来对给定的对象集合进行排序的比较器。（调用方实现） 36. 我们如何排序对象列表？如果我们需要排序一个对象数组，我们可以使用Arrays.sort()。 如果我们需要排序一个对象列表，我们可以使用Collections.sort()。 这两个类都有重载的sort（）方法用于自然排序（使用Comparable）或基于条件进行排序（使用Comparator）。 集合内部使用Arrays排序方法，所以他们都有相同的性能，除了集合需要时间将列表转换为数组外。 37. 在将Collection作为参数传递给一个函数的时候，我们如何确保函数不能修改呢？在传递参数之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保任何更改集合的操作都会抛出UnsupportedOperationException 。 38. 我们如何从给定的集合创建一个同步的集合？我们可以使用Collections.synchronizedCollection(Collection c)来获得由指定集合支持的同步（线程安全）的集合。 39. 在Collections Framework中实现的常用算法是什么？Java集合框架提供了常用的算法实现，如排序和搜索。 集合类包含这些方法的实现。这些算法大部分都在List上工作，但其中一些适用于各种集合。其中一些是排序，搜索，混淆，最小值最大值。 40. 什么是大O符号？ 举一些例子？大O符号按照数据结构中元素的数量来描述算法的性能。由于Collection类实际上是数据结构，所以我们通常倾向于使用大O表示法来根据时间，内存和性能选择使用的集合实现。 示例1：ArrayList get(index i)是一个常量操作，不依赖于列表中元素的数量。 所以大O表示法的性能是O（1）。示例2：对数组或列表性能的线性搜索是O（n），因为我们需要搜索整个元素列表以查找元素。 41. 与Java Collections框架相关的最佳实践是什么？ 根据需要选择正确类型的集合，例如，如果大小是固定的，我们可能希望使用Array而不是ArrayList。如果我们必须按照插入次序遍历Map，那么我们需要使用TreeMap。 如果我们不想重复，我们应该使用Set。 有些集合类允许指定初始容量，因此如果我们预估了要存储的元素数量，我们可以使用它来避免重新哈希或调整大小。 根据接口而不是实现来编写程序，它使我们能够在更晚的时间点轻松地改变实现。 为了类型安全总是使用泛型，从而避免在运行时出现ClassCastException。 使用JDK提供的不可变类作为Map中的键，以避免为我们的自定义类实现hashCode（）和equals（）。 尽可能多地使用Collections工具类来获取算法，或者获取只读，同步或空集合，而不是编写自己的实现。它将增强代码重用的稳定性和可维护性。 42. Java PriorityQueue是什么？PriorityQueue是基于优先级堆的无限队列，元素按照自然顺序排序，或者我们可以在创建时提供比较器进行排序。PriorityQueue不允许空值，我们不能添加任何不提供自然顺序的对象，或者我们没有任何比较器来排序。 Java PriorityQueue不是线程安全的，并提供了O（log（n））入队和出队操作的时间。 43. 为什么我们不能把代码写成List&lt;Number&gt; numbers = new ArrayList&lt;Integer&gt;(); ？泛型不支持子类型，因为它会导致实现类型安全的问题。 这就是为什么List &lt;T&gt;不被认为是List &lt;S&gt;的子类型，其中S是T的超类型。为了理解为什么不被允许，让我们看看如果它被支持，会发生什么。1234List &lt;Long&gt; listLong = new ArrayList &lt;Long&gt;（）;listLong.add（Long.valueOf（10））;List &lt;Number&gt; listNumbers = listLong; //编译器错误listNumbers.add（Double.valueOf（1.23））; 正如你从上面的代码可以看到，IF泛型支持子类型输入，我们可以很容易地在Long列表中添加一个Double，这个Long列表在遍历Long列表的时候会在运行时导致ClassCastException 。 44. 为什么我们不能创建泛型数组？ 或者将代码编写为List&lt;Integer&gt;[] array = new ArrayList&lt;Integer&gt;[10];我们不允许创建泛型数组，因为数组在运行时携带了元素的类型信息。如果元素类型与定义的类型不匹配，则在运行时使用此信息来抛出ArrayStoreException 。由于泛型类型信息在编译时被类型擦除，所以数组存储检查将会在应该失败的地方通过。让我们用一个简单的示例代码来理解这一点。12345List &lt;Integer&gt; [] intList = new List &lt;Integer&gt; [5]; //编译错误Object [] objArray = intList;List &lt;Double&gt; doubleList = new ArrayList &lt;Double&gt;（）;doubleList.add（Double.valueOf（1.23））;objArray [0] = doubleList; //这会失败，但会通过，因为在运行时intList和doubleList都只是List 数组是自然协变的，即当S是T的子类型时，S []是T []的一个子类型，但泛型不支持协方差或子类型，正如我们在上一个问题中看到的那样。所以如果我们被允许创建通用数组，因为类型擦除，我们不会得到数组存储异常，即使这两种类型都不相关。 引用 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"collections, list, set, map，堆空间,堆栈,栈内存,内存分配","slug":"collections-list-set-map，堆空间-堆栈-栈内存-内存分配","permalink":"/tags/collections-list-set-map，堆空间-堆栈-栈内存-内存分配/"}]},{"title":"Java类加载器","slug":"java-classloader","date":"2018-11-26T05:54:44.482Z","updated":"2018-01-17T02:55:21.608Z","comments":true,"path":"2018/11/26/java-classloader/","link":"","permalink":"/2018/11/26/java-classloader/","excerpt":"Java类加载器是项目开发中Java的一个重要但很少使用的组件。就个而言，我从来没有在任何项目中扩展ClassLoader，但有我自己的ClassLoader，可以自定义Java类加载的想法刺激我，写以篇文章。","text":"Java类加载器是项目开发中Java的一个重要但很少使用的组件。就个而言，我从来没有在任何项目中扩展ClassLoader，但有我自己的ClassLoader，可以自定义Java类加载的想法刺激我，写以篇文章。 目录 Java类加载器&nbsp;&nbsp;&nbsp;&nbsp;1.1 什么是Java类加载器？&nbsp;&nbsp;&nbsp;&nbsp;1.2 为什么在Java中编写自定义类加载器？&nbsp;&nbsp;&nbsp;&nbsp;1.3 Java类加载器如何工作？&nbsp;&nbsp;&nbsp;&nbsp;1.4 Java自定义ClassLoader&nbsp;&nbsp;&nbsp;&nbsp;1.5 Java自定义ClassLoader执行步骤&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5.1 由m29的评论更新&nbsp;&nbsp;&nbsp;&nbsp;1.6 使用ClassLoader Java选项的Mac OS X 10.6.4问题 Java类加载器本文将提供Java类加载器的概述，然后在Java中创建自定义的ClassLoader。 什么是Java类加载器？我们知道Java程序在Java虚拟机 （JVM）上运行。当我们编译一个Java类时，它将以平台和机器独立编译程序的字节码的形式进行转换，并将其存储为一个.class文件。之后，当我们尝试使用一个类时，Java类加载器会将该类加载到内存中。 Java中有三种类型的内置ClassLoader： 引导类加载器（Bootstrap Class Loader） - 加载JDK内部类，通常加载rt.jar和其他核心类，例如java.lang。*包类 扩展类加载器 - 它从JDK扩展目录加载类，通常是$ JAVA_HOME / lib / ext目录。 系统类加载器 - 它从当前类路径加载类， 该类可以在使用-cp或-classpath命令行选项调用程序时进行设置。 Java类加载器是分层的，每当引发一个请求来加载一个类时，它就委托给它的父类加载器，这样在运行环境中就保持了唯一性。 如果父类加载器没有找到该类，那么类加载器自身会尝试加载该类。 让我们通过执行下面的java程序来理解这个： ClassLoaderTest.java 12345678910111213141516171819package com.lexiangmiao.classloader;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; System.out.println(\"class loader for HashMap: \" + java.util.HashMap.class.getClassLoader()); System.out.println(\"class loader for DNSNameService: \" + sun.net.spi.nameservice.dns.DNSNameService.class .getClassLoader()); System.out.println(\"class loader for this class: \" + ClassLoaderTest.class.getClassLoader()); System.out.println(com.mysql.jdbc.Blob.class.getClassLoader()); &#125;&#125; 上面的Java类加载器示例程序的输出是： 1234class loader for HashMap: nullclass loader for DNSNameService: sun.misc.Launcher$ExtClassLoader@7c354093class loader for this class: sun.misc.Launcher$AppClassLoader@64cbbe37sun.misc.Launcher$AppClassLoader@64cbbe37 正如你所看到的，java.util.HashMap的ClassLoader是空的，它反映了Bootstrap类加载器，而DNSNameService类加载器是ExtClassLoader。 由于类本身在CLASSPATH中，所以System ClassLoader会加载它。 当我们试图加载HashMap的时候，我们的System ClassLoader把它委托给扩展类加载器，扩展类加载器又将其委派给Bootstrap ClassLoader，该类发现该类，并将其加载到JVM中。 DNSNameService类遵循相同的过程，但Bootstrap ClassLoader无法找到它，因为它在$ JAVA_HOME / lib / ext / dnsns.jar中，因此被扩展类加载器加载。 请注意，Blob类包含在MySql JDBC Connector jar（mysql-connector-java-5.0.7-bin.jar）中，在执行它之前，它已经包含在项目的构建路径中，并且它也通过System Class Loader 。 还有一点需要注意的是，由子类加载器加载的类可以看到由其父类加载器加载的类。 因此，由System ClassLoader加载的类可以看到由Extensions和Bootstrap ClassLoader加载的类。 如果有兄弟类加载器，则不能访问彼此加载的类。 为什么在Java中编写自定义类加载器？Java默认的ClassLoader可以从本地文件系统加载足够大多数情况下的文件。 但是，如果您在加载类时在运行时或者从FTP服务器或通过第三方Web服务期望类，则必须扩展现有的类加载器。 例如，AppletViewers从远程Web服务器加载类。 Java类加载器如何工作？当JVM请求一个类时，它通过传递Class的完全限定的名字来调用ClassLoader的loadClass函数。 loadClass函数调用findLoadedClass()方法来检查类是否已经被加载。 需要避免多次加载课程。 如果Class尚未被加载，那么它将把请求委托给父类加载器来加载类。 如果父类加载器没有找到该类，那么它将调用findClass（）方法来查找文件系统中的类。 Java自定义ClassLoader我们将通过扩展ClassLoader类和重写loadClass（String name）方法来创建自己的ClassLoader。 如果名称将从com.journaldev（即我们的示例类包）开始，那么我们将使用我们自己的类加载器加载它，否则我们将调用父类ClassLoader的loadClass（）方法来加载类。 项目结构如下图所示： Java类加载器，Java中的ClassLoader，Java Class Loader，Java类加载器示例CCLoader.java ：这是我们的自定义类加载器，具有以下方法。 private byte[] loadClassFileData(String name) ：此方法将从文件系统读取类文件到字节数组。 private Class getClass(String name) private Class getClass(String name)这个方法将调用loadClassFileData（）函数，并通过调用父类的defineClass（）方法，它将生成类并返回它。 public Class loadClass(String name) public Class loadClass(String name) ：这个方法负责加载类。 如果类名以com.journaldev（我们的示例类）开头，那么它将使用getClass（）方法加载它，否则将调用父类loadClass函数加载它。 public CCLoader(ClassLoader parent) ：这是负责设置父ClassLoader的构造函数。 CCLoader.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 import java.io.DataInputStream;import java.io.File;import java.io.IOException;import java.io.InputStream; /** * Our Custom Class Loader to load the classes. Any class in the com.journaldev * package will be loaded using this ClassLoader. For other classes, it will * delegate the request to its Parent ClassLoader. * */public class CCLoader extends ClassLoader &#123; /** * This constructor is used to set the parent ClassLoader */ public CCLoader(ClassLoader parent) &#123; super(parent); &#125; /** * Loads the class from the file system. The class file should be located in * the file system. The name should be relative to get the file location * * @param name * Fully Classified name of class, for example com.journaldev.Foo */ private Class getClass(String name) throws ClassNotFoundException &#123; String file = name.replace('.', File.separatorChar) + \".class\"; byte[] b = null; try &#123; // This loads the byte code data from the file b = loadClassFileData(file); // defineClass is inherited from the ClassLoader class // that converts byte array into a Class. defineClass is Final // so we cannot override it Class c = defineClass(name, b, 0, b.length); resolveClass(c); return c; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * Every request for a class passes through this method. If the class is in * com.journaldev package, we will use this classloader or else delegate the * request to parent classloader. * * * @param name * Full class name */ @Override public Class loadClass(String name) throws ClassNotFoundException &#123; System.out.println(\"Loading Class '\" + name + \"'\"); if (name.startsWith(\"com.journaldev\")) &#123; System.out.println(\"Loading Class using CCLoader\"); return getClass(name); &#125; return super.loadClass(name); &#125; /** * Reads the file (.class) into a byte array. The file should be * accessible as a resource and make sure that its not in Classpath to avoid * any confusion. * * @param name * File name * @return Byte array read from the file * @throws IOException * if any exception comes in reading the file */ private byte[] loadClassFileData(String name) throws IOException &#123; InputStream stream = getClass().getClassLoader().getResourceAsStream( name); int size = stream.available(); byte buff[] = new byte[size]; DataInputStream in = new DataInputStream(stream); in.readFully(buff); in.close(); return buff; &#125;&#125; CCRun.java ： 这是我们使用主函数的测试类，我们正在创建ClassLoader的对象，并使用它的loadClass方法加载样本类。 加载类之后，我们使用Java反射API来调用它的方法。 CCRun.java 1234567891011121314151617181920212223import java.lang.reflect.Method; public class CCRun &#123; public static void main(String args[]) throws Exception &#123; String progClass = args[0]; String progArgs[] = new String[args.length - 1]; System.arraycopy(args, 1, progArgs, 0, progArgs.length); CCLoader ccl = new CCLoader(CCRun.class.getClassLoader()); Class clas = ccl.loadClass(progClass); Class mainArgType[] = &#123; (new String[0]).getClass() &#125;; Method main = clas.getMethod(\"main\", mainArgType); Object argsArray[] = &#123; progArgs &#125;; main.invoke(null, argsArray); // Below method is used to check that the Foo is getting loaded // by our custom class loader i.e CCLoader Method printCL = clas.getMethod(\"printCL\", null); printCL.invoke(null, new Object[0]); &#125; &#125; Foo.java和Bar.java ： 这些是由我们的自定义类加载器加载的测试类。 他们还有一个printCL（）方法，被调用来打印已加载Class的ClassLoader。 Foo类将由我们的自定义类加载器加载，后者又使用Bar类，所以Bar类也将由我们的自定义类加载器加载。 Foo.java 1234567891011public class Foo &#123; static public void main(String args[]) throws Exception &#123; System.out.println(\"Foo Constructor &gt;&gt;&gt; \" + args[0] + \" \" + args[1]); Bar bar = new Bar(args[0], args[1]); bar.printCL(); &#125; public static void printCL() &#123; System.out.println(\"Foo ClassLoader: \"+Foo.class.getClassLoader()); &#125;&#125; Bar.java 12345678910public class Bar &#123; public Bar(String a, String b) &#123; System.out.println(\"Bar Constructor &gt;&gt;&gt; \" + a + \" \" + b); &#125; public void printCL() &#123; System.out.println(\"Bar ClassLoader: \"+Bar.class.getClassLoader()); &#125;&#125; Java自定义ClassLoader执行步骤 首先我们将通过命令行编译所有的类。 之后，我们将通过传递三个参数来运行CCRun类。 第一个参数是Foo类的完整分类名称，它将被我们的类加载器加载。 其他两个参数传递给Foo类的main函数和Bar构造函数。 输出的执行步骤如下所示。 123456789101112131415161718192021222324252627 Pankaj$ javac -cp . com/journaldev/cl/Foo.javaPankaj$ javac -cp . com/journaldev/cl/Bar.javaPankaj$ javac CCLoader.javaPankaj$ javac CCRun.javaCCRun.java:18: warning: non-varargs call of varargs method with inexact argument type for last parameter;cast to java.lang.Class&lt;?&gt; for a varargs callcast to java.lang.Class&lt;?&gt;[] for a non-varargs call and to suppress this warningMethod printCL = clas.getMethod(\"printCL\", null);^1 warningPankaj$ java CCRun com.journaldev.cl.Foo 1212 1313Loading Class 'com.journaldev.cl.Foo'Loading Class using CCLoaderLoading Class 'java.lang.Object'Loading Class 'java.lang.String'Loading Class 'java.lang.Exception'Loading Class 'java.lang.System'Loading Class 'java.lang.StringBuilder'Loading Class 'java.io.PrintStream'Foo Constructor &gt;&gt;&gt; 1212 1313Loading Class 'com.journaldev.cl.Bar'Loading Class using CCLoaderBar Constructor &gt;&gt;&gt; 1212 1313Loading Class 'java.lang.Class'Bar ClassLoader: CCLoader@71f6f0bfFoo ClassLoader: CCLoader@71f6f0bfctk-pcs1313512-2:src pk93229$ 如果仔细查看输出，首先尝试加载com.journaldev.cl.Foo类，但是由于它扩展了java.lang.Object类，它试图首先加载它，然后请求它来到CCLoader的loadClass方法，即委托它的父类。 所以父类加载器正在加载对象，字符串和其他Java类。 我们的ClassLoader只从调用printCL（）函数的文件系统中加载Foo和Bar类。 请注意，我们可以通过更改loadClassFileData（）函数来从FTP服务器读取字节数组，或通过调用任何第三方服务来即时获取类字节数组。 我希望这篇文章有助于理解Java类加载器的工作原理，以及如何将它扩展到只从文件系统中获取更多内容。 从m29的评论更新当JVM使用Java选项启动时，我们可以将自定义类加载器设置为默认类加载器。例如，我将在提供java类加载器选项后再次运行ClassLoaderTest程序。 123456789101112131415161718Pankaj$ javac -cp .:../lib/mysql-connector-java-5.0.7-bin.jar com/journaldev/classloader/ClassLoaderTest.javaPankaj$ java -cp .:../lib/mysql-connector-java-5.0.7-bin.jar -Djava.system.class.loader=CCLoader com.journaldev.classloader.ClassLoaderTestLoading Class 'com.journaldev.classloader.ClassLoaderTest'Loading Class using CCLoaderLoading Class 'java.lang.Object'Loading Class 'java.lang.String'Loading Class 'java.lang.System'Loading Class 'java.lang.StringBuilder'Loading Class 'java.util.HashMap'Loading Class 'java.lang.Class'Loading Class 'java.io.PrintStream'class loader for HashMap: nullLoading Class 'sun.net.spi.nameservice.dns.DNSNameService'class loader for DNSNameService: sun.misc.Launcher$ExtClassLoader@24480457class loader for this class: CCLoader@38503429Loading Class 'com.mysql.jdbc.Blob'sun.misc.Launcher$AppClassLoader@2f94ca6cPankaj$ 正如你所看到的，CCLoader正在加载ClassLoaderTest类，因为它在com.sanfor 包中。 ClassLoader Java选项的Mac OS X 10.6.4问题如果你在Mac OS上工作，上面的执行可能会抛出一些异常，但是它会成功执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109Pankaj$$ java -cp .:../lib/mysql-connector-java-5.0.7-bin.jar -Djava.system.class.loader=CCLoader com.journaldev.classloader.ClassLoaderTestIntentionally suppressing recursive invocation exception!java.lang.IllegalStateException: recursive invocation at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1391) at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1374) at sun.security.jca.ProviderConfig$1.run(ProviderConfig.java:64) at java.security.AccessController.doPrivileged(Native Method) at sun.security.jca.ProviderConfig.getLock(ProviderConfig.java:62) at sun.security.jca.ProviderConfig.getProvider(ProviderConfig.java:187) at sun.security.jca.ProviderList.getProvider(ProviderList.java:215) at sun.security.jca.ProviderList.getService(ProviderList.java:313) at sun.security.jca.GetInstance.getInstance(GetInstance.java:140) at java.security.cert.CertificateFactory.getInstance(CertificateFactory.java:148) at sun.security.pkcs.PKCS7.parseSignedData(PKCS7.java:244) at sun.security.pkcs.PKCS7.parse(PKCS7.java:141) at sun.security.pkcs.PKCS7.parse(PKCS7.java:110) at sun.security.pkcs.PKCS7.&lt;init&gt;(PKCS7.java:92) at sun.security.util.SignatureFileVerifier.&lt;init&gt;(SignatureFileVerifier.java:80) at java.util.jar.JarVerifier.processEntry(JarVerifier.java:256) at java.util.jar.JarVerifier.update(JarVerifier.java:188) at java.util.jar.JarFile.initializeVerifier(JarFile.java:321) at java.util.jar.JarFile.getInputStream(JarFile.java:386) at sun.misc.JarIndex.getJarIndex(JarIndex.java:99) at sun.misc.URLClassPath$JarLoader$1.run(URLClassPath.java:606) at java.security.AccessController.doPrivileged(Native Method) at sun.misc.URLClassPath$JarLoader.ensureOpen(URLClassPath.java:597) at sun.misc.URLClassPath$JarLoader.&lt;init&gt;(URLClassPath.java:581) at sun.misc.URLClassPath$3.run(URLClassPath.java:331) at java.security.AccessController.doPrivileged(Native Method) at sun.misc.URLClassPath.getLoader(URLClassPath.java:320) at sun.misc.URLClassPath.getLoader(URLClassPath.java:297) at sun.misc.URLClassPath.getResource(URLClassPath.java:167) at java.net.URLClassLoader$1.run(URLClassLoader.java:192) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:188) at sun.misc.Launcher$ExtClassLoader.findClass(Launcher.java:244) at java.lang.ClassLoader.loadClass(ClassLoader.java:319) at java.lang.ClassLoader.loadClass(ClassLoader.java:309) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:330) at java.lang.ClassLoader.loadClass(ClassLoader.java:254) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:399) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:247) at java.lang.SystemClassLoaderAction.run(ClassLoader.java:2147) at java.security.AccessController.doPrivileged(Native Method) at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1404) at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1374)Intentionally suppressing recursive invocation exception!java.lang.IllegalStateException: recursive invocation at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1391) at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1374) at sun.security.jca.ProviderConfig$3.run(ProviderConfig.java:231) at java.security.AccessController.doPrivileged(Native Method) at sun.security.jca.ProviderConfig.doLoadProvider(ProviderConfig.java:225) at sun.security.jca.ProviderConfig.getProvider(ProviderConfig.java:205) at sun.security.jca.ProviderList.getProvider(ProviderList.java:215) at sun.security.jca.ProviderList.getService(ProviderList.java:313) at sun.security.jca.GetInstance.getInstance(GetInstance.java:140) at java.security.cert.CertificateFactory.getInstance(CertificateFactory.java:148) at sun.security.pkcs.PKCS7.parseSignedData(PKCS7.java:244) at sun.security.pkcs.PKCS7.parse(PKCS7.java:141) at sun.security.pkcs.PKCS7.parse(PKCS7.java:110) at sun.security.pkcs.PKCS7.&lt;init&gt;(PKCS7.java:92) at sun.security.util.SignatureFileVerifier.&lt;init&gt;(SignatureFileVerifier.java:80) at java.util.jar.JarVerifier.processEntry(JarVerifier.java:256) at java.util.jar.JarVerifier.update(JarVerifier.java:188) at java.util.jar.JarFile.initializeVerifier(JarFile.java:321) at java.util.jar.JarFile.getInputStream(JarFile.java:386) at sun.misc.JarIndex.getJarIndex(JarIndex.java:99) at sun.misc.URLClassPath$JarLoader$1.run(URLClassPath.java:606) at java.security.AccessController.doPrivileged(Native Method) at sun.misc.URLClassPath$JarLoader.ensureOpen(URLClassPath.java:597) at sun.misc.URLClassPath$JarLoader.&lt;init&gt;(URLClassPath.java:581) at sun.misc.URLClassPath$3.run(URLClassPath.java:331) at java.security.AccessController.doPrivileged(Native Method) at sun.misc.URLClassPath.getLoader(URLClassPath.java:320) at sun.misc.URLClassPath.getLoader(URLClassPath.java:297) at sun.misc.URLClassPath.getResource(URLClassPath.java:167) at java.net.URLClassLoader$1.run(URLClassLoader.java:192) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:188) at sun.misc.Launcher$ExtClassLoader.findClass(Launcher.java:244) at java.lang.ClassLoader.loadClass(ClassLoader.java:319) at java.lang.ClassLoader.loadClass(ClassLoader.java:309) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:330) at java.lang.ClassLoader.loadClass(ClassLoader.java:254) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:399) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:247) at java.lang.SystemClassLoaderAction.run(ClassLoader.java:2147) at java.security.AccessController.doPrivileged(Native Method) at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1404) at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1374)Loading Class 'com.journaldev.classloader.ClassLoaderTest'Loading Class using CCLoaderLoading Class 'java.lang.Object'Loading Class 'java.lang.String'Loading Class 'java.lang.System'Loading Class 'java.lang.StringBuilder'Loading Class 'java.util.HashMap'Loading Class 'java.lang.Class'Loading Class 'java.io.PrintStream'class loader for HashMap: nullLoading Class 'sun.net.spi.nameservice.dns.DNSNameService'class loader for DNSNameService: sun.misc.Launcher$ExtClassLoader@24480457class loader for this class: CCLoader@38503429Loading Class 'com.mysql.jdbc.Blob'sun.misc.Launcher$AppClassLoader@2f94ca6cPankaj$ 这就是Java类加载器和java自定义类加载器的例子。 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,class loader,类加载器","slug":"java-class-loader-类加载器","permalink":"/tags/java-class-loader-类加载器/"}]},{"title":"Java 8中求两日期时间差值的方法","slug":"java-8-period-and-duration","date":"2018-11-26T05:54:44.461Z","updated":"2017-11-23T07:38:13.061Z","comments":true,"path":"2018/11/26/java-8-period-and-duration/","link":"","permalink":"/2018/11/26/java-8-period-and-duration/","excerpt":"Java 7中对日期的差值的计算和本地日期时间不像C#方便，往往需要自己封闭实现一个或引用第三方jar包，至Java 8引进了","text":"Java 7中对日期的差值的计算和本地日期时间不像C#方便，往往需要自己封闭实现一个或引用第三方jar包，至Java 8引进了 以下几个例子向您展示了如何使用Java 8 Duration ， Period 和 ChronoUnit 对象来找出时间之间的差值。 Duration - 以秒和纳秒为单位计算两时间的差值。 Period - 以年，月，日为单位计算两时间的差值。 ChronoUnit - 以指定的单位计算两时间的差值。 1.Duration示例java.time.Duration用于查找两个LocalDateTime之间的秒数差值 DurationExample.java123456789101112131415161718192021222324252627282930313233343536package sanfor.time;import java.time.Duration;import java.time.LocalDateTime;import java.time.Month;import java.time.temporal.ChronoUnit;public class DurationExample &#123; public static void main(String[] args) &#123; // Creating Durations System.out.println(\"--- Examples --- \"); Duration oneHours = Duration.ofHours(1); System.out.println(oneHours.getSeconds() + \" 秒\"); Duration oneHours2 = Duration.of(1, ChronoUnit.HOURS); System.out.println(oneHours2.getSeconds() + \" 秒\"); // Test Duration.between System.out.println(\"\\n--- Duration.between --- \"); LocalDateTime oldDate = LocalDateTime.of(2016, Month.AUGUST, 31, 10, 20, 55); LocalDateTime newDate = LocalDateTime.of(2016, Month.NOVEMBER, 9, 10, 21, 56); System.out.println(oldDate); System.out.println(newDate); //count seconds between dates Duration duration = Duration.between(oldDate, newDate); System.out.println(duration.getSeconds() + \" 秒\"); &#125;&#125; 输出12345678--- Examples ---3600 秒 3600 秒--- Duration.between ---2016-08-31T10:20:552016-11-09T10:21:566048061 秒 2.Period示例java.time.Period用于找出两LocalDate之间年，月或日差值 PeriodExample.java123456789101112131415161718192021222324252627282930313233343536package sanfor.time;import java.time.LocalDate;import java.time.Month;import java.time.Period;public class PeriodExample &#123; public static void main(String[] args) &#123; System.out.println(\"--- Examples --- \"); Period tenDays = Period.ofDays(10); System.out.println(tenDays.getDays()); //10 Period oneYearTwoMonthsThreeDays = Period.of(1, 2, 3); System.out.println(oneYearTwoMonthsThreeDays.getYears()); //1 System.out.println(oneYearTwoMonthsThreeDays.getMonths()); //2 System.out.println(oneYearTwoMonthsThreeDays.getDays()); //3 System.out.println(\"\\n--- Period.between --- \"); LocalDate oldDate = LocalDate.of(1982, Month.AUGUST, 31); LocalDate newDate = LocalDate.of(2016, Month.NOVEMBER, 9); System.out.println(oldDate); System.out.println(newDate); // check period between dates Period period = Period.between(oldDate, newDate); System.out.print(period.getYears() + \" 年,\"); System.out.print(period.getMonths() + \" 月,\"); System.out.print(period.getDays() + \" 日\"); &#125;&#125; 输出12345678910--- Examples ---10123--- Period.between ---1982-08-312016-11-0934 年,2 月,9 日 ChronoUnit示例 或者，您可以使用java.time.temporal.ChronoUnit.{unit}.between查找时间或日期之间的任何单位的差值，请查看以下示例： ChronoUnitExample.java12345678910111213141516171819202122232425262728293031323334353637383940package sanfor.time;import java.time.LocalDateTime;import java.time.Month;import java.time.temporal.ChronoUnit;public class ChronoUnitExample &#123; public static void main(String[] args) &#123; LocalDateTime oldDate = LocalDateTime.of(1982, Month.AUGUST, 31, 10, 20, 55); LocalDateTime newDate = LocalDateTime.of(2016, Month.NOVEMBER, 9, 10, 21, 56); System.out.println(oldDate); System.out.println(newDate); // count between dates long years = ChronoUnit.YEARS.between(oldDate, newDate); long months = ChronoUnit.MONTHS.between(oldDate, newDate); long weeks = ChronoUnit.WEEKS.between(oldDate, newDate); long days = ChronoUnit.DAYS.between(oldDate, newDate); long hours = ChronoUnit.HOURS.between(oldDate, newDate); long minutes = ChronoUnit.MINUTES.between(oldDate, newDate); long seconds = ChronoUnit.SECONDS.between(oldDate, newDate); long milis = ChronoUnit.MILLIS.between(oldDate, newDate); long nano = ChronoUnit.NANOS.between(oldDate, newDate); System.out.println(\"\\n--- 总计 --- \"); System.out.println(years + \" 年\"); System.out.println(months + \" 月\"); System.out.println(weeks + \" 周\"); System.out.println(days + \" 日\"); System.out.println(hours + \" 时\"); System.out.println(minutes + \" 分\"); System.out.println(seconds + \" 秒\"); System.out.println(milis + \" 毫秒\"); System.out.println(nano + \" 纳秒\"); &#125;&#125; 输出123456789101112131982-08-31T10:20:552016-11-09T10:21:56--- 总计 ---34 年410 月1784 周12489 日299736 时17984161 分1079049661 秒1079049661000 毫秒1079049661000000000 纳秒 引用 Oracle教程 - Period和Duration Duration Java文档 Period Java文档 ChronoUnit Java文档","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"date,duration,period,ChronoUnit,java.time,java8","slug":"date-duration-period-ChronoUnit-java-time-java8","permalink":"/tags/date-duration-period-ChronoUnit-java-time-java8/"}]},{"title":"Hibernate面试问题","slug":"hibernate-interview-questions","date":"2018-11-26T05:54:44.441Z","updated":"2018-03-06T09:39:42.565Z","comments":true,"path":"2018/11/26/hibernate-interview-questions/","link":"","permalink":"/2018/11/26/hibernate-interview-questions/","excerpt":"Hibernate是Java应用程序中使用最广泛的ORM工具之一 用于许多的企业应用程序中的数据库操作。因此我决定写一篇关于Hibernate面试问题的文章，以便在面试前刷新你的相关知识。","text":"Hibernate是Java应用程序中使用最广泛的ORM工具之一 用于许多的企业应用程序中的数据库操作。因此我决定写一篇关于Hibernate面试问题的文章，以便在面试前刷新你的相关知识。无论你是新手还是老鸟，具有良好的知识或Hibernate的ORM工具有助于破解面试问题。在这里，我提供了重要的Hibernate面试问题和答案，以帮助您提高自己的知识面，并打动面试官 最近我写了大量关于Hibernate的文章，其中大多数都包含完整的可下载项目 我会在需要时为他们提供参考，您可以通过他们来刷新您的知识。 Hibernate面试问题 什么是Hibernate框架？ 什么是Java Persistence API（JPA）？ 使用Hibernate Framework的主要优势是什么？ Hibernate相比JDBC有什么优势？ Hibernate框架的一些重要接口的名称是什么？ 什么是Hibernate配置文件？ 什么是Hibernate映射文件？ 用于Hibernate映射的一些重要注解的名称是什么？ 什么是Hibernate SessionFactory以及如何配置它？ Hibernate SessionFactory是线程安全的吗？ 什么是Hibernate Session以及如何获取它？ Hibernate会话是线程安全的吗？ openSession和getCurrentSession有什么区别？ Hibernate Session get（）和load（）方法有什么区别？ 什么是Hibernate缓存？ 解释Hibernate的第一级缓存？ 如何使用EHCache配置Hibernate二级缓存？ 实体bean的有些什么不同状态？ Hibernate Session merge（）用来做什么？ Hibernate的save（），saveOrUpdate（）和persist（）方法有什么区别？ 如果我们在Entity bean中没有无参数构造函数会发生什么？ 排序集合（sorted collection）和有序集合（ordered collection）之间有什么区别，哪一个更好？ Hibernate中的有哪些集合类型？ 如何在Hibernate中实现连接？ 为什么我们不应该让实体类final类？ 什么是HQL？它有什么好处？ 什么是Hibernate中的查询缓存？ 我们可以在Hibernate中执行原生的sql查询吗？ 原生SQL查询支持在Hibernate中的好处是什么？ 什么是命名SQL查询？ 命名SQL查询有什么好处？ Hibernate Criteria API有什么好处？ 如何在日志文件中记录Hibernate生成的sql查询？ 什么是Hibernate Proxy以及它如何在延迟加载中提供帮助？ 如何在Hibernate中实现关联？ 事务管理如何在Hibernate中工作？ 什么是级联，什么是不同类型的级联？ 如何将log4j日志集成到Hibernate应用程序中？ 如何在Hibernate框架中使用应用程序服务器JNDI DataSource？ 如何整合Hibernate和Spring框架？ 什么是HibernateTemplate类？ 如何将Hibernate与Servlet或Struts2 Web应用程序集成？ Hibernate框架中使用哪些设计模式？ Hibernate框架遵循的最佳实践是什么？ 什么是Hibernate验证框架？ Hibernate Tools Eclipse插件的好处是什么？ Hibernate面试问题答1. 什么是Hibernate框架？对象关系映射或ORM是将应用程序域模型对象映射到关系数据库表的编程技术 Hibernate是基于Java的ORM工具，它提供了将应用程序域对象映射到关系数据库表的框架，反之亦然。 Hibernate提供了Java Persistence API的引用实现，这使得它成为具有松耦合优势的ORM工具的绝佳选择，我们可以使用Hibernate Persistence API进行CRUD操作，Hibernate框架提供了使用JPA注解以及基于XML的配置将普通的旧java对象映射到传统数据库表的选项。 同样，Hibernate配置也很灵活，可以通过XML配置文件以及编程方式完成，有关Hibernate框架用法的快速概述，您可以学习Hibernate初学者教程 。 2. 什么是Java Persistence API（JPA）？Java Persistence API（JPA）提供了管理应用程序中的关系数据的规范，当前JPA 2.1版于2011年7月开始，名为JSR 338. 2013年5月22日，JPA 2.1被批准为最终版。 JPA规范是在javax.persistence包中，使用注解定义的，使用JPA注解有助于我们编写实现独立（无依赖）的代码。 3. 使用Hibernate Framework的主要优势是什么？使用Hibernate框架的一些主要优势是： Hibernate消除了JDBC附带的所有重复代码并负责管理资源，因此我们可以专注于业务逻辑。 Hibernate框架提供对XML和JPA注解的支持，这使得我们的代码实现独立。 Hibernate提供了一种类似于SQL的强大查询语言（HQL），然而，HQL完全是面向对象的，理解继承，多态和关联等概念。 Hibernate是红帽社区（ Red Hat Community）的一个开源项目，在世界各地都有使用这使得它成为比其他人更好的选择，因为学习曲线很小，并且有大量在线文档和帮助可以在论坛中轻松获得。 Hibernate很容易与其他Java EE框架集成，它非常流行，因此Spring Framework提供了内置的支持，将Hibernate与Spring应用程序集成在一起。 Hibernate支持使用代理对象进行延迟初始化，并仅在需要时执行实际的数据库查询。 Hibernate缓存有助于我们获得更好的性能。 对于数据库供应商特定的功能，Hibernate是合适的，因为我们也可以执行本机sql查询。 总体来说，Hibernate是目前ORM工具市场上的最佳选择，它包含了ORM工具所需的所有功能。 4. Hibernate相比JDBC有什么优势？Hibernate框架相对于JDBC的一些主要优势是： Hibernate移除了JDBC API附带的大量重复代码，代码看起来更清晰可读。 Hibernate支持继承，关联和集合 这些功能在JDBC API中不存在。 Hibernate隐式提供事务管理，事实上大部分查询不能在事务外执行。在JDBC API中，我们需要使用提交和回滚编写事务管理代码，阅读更多关于JDBC事务管理 。 JDBC API在检测到异常时，会抛出SQLException ，所以我们需要编写大量的try-catch块代码 大多数情况下，在业务管理中，每次JDBC调用调用多次都是冗余的，Hibernate包装JDBC异常并抛出JDBCException或HibernateException未检查异常，所以我们不需要编写代码来处理它，Hibernate内置的事务管理消除了try-catch块的使用。 Hibernate查询语言（HQL）更加面向对象，接近于Java编程语言，对于JDBC，我们需要编写原生的SQL查询。 Hibernate支持缓存，性能更好，JDBC查询不会被缓存，因此性能很低。7 Hibernate提供了选项，我们也可以通过它来创建数据库表，因为JDBC表必须存在于数据库中。 Hibernate配置可以帮助我们使用JDBC连接以及连接池的JNDI DataSource，这是企业应用程序中非常重要的特性，但在JDBC API中完全缺失。 Hibernate支持JPA注解，所以代码与实现无关，可以用其他ORM工具轻松替换，JDBC代码与应用程序耦合非常紧密。 5. Hibernate框架的一些重要接口的名称是什么？Hibernate框架的一些重要接口是： SessionFactory（org.Hibernate.SessionFactory）：SessionFactory是单个数据库的编译映射的不可变线程安全的缓存 我们需要初始化SessionFactory，然后我们可以缓存并重用它，SessionFactory实例用于获取数据库操作的Session对象。 Session（org.Hibernate.Session）：Session是一个单线程，暂存的对象，表示应用程序和持久性存储之间的会话，它封装了JDBCjava.sql.Connection并作为org.Hibernate.Transaction的工厂工作 我们应该只在需要时才打开会话，并在我们完成使用后立即关闭会话。Session对象是java应用程序代码和Hibernate框架之间的接口，并提供CRUD操作的方法。 Transaction（org.Hibernate.Transaction）：Transaction是应用程序用来指定原子工作单元的单线程，暂存对象，它从底层的JDBC或JTA(Java Transaction API)事务中抽象出应用程序，在某些情况下，org.Hibernate.Session可能跨越多个org.Hibernate.Transaction。 6. 什么是Hibernate配置文件？Hibernate配置文件包含特定于数据库的配置并用于初始化SessionFactory，我们在Hibernate配置xml文件中提供数据库凭证或JNDI资源信息。Hibernate配置文件的其他一些重要部分是Dialect信息，以便Hibernate知道数据库类型和映射文件或类的详细信息。 7. 什么是Hibernate映射文件？Hibernate映射文件用于定义实体bean字段和数据库表列映射。我们知道JPA注解可用于映射，但有时在使用第三方类时，XML映射文件可能更方便，而不能使用注解。 8. 用于Hibernate映射的一些重要注解的名称是什么？Hibernate支持JPA注解，并且在org.Hibernate.annotations包中有一些其他注解，使用的一些重要的JPA和Hibernate注解是： javax.persistence.Entity ：与模型类一起使用来指定它们是实体bean。 javax.persistence.Table ：与实体bean一起用于在数据库中定义相应的表名。 javax.persistence.Access ：用于定义访问类型，字段或属性。默认值是field，如果你想让Hibernate使用getter/setter方法，那么你需要将它设置为属性。 javax.persistence.Id ：用于在实体bean中定义主键。 javax.persistence.EmbeddedId ：用于在实体bean中定义复合主键。 javax.persistence.Column ：用于在数据库表中定义列名。 javax.persistence.GeneratedValue ：用于定义用于生成主键的策略 与javax.persistence.GenerationType enum一起使用。 javax.persistence.OneToOne ：用于定义两个实体bean之间的一对一映射 我们还有其他类似的注解，如OneToMany，ManyToOne和ManyToMany org.Hibernate.annotations.Cascade ：用于定义两个实体bean之间的级联，与映射一起使用。它与org.Hibernate.annotations.CascadeType一起使用 javax.persistence.PrimaryKeyJoinColumn ：用于为外键定义属性。与org.Hibernate.annotations.GenericGenerator和org.Hibernate.annotations.Parameter 以下是显示这些注解使用情况的两个类。12345678910111213141516171819202122232425262728293031import javax.persistence.Access;import javax.persistence.AccessType;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.OneToOne;import javax.persistence.Table;import org.hibernate.annotations.Cascade;@Entity@Table(name = \"EMPLOYEE\")@Access(value=AccessType.FIELD)public class Employee &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"emp_id\") private long id; @Column(name = \"emp_name\") private String name; @OneToOne(mappedBy = \"employee\") @Cascade(value = org.hibernate.annotations.CascadeType.ALL) private Address address; //getter setter methods&#125; 123456789101112131415161718192021222324252627282930313233import javax.persistence.Access;import javax.persistence.AccessType;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.OneToOne;import javax.persistence.PrimaryKeyJoinColumn;import javax.persistence.Table;import org.hibernate.annotations.GenericGenerator;import org.hibernate.annotations.Parameter;@Entity@Table(name = \"ADDRESS\")@Access(value=AccessType.FIELD)public class Address &#123; @Id @Column(name = \"emp_id\", unique = true, nullable = false) @GeneratedValue(generator = \"gen\") @GenericGenerator(name = \"gen\", strategy = \"foreign\", parameters = &#123; @Parameter(name = \"property\", value = \"employee\") &#125;) private long id; @Column(name = \"address_line1\") private String addressLine1; @OneToOne @PrimaryKeyJoinColumn private Employee employee; //getter setter methods&#125; 9. 什么是Hibernate SessionFactory以及如何配置它？SessionFactory是用于获取Session对象的工厂类。SessionFactory负责读取Hibernate配置参数并连接到数据库并提供Session对象。通常应用程序具有一个SessionFactory实例，并且服务于客户端请求的线程从该工厂获取Session实例。 SessionFactory的内部状态是不可变的。一旦它被创建，这个内部状态就被设置了。这个内部状态包括关于对象/关系映射的所有元数据。 SessionFactory还提供获取Class元数据和Statistics实例以获取查询执行状态，二级缓存详细信息等的方法。 10. Hibernate SessionFactory是线程安全的吗？SessionFactory的内部状态是不可变的，所以它是线程安全的。多个线程可以同时访问它以获取Session实例。 11. 什么是Hibernate Session以及如何获取它？Hibernate Session是java应用层和Hibernate之间的接口。这是用来执行数据库操作的核心接口。会话的生命周期受事务开始和结束的约束。 会话提供方法来执行持久对象的创建，读取，更新和删除操作。我们可以执行HQL查询，SQL本机查询并使用Session对象创建条件。 12. Hibernate会话是线程安全的吗？Hibernate Session对象不是线程安全的，每个线程都应该获得它自己的会话实例，并在工作完成后关闭它。 13. openSession和getCurrentSession有什么区别？Hibernate SessionFactory getCurrentSession（）方法返回绑定到上下文的会话。但为了这个工作，我们需要在Hibernate配置文件中配置它。由于这个会话对象属于Hibernate上下文，所以我们不需要关闭它。一旦会话工厂关闭，此会话对象就会关闭。1&lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; Hibernate SessionFactory openSession（）方法总是打开一个新的会话。一旦我们完成了所有的数据库操作，我们应该关闭这个会话对象。我们应该在多线程环境中为每个请求打开一个新会话。 还有另一种方法openStatelessSession（）返回无状态会话，有关示例的更多详细信息，请阅读Hibernate openSession vs getCurrentSession。 14. Hibernate Session get（）和load（）方法有什么区别？Hibernate会话有不同的方法来从数据库加载数据。get和load是最常用的方法，首先看起来它们很相似，但它们之间有一些差异。 get（）在调用数据后立即加载数据，而load（）返回代理对象并仅在实际需要时才加载数据，所以load（）更好，因为它支持延迟加载。 由于load（）在没有找到数据时抛出异常，所以只有当我们知道数据存在时才应该使用它。（get方法返回null，但load若为null则报异常） 当我们想要确保数据库中存在数据时，我们应该使用get（）。 有关差异的说明，请阅读Hibernate get vs load 。 15. 什么是Hibernate缓存？解释Hibernate的一级缓存？顾名思义，Hibernate缓存查询数据以使我们的应用程序更快。如果使用正确，Hibernate Cache可以在获得快速应用程序性能方面非常有用 缓存背后的想法是减少数据库查询的数量，从而减少应用程序的吞吐时间。 Hibernate一级缓存与Session对象相关联。Hibernate一级缓存默认启用，无法禁用它。然而，Hibernate提供了一些方法，我们可以通过这些方法从缓存中删除选定的对象或完全清除缓存。 在会话中缓存的任何对象对其他会话都不可见，并且在会话关闭时，所有缓存的对象也将丢失。 为了更好的解释，请阅读Hibernate一级缓存 。 16. 如何使用EHCache配置Hibernate二级缓存？EHCache是​​利用Hibernate二级缓存的最佳选择。在Hibernate应用程序中启用EHCache需要执行以下步骤。 在Maven项目中添加Hibernate-ehcache依赖项，如果它不是maven，则添加相应的jar。12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt;&lt;/dependency&gt; 在Hibernate配置文件中添加以下属性。 12345678910 &lt;property name=\"hibernate.cache.region.factory_class\"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt; &lt;!-- For singleton factory --&gt;&lt;!-- &lt;property name=\"hibernate.cache.region.factory_class\"&gt;org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory&lt;/property&gt;--&gt; &lt;!-- enable second level cache and query cache --&gt;&lt;property name=\"hibernate.cache.use_second_level_cache\"&gt;true&lt;/property&gt;&lt;property name=\"hibernate.cache.use_query_cache\"&gt;true&lt;/property&gt;&lt;property name=\"net.sf.ehcache.configurationResourceName\"&gt;/myehcache.xml&lt;/property&gt; 创建EHCache配置文件，示例文件myehcache.xml如下所示。1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"ehcache.xsd\" updateCheck=\"true\" monitoring=\"autodetect\" dynamicConfig=\"true\"&gt; &lt;diskStore path=\"java.io.tmpdir/ehcache\" /&gt; &lt;defaultCache maxEntriesLocalHeap=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskSpoolBufferSizeMB=\"30\" maxEntriesLocalDisk=\"10000000\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\" statistics=\"true\"&gt; &lt;persistence strategy=\"localTempSwap\" /&gt; &lt;/defaultCache&gt; &lt;cache name=\"employee\" maxEntriesLocalHeap=\"10000\" eternal=\"false\" timeToIdleSeconds=\"5\" timeToLiveSeconds=\"10\"&gt; &lt;persistence strategy=\"localTempSwap\" /&gt; &lt;/cache&gt; &lt;cache name=\"org.hibernate.cache.internal.StandardQueryCache\" maxEntriesLocalHeap=\"5\" eternal=\"false\" timeToLiveSeconds=\"120\"&gt; &lt;persistence strategy=\"localTempSwap\" /&gt; &lt;/cache&gt; &lt;cache name=\"org.hibernate.cache.spi.UpdateTimestampsCache\" maxEntriesLocalHeap=\"5000\" eternal=\"true\"&gt; &lt;persistence strategy=\"localTempSwap\" /&gt; &lt;/cache&gt;&lt;/ehcache&gt; 使用@Cache注解和缓存策略注解实体bean 例如，123456789import org.hibernate.annotations.Cache;import org.hibernate.annotations.CacheConcurrencyStrategy;@Entity@Table(name = \"ADDRESS\")@Cache(usage=CacheConcurrencyStrategy.READ_ONLY, region=\"employee\")public class Address &#123;&#125; 就是这样，我们完成了 Hibernate将使用EHCache进行二级缓存，请阅读Hibernate EHCache示例以获得完整的解释示例。 17. 实体bean的有些什么不同状态？实体bean实例可以以下三种状态的其中之一。 瞬时态（Transient） ：当对象永远不会持久或与任何会话无关联时，它处于瞬态状态。通过调用save（），persist（）或saveOrUpdate（），可以使瞬态实例持久化 通过调用delete（）可以使持久性实例成为暂态。 持久态（Persistent） ：当对象与唯一会话关联时，它处于持久状态。由get（）或load（）方法返回的任何实例都是持久的。 游离态（Detached） ：当一个对象先前是持久性的，但没有与任何会话相关联时，它处于游离状态。游离的实例可以通过调用update（），saveOrUpdate（），lock（）或replicate（）来持久化。通过调用merge（），瞬时或游离实例的状态也可以作为新的持久实例持久化。 18. Hibernate Session merge（）用来做什么？Hibernate合并可以用来更新现有的值，但是这种方法从传递的实体对象中创建一个副本并返回它。返回的对象是持久化上下文的一部分，并对任何更改进行跟踪，传递的对象不被跟踪。 示例程序，阅读Hibernate合并 。 19. Hibernate的save（），saveOrUpdate（）和persist（）方法有什么区别？Hibernate保存可用于将实体保存到数据库。save（）的问题是它可以在没有事务的情况下被调用，如果我们有映射实体，那么只有主对象被保存，导致数据不一致。另外保存立即返回生成的ID。 Hibernate persist与事务保存类似。我觉得它比保存更好，因为我们不能在事务边界外使用它，所以所有的对象映射都被保留下来。此外，persist不会立即返回生成的ID，因此数据持久化发生在需要的时候。 根据提供的数据将Hibernate saveOrUpdate结果插入或更新查询。如果数据存在于数据库中，则执行更新查询。我们也可以在没有事务的情况下使用saveOrUpdate（），但如果会话不刷新，您将再次遇到映射对象未保存的问题。例如使用这些方法，请阅读Hibernate save vs persist 。 20. 如果我们在Entity bean中没有无参数构造函数会发生什么？Hibernate使用Reflection API来创建实体bean的实例，通常在调用get（）或load（）方法时 方法Class.newInstance()用于此，它需要无参数构造函数。因此，如果你在实体bean中没有无参数构造函数，Hibernate将无法实例化它，你将得到HibernateException 。 21. 排序集合（sorted collection）和有序集合（ordered collection）之间有什么区别，哪一个更好？当我们使用Collection API排序算法对一个集合进行排序时，它被称为排序集合。对于小型集合来说，它没有多少开销，但对于较大的集合，它可能导致性能下降和OutOfMemory错误。另外，实体bean应该实现Comparable或Comparator接口，以便在Java对象列表排序时进行更多的工作。 如果我们使用Hibernate框架从数据库加载集合数据，我们可以使用它的Criteria API来使用“order by”子句来获得有序列表。下面的代码片段显示了如何获取它。 12List&lt;Employee&gt; empList = session.createCriteria(Employee.class) .addOrder(Order.desc(\"id\")).list(); 有序列表比排序列表要好，因为实际的排序是在数据库级完成的，速度很快并且不会导致内存问题。 22. Hibernate中的有哪些集合类型？Hibernate中有五种集合类型用于一对多关系映射。 Bag Set List Array Map 23. 如何在Hibernate中实现连接？有多种方法可以在Hibernate中实现连接。 使用诸如一对一，一对多等关联。 在HQL查询中使用JOIN。还有另一种形式“联合提取”来同时加载相关数据，没有延迟加载。 我们可以触发原生的sql查询并使用join关键字。 24. 为什么我们不应该让实体类final类？只有在需要的时候，Hibernate才会使用代理类来延迟加载数据。这是通过扩展实体bean来完成的，如果实体bean是final类，那么延迟加载将不可能，因此性能低下。 25. 什么是HQL？它有什么好处？Hibernate Framework带有一个强大的面向对象的查询语言–Hibernate Query Language（HQL）。它与SQL很相似，除了我们使用对象而不是表名，这使得它更接近于面向对象的编程。 除java类和变量名之外，Hibernate查询语言不区分大小写的。因此，SeLeCT与sELEct与SELECT相同，但com.lexiangmiao.model.Employee与com.lexiangmiao.model.EMPLOYEE不同。 HQL查询被缓存，但我们应尽可能避免它，否则我们将不得不照顾关联。 然而，由于面向对象的方法，它是比原生SQL查询更好的选择。 阅读HQL示例 。 26. 什么是Hibernate中的查询缓存？Hibernate为查询结果集实现了一个缓存区域，该查询结果集与Hibernate二级缓存紧密集成。 这是一个可选功能，需要额外的代码步骤。这只对使用相同参数频繁运行的查询很有用。首先我们需要在Hibernate配置文件中配置下面的属性。1&lt;property name=\"hibernate.cache.use_query_cache\"&gt;true&lt;/property&gt; 在代码中，我们需要使用Query的setCacheable（true）方法，快速示例如下所示。123Query query = session.createQuery(\"from Employee\");query.setCacheable(true);query.setCacheRegion(\"ALL_EMP\"); 27. 我们可以在Hibernate中执行原生的sql查询吗？Hibernate提供了通过使用SQLQuery对象来执行原生SQL查询的选项。 然而，对于正常情况来说，它不是推荐的方法，因为我们失去了与Hibernate关联和Hibernate一级缓存相关的好处。阅读Hibernate Native SQL查询示例。 28. 原生SQL查询支持在Hibernate中的好处是什么？当我们想要执行Hibernate API不支持的特定于数据库的查询（如查询提示或Oracle数据库中的CONNECT关键字）时，原生SQL Query便于使用。 29. 什么是命名SQL查询？Hibernate提供了可以在中心位置定义的命名查询（ Named Query），并在代码中的任何地方使用它们。我们可以为HQL和Native SQL创建命名查询。 Hibernate命名查询可以在Hibernate映射文件中定义，也可以通过使用JPA注角@NamedQuery和@NamedNativeQuery来定义。 30. 命名SQL查询有什么好处？ Hibernate命名查询（ Named Query）帮助我们将查询分组在一个中心位置（便于管理），而不是让它们遍布整个代码。 在创建Hibernate会话工厂时检查Hibernate命名查询语法，从而在命名查询出现任何错误的情况下使应用程序快速失败。（便于查错） Hibernate命名查询是全局的，意味着一旦定义它可以在整个应用程序中使用。 然而，命名查询的一个主要缺点是很难调试，因为我们需要找出它的定义位置。 31. Hibernate Criteria API有什么好处？Hibernate提供的Criteria API更加面向对象，用于查询数据库和获取结果。我们不能使用Criteria来运行更新或删除查询或任何DDL语句。它仅用于使用更多面向对象的方法从数据库中获取结果。 Criteria API的一些常见用法是： Criteria API提供了Projection，我们可以使用sum（），min（），max（）等集合函数。 Criteria API可以与ProjectionList一起使用来仅提取选定的列。 Criteria API可以通过连接多个表来用于连接查询，有用的方法是createAlias（），setFetchMode（）和setProjection（） Criteria API可用于获取带有条件的结果，有用的方法是add（），我们可以在其中添加限制条件。 Criteria API提供了可用于排序结果的addOrder（）方法。 在Hibernate标准示例中学习一些快速示例。 32. 如何在日志文件中记录Hibernate生成的sql查询？我们可以在Hibernate配置下面设置属性来记录SQL查询。1&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; 但是，我们应该只在开发或测试环境中使用它，并在生产环境中关闭它。 33. 什么是Hibernate Proxy以及它如何在延迟加载中提供帮助？Hibernate使用代理对象来支持延迟加载。基本上，当你从表中加载数据时，Hibernate不加载所有的映射对象。只要通过getter方法引用子对象或查找对象，如果链接的实体不在会话缓存中，则代理代码将转到数据库并加载链接的对象。它使用javassist来有效地动态生成实体对象的子类实现。 34. 如何在Hibernate中实现关联？我们可以在Hibernate中轻松实现一对一，一对多和多对多的关联。 它可以使用JPA注解以及基于XML的配置来完成 为了更好地理解，你应该阅读以下教程。 Hibernate一对一映射 Hibernate一对多映射 Hibernate多对多映射 35. 事务管理如何在Hibernate中工作？在Hibernate中事务管理非常简单，因为大多数操作在事务之外是不允许的。所以在从SessionFactory获得会话之后，我们可以调用会话beginTransaction()来启动事务。此方法返回事务引用，我们稍后可以使用该引用来提交或回滚事务。 总的来说，Hibernate事务管理比JDBC事务管理要好，因为我们不需要依赖异常来回滚。会话方法引发的任何异常都会自动回滚事务。 36. 什么是级联，什么是不同类型的级联？当我们有实体之间的关系时，我们需要定义不同的操作将如何影响另一个实体。这是通过级联完成的，它有不同的类型。 以下是在主要和次要实体之间应用级联的简单示例。1234567891011 import org.hibernate.annotations.Cascade;@Entity@Table(name = \"EMPLOYEE\")public class Employee &#123;@OneToOne(mappedBy = \"employee\")@Cascade(value = org.hibernate.annotations.CascadeType.ALL)private Address address;&#125; 请注意，Hibernate CascadeType枚举常量与JPA javax.persistence.CascadeType稍有不同，因此我们需要使用Hibernate。CascadeType和Cascade批注进行映射，如上例所示 CascadeType枚举中定义的常用级联类型有： None：没有级联，它不是一种类型，但是当我们没有定义任何级联时，父级没有任何操作会影响孩子。 ALL：级联save, delete, update, evict, lock, replicate, merge, persist。基本上一切。 SAVE_UPDATE：级联保存和更新，仅在Hibernate时可用。 DELETE：仅在Hibernate中对应于Hibernate本机DELETE操作。 DETATCH，MERGE，PERSIST，REFRESH和REMOVE - 此类类似的操作 LOCK：对应于Hibernate本地LOCK动作。 REPLICATE：对应于Hibernate本地REPLICATE操作。 37. 如何将log4j日志集成到Hibernate应用程序中？Hibernate 4使用JBoss日志记录，而不是早期版本中使用的slf4j。对于log4j配置，我们需要遵循以下步骤。 为maven项目添加log4j依赖项，如果不是maven，则添加相应的jar文件。 创建log4j.xml配置文件或log4j.properties文件并将其保存在类路径中。无论您想要什么，您都可以保留文件名，因为我们将在下一步中加载它。 对于独立项目，使用静态块使用DOMConfigurator或PropertyConfigurator配置log4j。对于Web应用程序，您可以使用ServletContextListener来配置它。 就是这样，我们的设置已经准备就绪。在java类中创建org.apache.log4j.Logger实例并开始记录。对于完整的示例代码，您应该参阅Hibernate log4j示例和Servlet log4j示例。 38. 如何在Hibernate框架中使用应用程序服务器JNDI DataSource？对于Web应用程序，最好允许servlet容器管理连接池。这就是我们为DataSource定义JNDI资源的原因，并且我们可以在Web应用程序中使用它 在Hibernate中使用非常简单，我们需要的是删除所有数据库特定的属性，并使用下面的属性来提供JNDI数据源名称。1&lt;property name=\"hibernate.connection.datasource\"&gt;java:comp/env/jdbc/MyLocalDB&lt;/property&gt; 有关完整示例，请参阅Hibernate JNDI数据源示例 。 39. 如何整合Hibernate和Spring框架？Spring是最常用的Java EE框架之一，Hibernate是最流行的ORM框架。这就是Spring Hibernate组合在企业应用程序中被广泛使用的原因。Spring最好的部分就是它提供了Spring ORM模块对Hibernate的开箱即用集成支持。将Spring和Hibernate框架集成在一起需要执行以下步骤。 添加Hibernate-entitymanager，Hibernate-core和spring-orm依赖项。 为数据库操作创建模型类和相应的DAO实现。 请注意，DAO类将使用将由Spring Bean配置注入的SessionFactory。 如果您使用Hibernate 3，则需要在Spring Bean配置文件中配置org.springframework.orm.Hibernate3.LocalSessionFactoryBean或org.springframework.orm.Hibernate3.annotation.AnnotationSessionFactoryBean。对于Hibernate 4，应该配置单个类org.springframework.orm.Hibernate4.LocalSessionFactoryBean 。 请注意，我们不需要使用Hibernate事务管理，我们可以使用@Transactional注解将它留给Spring声明式事务管理。 有关完整的示例，请参阅Spring Hibernate集成和Spring MVC Hibernate集成 。 40. 什么是HibernateTemplate类？当Spring和Hibernate集成开始时，Spring ORM提供了两个辅助类HibernateDaoSupport和HibernateTemplate。使用它们的原因是从Hibernate获取Session并获得Spring事务管理的好处。 但是从Hibernate 3.0.1开始，我们可以使用SessionFactory getCurrentSession（）方法获取当前会话并使用它来获得Spring事务管理的好处。如果你通过上面的例子，你会看到它是多么容易，这就是为什么我们不应该再使用这些类。 HibernateTemplate另一个好处是异常转换，但可以通过在服务类中使用@Repository注解轻松实现，如上面的spring mvc示例所示。这是判断你的知识的一个诡计问题，以及你是否知道最近的事态发展。 41. 如何将Hibernate与Servlet或Struts2 Web应用程序集成？Hibernate与Servlet或Struts2的集成需要使用ServletContextListener完成，在Hibernate Struts2集成示例中可以找到完整的示例。 42. Hibernate框架中使用哪些设计模式？Hibernate框架中使用的一些设计模式是： 领域模型（Domain Model）模式 - 包含行为和数据的领域的对象模型。数据映射器（Data Mapper） - 一层映射器，它可以在对象和数据库之间移动数据，同时保持对象和映射器本身的独立性。代理模式用于延迟加载SessionFactory中的工厂模式 43. Hibernate框架遵循的最佳实践是什么？在Hibernate中遵循的一些最佳实践是： 总是检查主键字段的访问权限，如果它是在数据库层生成的，那么你不应该为此设置setter。 默认情况下，Hibernate直接设置字段值，而不使用setter 所以如果你想让Hibernate使用setter，那么确保正确的访问被定义为@Access(value=AccessType.PROPERTY) 。 如果访问类型是属性，请确保注解与getter方法而不是setter方法一起使用 避免在提交和获取方法上混合使用注解。 仅当使用原生SQL查询是在无法使用HQL完成时（例如使用数据库特定功能），才使用原生SQL查询。 如果您必须对集合进行排序，请使用有序列表，而不要使用Collection API进行排序。 明智地使用命名查询，将其保存在一个地方以便于调试 仅将它们用于常用查询 对于特定于实体的查询，您可以将它们保留在实体bean本身中。 对于Web应用程序，总是尝试使用JNDI DataSource而不是配置来在Hibernate中创建连接。 避免多对多关系，可以使用双向一对多和多对一关系轻松实现。 对于集合，尝试使用Lists, maps and sets。避免使用array，因为你没有得到延迟加载的好处。 不要将异常视为可恢复，回滚事务并关闭会话。如果你不这样做，Hibernate不能保证内存状态准确地表示持久状态。 首选DAO模式来暴露可用于实体bean的不同方法。 倾向于关联的延迟抓取。 44. 什么是Hibernate验证框架？数据验证是任何应用程序的组成部分。您将在表示层使用Javascript找到数据验证，然后在处理它之前在服务器端代码，在持久化之前也要进行数据验证，以确保它遵循正确的格式。 验证是一项横切任务，所以我们应该尽量保持它与业务逻辑的区分。这就是为什么JSR303和JSR349提供通过使用注解来验证bean的规范。Hibernate Validator提供了这两个bean验证规范的参考实现。在Hibernate验证示例中阅读更多内容。 45. Hibernate Tools Eclipse插件的好处是什么？Hibernate Tools插件可以帮助我们轻松编写Hibernate配置和映射文件。主要的好处是内容帮助可以帮助我们使用属性或xml标签。它还会根据Hibernate DTD文件来验证它们，所以我们事先知道任何错误。学习如何安装和使用Hibernate Tools Eclipse插件。 这就是Hibernate面试的问题和答案，我希望它能帮助你作为新人或有经验的人面试。 引用 原文","raw":null,"content":null,"categories":[{"name":"db","slug":"db","permalink":"/categories/db/"}],"tags":[{"name":"Hibernate,ORM","slug":"Hibernate-ORM","permalink":"/tags/Hibernate-ORM/"}]},{"title":"git常用命令","slug":"git-usefully-command","date":"2018-11-26T05:54:44.422Z","updated":"2019-07-05T06:35:59.423Z","comments":true,"path":"2018/11/26/git-usefully-command/","link":"","permalink":"/2018/11/26/git-usefully-command/","excerpt":"收集平时常用的一些maven命令。","text":"收集平时常用的一些maven命令。 打标签并推送到远程12345678910111213# 基于当前节点打taggit tag -a v0.9.0.RELEASE -m '接手之前的版本'# 指琮前节点打taggit tag -a v0.9.0.RELEASE -m '接手之前的版本' 033133b# 显示tag内容git show v0.9.0.RELEASE# 推送tag到远程git push origin v0.9.0.RELEASE 方法1git revert …对所有n个提交做回滚，然后push到远程，保留了修改历史记录。 方法2 git reset –hard HEAD~n 重设到指定分支，若push到远程，可能被阻止，可以使用git push -f 强制更新。 回滚远程提交方法1git revert …对所有n个提交做回滚，然后push到远程，保留了修改历史记录。 方法2 git reset –hard HEAD~n 重设到指定分支，若push到远程，可能被阻止，可以使用git push -f 强制更新。 git clone查定分支和目录$ git clonewill give you the whole repository. After the clone, you can list the tags with $ git tag -l and then checkout a specific tag: $ git checkout tags/&lt;tag_name&gt;Even better, checkout and create a branch (otherwise you will be on a branch named after the revision number of tag): $ git checkout tags/&lt;tag_name&gt; -b &lt;branch_name&gt; 查看远程地址查看全名1git remote -v 短名方式查看 1git remote 创建临时版本1git checkout -b dev20170803 git bash连接linux linux上执行，ssh-keygen 生成公私钥对 12ssh-keygen# 据提示输入文件名称，如id_rsa.trainmall 公钥添加到authorized_keys 1cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 修改配置文件允许使用秘钥登录 1vim /etc/ssh/sshd_config PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keysPasswordAuthentication yes 重启ssh服务 1systemctl restart sshd 复制linux服务器上的私钥到本地机 scp root@192.168.1.168:/root/.ssh/id_rsa ~/.ssh 需要本地配置多个ssh，则要进行config配置 123456789vim config# 增加以下配置# trainmallHost trainmall Hostname 47.96.102.25 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.trainmall User jesshaw@126.com 测试是否成功 1ssh root@trainmall 管理git生成的多个ssh key 生成公私钥对 123cd ~/.ssh/ssh-keygen -t rsa -C \"jeshaw@lexiangmiao.com\"# 根据提示输入文件名称，如id_rsa.lexiangmiao 添加公钥到需要上传的代码网站 1cat id_rsa.lexiangmiao.pub 配置config 123456789101112131415vim config# githubHost mygithub github.com Hostname github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.github User jesshaw@lexiangmiao.com# lexiangmiaoHost code.lexiangmiao.com Hostname code.lexiangmiao.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.lexiangmiao User jesshaw@lexiangmiao.com 添加私钥到本地 1ssh-add ~/.ssh/id_rsa.lexiangmiao 测试是否成功 1234ssh -T git@github.com#调试方式查看是否成功ssh -vT git@code.lexiangmiao.com 配置当前库的用户和邮箱 12345git config user.name \"Firstname Lastname\"git config user.email \"your_email@example.com\"git config --local -l# 查看全局配置git config --global -l 箭头键不能工作经常碰到在bash中执行命名后需要使用上下箭头键来完成选择，但是偏偏在win7中不能使用。(当然换到cmd中是可以的，不使用此方式的原因你懂的) 实际上我们是实现选择的工作，虽然体验上是差了一些，但以下方法是行的 即使用输入”数字+回车”实现选择的功能，如下示例1234567yo generatewhat would you like to do? (Use arrow keys)Run a generatorBootstrapLoopbackexit## 输入2+回车即选择了Bootstrap 设置提交的用户名和邮箱列出所有配置1git config [--local|--global|--system] -l 设置某个配置项的值123git config [--local|--global|--system] section.key valuegit config --local user.name \"lexiangmiao\" 查看某项的当前值123git config namegit config user.name 回滚回滚前两次提交 12git revert HEAD~2git push push之后会增加一条revert “引用上一次提交的备注”的提交记录 获取分支12$ git checkout -b dev.0.1 origin/dev.0.1 $ git checkout dev.0.1 以ssh方式复制项目（不需要输入帐户）1$ git clone git@github.com:jesshaw/node-sample-project.git 日志输出更友好12345$ git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit$ git config --global alias.lg \"log --color --graph --pretty=format:'%C(bold cyan)%h%C(reset) -%C(yellow)%d%C(reset) %s %C(green)(%cr) %C(bold magenta)&lt;%an&gt;%C(reset)' --abbrev-commit\"$ git config --global alias.lgl \"log --color --graph --pretty=format:'%C(bold cyan)%h%C(reset) -%C(yellow)%d%C(reset) %s %C(green)(%ci) %C(bold magenta)&lt;%an&gt;%Creset' --abbrev-commit\"$ git config --global --unset alias.lg$ git config --global --unset alias.lgl 怎样移除远程的提交日志示例数据如下123456$ git lg -5* 728e3ed - (HEAD -&gt; master, origin/master, origin/HEAD) test4 (26 minutes ago) &lt;ximing&gt;* c8f834f - (mywork) test3 (19 hours ago) &lt;ximing&gt;* 3992e9c - test2 (19 hours ago) &lt;ximing&gt;* abbe339 - test1 (19 hours ago) &lt;ximing&gt;* 2936159 - add bookmark (21 hours ago) &lt;ximing&gt; 方法1移除c8f834f之后的提交历史 12$ git reset --hard 3992e9c$ git push origin -f master 方法2 仅移除abbe339的提交，其他保留 1234567$ git rebase -i 2936159error: could not apply 3992e9c... test2When you have resolved this problem, run \"git rebase --continue\".If you prefer to skip this patch, run \"git rebase --skip\" instead.To check out the original branch and stop rebasing, run \"git rebase --abort\".Could not apply 3992e9c9ac3a6e6bb64e0876dace165980990b45... test2 此时应当解决冲突，然后多次执行以下命令直至没有error: could not apply 3992e9c… test2此类错误为止 123$ git status$ git add -A $ git rebase --continue 提交到远程 1$git push origin +master 清除远程上某个文件的所有提交日志1234567$ cd current directory$ git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch 文件名' --prune-empty --tag-name-filter cat -- --all$ git push origin master --force$ rm -rf .git/refs/original/$ git reflog expire --expire=now --all$ git gc --prune=now$ git gc --aggressive --prune=now 提交所有更改的文件1$ git commit -a -m \"提交备注\" 取消远程某次或某几次提交(远程日志保留)123$ git revert --no-commit b49eb8e 1d8b062## 解决冲突后提交$ git commit -a -m \"Revert commits b49eb8e and 1d8b062\" 取消本地文件修改1$ git checkout file1.js file2.js 选择某个（dev1）分支上指定的提交合并到其他（bugfix）分支1234$ git checkout dev1$ git rebase -i bugfix #基于bugfix，列出提交的记录，选择需要的提交执行。有时需要解决冲突$ git checkout bugfix$ git merge dev1","raw":null,"content":null,"categories":[{"name":"git","slug":"git","permalink":"/categories/git/"}],"tags":[{"name":"git,git命令","slug":"git-git命令","permalink":"/tags/git-git命令/"}]},{"title":"导出csv文件注意事项","slug":"export-svc-file","date":"2018-11-26T05:54:44.415Z","updated":"2017-11-01T07:27:33.478Z","comments":true,"path":"2018/11/26/export-svc-file/","link":"","permalink":"/2018/11/26/export-svc-file/","excerpt":"web应用系统开发或多或少的会涉及到导出csv文件，用于excel打开，本文件总结了一些注意事项和解决方法。","text":"web应用系统开发或多或少的会涉及到导出csv文件，用于excel打开，本文件总结了一些注意事项和解决方法。 1. 列与列这间逗号分隔逗号必须为半角逗号的形式 2. 第一行标题列3. 列值放在双引号内避免因列值存在逗号而出现错行 4. 设置ContentType为”application/csv; charset=UTF-8”非英文环境必须设置为UTF-8 5. 设置Header的”Content-Disposition”为”attachment; filename=ctripCancelOrders.csv”6. 不同应用环境中需要考虑写入编码例如在java中需要加入以下特殊输入，才能让excel打开时没有乱码 1outputStream.write(new String(new byte[] &#123; (byte) 0xEF, (byte) 0xBB,(byte) 0xBF &#125;));","raw":null,"content":null,"categories":[{"name":"others","slug":"others","permalink":"/categories/others/"}],"tags":[{"name":"csv,excel","slug":"csv-excel","permalink":"/tags/csv-excel/"}]},{"title":"docker常用命令","slug":"docker-usefully-command","date":"2018-11-26T05:54:44.411Z","updated":"2019-06-28T08:55:08.702Z","comments":true,"path":"2018/11/26/docker-usefully-command/","link":"","permalink":"/2018/11/26/docker-usefully-command/","excerpt":"收集平时常用的一些docker命令。","text":"收集平时常用的一些docker命令。 ###docker build src/main/docker -t trainmall:v3 拉取镜像1docker pull 创建镜像1docker build 列出镜像1docker images 运行容器1docker run 列出容器12docker psdocker ps -a 删除容器1docker rm 删除镜像1docker rmi 删除所有none镜像1docker rmi `docker images | grep \"&lt;none&gt;\" | awk '&#123;print $3&#125;'` 在host和container之间拷贝文件123docker cpdocker cp &lt;containerId&gt;:/file/path/within/container /host/path/targe 保存改动为新的镜像1docker commit 进行docker容器123docker exec -it [container id] bashdocker exec -it [container id] /bin/sh 启动docker的jenkins时给jenkins授权,1000:1000为jenkins用户和用户组1sudo chown -R 1000:1000 /home/docker/jenkins 配置客户端访问私有仓库 vim /etc/docker/daemon.json 增加以下接点 “insecure-registries” : [“47.100.28.49:5000”] sudo systemctl daemon-reload sudo systemctl restart docker 验证 docker login -u jes -p jes1@lexiangmiao.com 47.100.28.49:5000 登录拉取私有库数据，并启动docker login -u jes -p jes1@lexiangmiao.com localhost:5000 docker pull localhost:5000/jesshaw/retail:lastest docker-componse -f retail.yml up -d retail.yml version: ‘2’services: retail-app: image: localhost:5000/jesshaw/retail:latest environment: - _JAVA_OPTIONS=-Xmx512m -Xms256m - SPRING_PROFILES_ACTIVE=prod,swagger - SPRING_DATASOURCE_URL=jdbc:mysql://lxm-mysql:3306/retail?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false - JHIPSTER_SLEEP=10 # gives time for the database to boot before the application ports: - 8090:8080 shell启用 retail start-retail start.sh chmod 777 start.sh #!/bin/sh echo “—————remove images—————————-“docker-compose downecho “—————remove sucess —————————“ echo “—————remove images—————————-“sudo docker rmi -f localhost:5000/jesshaw/retailecho “—————remove sucess —————————“ echo “—————login localhost registry————–”sudo docker login -u jes -p jes1@lexiangmiao.com localhost:5000echo “—————login sucess ————————–” echo “—————pull images—————————-“sudo docker pull localhost:5000/jesshaw/retailecho “—————pull sucess —————————“ echo “—————–start api start———————“docker-compose up -decho “—————–start api end———————“","raw":null,"content":null,"categories":[{"name":"docker","slug":"docker","permalink":"/categories/docker/"}],"tags":[{"name":"docker,docker命令","slug":"docker-docker命令","permalink":"/tags/docker-docker命令/"}]},{"title":"CentOS下安装Docker","slug":"docker-install","date":"2018-11-26T05:54:44.404Z","updated":"2019-06-28T07:29:18.092Z","comments":true,"path":"2018/11/26/docker-install/","link":"","permalink":"/2018/11/26/docker-install/","excerpt":"Docker意为搬运工人。负责将开发出来的代码部署到指定的系统环境当中。相对于原始的手动或虚拟机部署，Docker极大的提高了生产效率。","text":"Docker意为搬运工人。负责将开发出来的代码部署到指定的系统环境当中。相对于原始的手动或虚拟机部署，Docker极大的提高了生产效率。 Docker介绍Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！ 无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，用以提高生产效率，节约有限的生命。 Docker基本概念镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 镜像（Image）Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器（Container）容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。 仓库（Repository）镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 Docker安装注意事项 Docker有两个版本，分别是社区版本：Community Edition (CE)和企业版本：Enterprise Edition (EE)。一般使用CE版。 CE版本仅支持64位系统。 Docker安装方式有很多种，因为线路原因，综合考虑使用从安装包安装的方式。 步骤1 下载stable版本的包 到https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 下载需要装的版本1wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/package.rpm 注意: 如要下载edge包，则需要改变路径。stable版每季度发版一次，提供4个月的支持。edge版每月发版一次，仅当月提供支持。 2 安装Docker CE 1$ sudo yum install /path/to/package.rpm 3 启动 1$ sudo systemctl start docker 4 验证 通过运行hell-world镜像，验证是否安装正确。 1$ sudo docker run hello-world Docker国内镜像配置由于种种原因，下载镜像会很慢，配置国内镜像是明智选择。 1 停止docker 1sudo systemctl stop docker 2 配置镜像 创建或修改daemon.json1sudo touch /etc/docker/daemon.json 在daemon.json中增加以下配置1234&#123;\"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\", \"http://hub-mirror.c.163.com\",\"https://registry.docker-cn.com\"],\"max-concurrent-downloads\": 10&#125; 3 启动docker 1sudo systemctl start docker 引用 在centos中，从安装包安装Docker Docker最佳实践","raw":null,"content":null,"categories":[{"name":"docker","slug":"docker","permalink":"/categories/docker/"}],"tags":[{"name":"CentOS, docker, install,安装","slug":"CentOS-docker-install-安装","permalink":"/tags/CentOS-docker-install-安装/"}]},{"title":"java核心技术面试问题","slug":"core-java-interview-questions","date":"2018-11-26T05:54:44.390Z","updated":"2017-09-26T05:00:53.649Z","comments":true,"path":"2018/11/26/core-java-interview-questions/","link":"","permalink":"/2018/11/26/core-java-interview-questions/","excerpt":"是否是一位新手或者具有丰富经验专业的程序员，java核心技术在任何java/JEE面试中都扮演重要的角色。","text":"是否是一位新手或者具有丰富经验专业的程序员，java核心技术在任何java/JEE面试中都扮演重要的角色。 java核心技术面试问题列表在许多面试中，java核心技术是喜欢考察的知识点，并且在决定你的面试结果中扮演关键的角色。这篇文章关于java核心技术的问题，它直接来自于我10多年java编程和许多面试经历。 我已经写过许多java面试问题的具体文章，如字符串String，集合Collections和多线程Multithreading等主题。 这里我先给出一些重要的java核心技术面试问题，让你重新加快下你所知道的知识点。 java 8发布了什么重要特性？ 你对java的平台独立性的理解是什么？ JVM是什么？JVM是平台独立的吗？ JDK和JVM的区别是什么？ JVM和JRE的区别是什么？ 所有类的的超类是哪个类？ 为什么java不支持多继承？ 为什么java不是纯面向对象的语言？ path和classpath变量的区别是什么？ java中main方法的重要性是什么？ java中的重载overloading和覆载overriding是什么？ 能重载main方法吗？ 在一个java源文件中能有多个公共类吗？ java包是什么？那个包默认被引入？ java的访问修饰符有哪些？ final关键字有什么作用？ static关键字有什么作用？ java中的finally和finalize有什么作用？ 能声明一个类为静态static类吗？ 静态static引入是什么？ java带资源的try语句是什么，有什么作用？ java的多catch语句块是什么，有什么作用？ 静态static语句块是什么，有什么作用？ 接口是什么，有什么作用? 抽象类是什么，有什么作用？ 抽象类和接口有什么区别？ 接口能否实现或扩展另一个接口？ 标记接口Marker interface是什么，有什么作用？ 包装类是什么？ java中的枚举是什么？ java注解是什么？ java反射API是什么？为什么它非常重要？ java中的组合是什么？ 组合相对与继承有什么好处？ java中怎样对自定义对象集合进行排序？ java中的内部类是什么? 匿名内部类是什么？ java类加载器Classloader是什么？ 类加载器的不同类型是什么？ java中的三元操作符是什么？ super关键字做什么用的？ break和continue语句是什么，怎么用？ this关键字是什么，怎么用？ 默认构造器是什么？ try可以不带catch语句块吗？ 垃圾收集器Garbage Collection是什么？ 序列化Serialization和反序列化Deserialization是什么？ 通过命令提示行怎样运行JAR文件 System类的用途是什么？ instanceof关键字用途是什么？ switch case语句中能使用String类型吗？ java是通过值传递还是通过引用传递？ 堆Heap和栈Stack内存有什么区别？ java编译器是存储在JDK，JRE或JVM哪一个中？ 如下程序将输出什么？ java核心技术面试问题及答案1. java 8发布了什么重要特性？java 8于2014年3月发布，因此是java面试中的热点问题。如果你清楚的回答这个问题，将展示出你对新技术的关注度。 在java 5引入注解和泛型后，java 8是最大（变化）的发布版之一。 java 8有如下重要新特性： 接口可以带默认和静态方法。 函数式接口和Lambda表达式。 为集合引入的java Stream API。 java 新的日期时间API。 强烈推荐打开链接了作深入理解，也可以看一下java 8的新特性。 2. 你对java的平台独立性Platform independence的理解是什么？平台独立性意思是在任何操作系统中运行同样的java程序。例如你可以在Windows上写java程序运行在Mac OS上。 3. JVM是什么？JVM是平台独立的吗？JVM是java虚拟机（Java Virtual Machine）的缩写，它是java语言的核心。JVM的责任就是转换字节码到可读的机器码。JVM不是平台独立的，也是为什么我们在不同的操作系统需要不同的JVM的原因。我们用java可选项可以自定义分配内存最小和最大值。java虚拟机之所以被叫做虚拟，是因为他提了一个不依赖于底层操作系统的接口。 阅读更多知识，请访问 JVM、JRE和JDK 一文。 4. JDK和JVM的区别是什么？JDK是java开发工具包（java Development Kit）的缩写，它是用于开发目的工具集合。JVM是执行java程序的部分。 JDK除了包含了一批用于Java开发的组件，还包含JRE,java运行时环境，也包括了用于产品环境的各种库类，如基础类库rt.jar，以及给开发人员使用的补充库，如国际化与本地化的类库、IDL库等等。JDK中还包括各种样例程序，用以展示Java API中的各部分。 JVM是java平台的可执行的部分。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。由于JVM并不是专为Java所实现的运行时，实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。 5. JVM和JRE的区别是什么？JRE是java运行时环境的缩写（Java Runtime Environment），它是JVM的一种实现。JRE由JVM,java二节文件和其他成功执行任何程序的其他类组成。JRE不包含任何像编译器、调试器等那样的开发工具。如果你想执行任何java程序，你应当安装JRE。 6. 所有类的的超类是哪个类？java.lang.Object是所有类的根类，不需要扩展它。 7. 为什么java不支持多继承？因是“钻石问题（菱形继承问题）” 导致java类不支持多继承。想了解更多“钻石问题”，请阅读java中的多继承。 然后多继承在接口中是支持的。一个接口可以扩展多个接口，因为仅仅是声明方法，实现类中将实现它接口的方法。因此在接口中就没有“钻石问题（菱形继承问题）”了。 8. 为什么java不是纯面向对象的语言？说java不是纯面向对象语言，是因为它支持如int、byte、short、long等原始类型。我相信在写代码时它带来了简捷性。很显然地java有原始类型对应的包装类型表示，从所周知，包装类型除了添加了一些方法，它们没有带来任何好处。 9. path和classpath变量的区别是什么？PATH是一个用在操作系统中定位可执行文件的环境变量（不仅java可执行文件，还有其他如C#,C++等可执行文件）。这就是为什么在安装java时或想任何可执行文件被找到时，我们需要配置目录路径到Path变量的原因。 Classpath是为java指定的用于java可执行文件定位class字节文件的路径变量。在运行java应用程序时将查找这个classpath路径，它可以是目录、ZIP文件、JAR文件等。 10. java中main方法的重要性是什么？main()方法是任何独立的java应用程序的入口点。main的语法是：public static void main(String args[]). main方法是公用且静态的，输入参数是数组，可以转入运行时参数给它。 11. java中的重载overloading和覆载overriding是什么？有超过一个方法存在相同名称、不同参时，我们称它为重载。 覆载指的是父子类之间存在相同签名的方法。在子类中可以使用@Override注解覆盖父类的方法。 12. 能重载main方法吗？可以，在类中可以有多个main名字的方法。然而运行时的入口仅查找这个方法public static void main(String args[]). 13. 在一个java源文件中能有多个公共类吗？在单个java源文件中，不能超过一个公共类。但单个源文件中可以有多个非公共的类。 14. java包是什么？那个包默认被引入？java包是组织java类文件的一种机制。这个组织逻辑可以基于功能或模块。一个类的完整类名应包含包及类名，例如，java.lang.Object是Object类的完整类名，它是java.lang包的一部分。 java.lang包是被默认引入的，任何类中它不需要明确引入。 15. java的访问修饰符有哪些？java提供公有public, 私有private和保护protected访问修饰符。若未使用任何修饰符，则被叫做默认default访问修饰符。 java类仅有公有和默认访问修饰符。阅读更多关于java访问修饰符的知识。 16. final关键字有什么作用？final关键用于确保其他类不能扩展它。如String类就带有final，我们就不能扩展它。 方法前也可以使用final关键字用来确保子类不能覆盖它。 final关键字用在变量前确保只能分配一次值。然而变量的状态是可以改变的，例如可以分配到final变量一次，但是变量的值，在分配之后是可以改变的。 java接口的变量默认就是final且静态static的。 17. static关键字有什么作用？static关键字用在类级别全局的变量，如所有对象将共享同一个变量。 static关键字也可以用在方法前。静态方法仅能访问类的静态变量和调用静态方法。 static关键字用作静态块。静态块是通过java类加载器一次性加载到内存的。常用来初始化静态变量，大多用来创建静态资源。 static关键字用作静态嵌套类。此时能访问变部静态类的静态方法或静态变量。 static关键字用作静态引入。如import static java.lang.Math.PI;，这样就可以直接在当前类中使用PI参数了。 18. java中的finally和finalize有什么作用？finally块用作在try-catch块之后你总想执行的东西。甚至在抛出异常时也会执行。它大多用来释放在try块中创建的资源。 finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但java中的finalize的调用具有不确定性。 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于： a.清理本地对象(通过JNI创建的对象)； b.作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。 19. 能声明一个类为静态static类吗？不能声明一个类为顶级静态类，但可以声明为嵌套静态类。 20. 静态static引入是什么？我们访问静态变量或方法一般是通过类访问的。但也可以通过静态引入的方式import static java.lang.Math.PI;使用它。 使用静态引入带来困惑，最好避免使用它，同时使用它还会使代码的可维护性和可读性变差。 21. java带资源的try语句是什么，有什么作用？java 7的新特性,带资源的try语句，用于自动释放资源，相当于try-catch语句块执行了finnaly块。 22. java的多个catch语句块是什么，有什么作用？如果一个try块中有多个异常要被捕获，catch块中的代码会变丑陋的同时还要用多余的代码来记录异常。有鉴于此，java 7的一个新特征是：一个catch子句中可以捕获多个异常。使用管道符(|),如’catch(IOException | SQLException | Exception ex)’捕获异常。 23. 静态static语句块是什么，有什么作用？静态块是一组语句块，通过java类加载器一次性加载到内存的。常用来初始化静态变量，大多用来创建静态资源。 24. 接口是什么，有什么作用?接口是java语言的核心部分，不但用在许多JDK中而且也用在许多框架、工具和java设计模式中。在java中，接口提供了一用实现方式的抽象，用来定义子类需要实现的契约。 在代码中，接口有利于定义类型起始点和创建顶层结构。自从java接口能实现多个接口后，在许多场景下，使用接口更优于超类。 25. 抽象类是什么，有什么作用？抽象类为子类创建一些默认方法的实现。抽象类可以有未实现的抽象方法。 abstract关键字用来创建抽象类。抽象类不能被实例化，大多是用于子类的扩展。 26. 抽象类和接口有什么区别？ abstract用于创建抽象类，而interface用来创建接口。 子类用extends扩展抽象类，而接口使用implements实现接口。 抽象类可以有实现方法，但接口没有。 抽象类有构造器，但接口没有。 抽象类的方法有public, private, protected, static修饰符，但接口的方法是隐式的public和abstract，不需要使用任何的修饰符。 一个类只能扩展最多一个抽象类，但接口可以扩展一个或多个接口。 抽象类可以扩展其他类和实现其他接口，但接口只能扩展其他接口。 抽象类有main入口方法，是可以运行的，但时接口不能。 接口常用来定义契约，但抽象定义契约的同时还可以有方法实现。 27. 接口能否实现或扩展另一个接口？接口不能实现另一个接口，但可以扩展它。因为接口没有实现就没有“钻石问题”。 28. 标记接口Marker interface是什么，有什么作用？标记接口是一个没有任何方法实现的空接口，用于标记实现类有某些功能。从所周知的Serializable和Cloneable就是标记接口。 29. 包装类是什么？java包装类是8个原始类型对应的对象表示形式。所有的包装类都是不能被继承final和一成不变immutable的。 30. java中的枚举是什么？枚举作为一个新类型，在java 1.5版本引入。它的域由一些固定的常量构成。如，在java中可以使用EAST, WEST, NORTH, SOUTH创建Direction方向的枚举。 与类相似，我们使用enum关键字用于创建一个枚举类型。枚举常量是隐式的静态不能继承的。 31. java注解是什么？java注解提供关于代码的描述信息。它不直接影响代码。注解在java5中被引入。注解是关于嵌套在程序自己中的元数据。可以用过注解解析工具或编译器解析。我们常指定注释在编译时或者在运行时可用。java盎的注解有@Override, @Deprecated and @SuppressWarnings。 32. java反射API是什么？为什么有它非常重要？java反射API提供查看和修改java应用程序的运行时行为的能力。我们可以查看java类，接口，枚举和它们的方法和域的详情。反射API是一个高级主题，一般的应用中应当避免它。反射API用于反设计模式的场景，如单例模式中调用私有构造器，建返访问修饰调用。 即然一般的应用中应当避免使用反射API，但有它的话还是非常重要。因为我们不能没有如Spring，Hibernate或者Tomcat服务，JBoss之类的框架。它们通过反射API调用适当的方法和实体，使用它做了许多处理。 33. java中的组合（Composition）是什么？组合是在类中实现有has-a关系的一种设计技术。使用对象组合是为了代码重用。 java组合通过引用其他对象的实例变量实现的。使用组合的好处是，我们能够控制其他对象的可见性，在我们需要的时候重用。 34. 组合相对与继承有什么好处？java编程的最佳实践之一是“组合（Composition）优于继承（Inheritance）”。有以下原因： 尽管我们可以不使用超类的方法，但在超类中的任何改变也可能影响到子类。例如，假如我们在子类中有一个方法test()，突然某人在父类引入一个方法test()，那么我们在子类中出现编译错误。组合从没有这种问题，是因为我们仅在需要方法时才使用。 若我们在设计超类时没有掌控，继承会暴露了所有超类的方法和变量到客户端，这样也能导致安全漏洞。组合允许我们对方法提供限制的访问，因此更加安全。 在组合中我们可以运行时绑定，继承绑定是在编译时。因此组合的方法调用更加灵活。 你可以在java组合vs继承一文中，阅读更多关于组合优于继承的知识。 35. java中怎样对自定义对象集合进行排序？自定义对象集合支持排序需要实现比较Comparable接口。比较接口有compareTo(T obj)方法，它被用于排序的实现，我们可以提供默认的排序方法。 然后，如果想基于不同条件，如员工集合中基于薪资或年龄的排序。我们可以创建多个匿名类的比较器实例实现。 36. java中的内部类是什么?我们把定义在类的内部的类称为嵌套类。任何非静态的嵌套类被称之为内部类。内部类与类的对象实例相关。它能访问所有变量和外部类的方法。即然内部类是与实例相关，那么它就没有任何静态变量。 在类的内部，可以有本地内部类和匿名内部类。详情请阅读java内部类。 37. 匿名内部类是什么？一个本地不带名字的类被叫做匿名内部类。在单个语句中匿名类定义后并立即实例化。匿名内部类总是扩展自一个类或者实现一个接口。 既然匿名类没有名字，那么它也没有定义构造器。匿名内部类仅在定义的地方可以访问。 38. java类加载器Classloader是什么？java类加载器是在我们想访问任何类时，加载字节码程序到内存的一种程序。我们也可以扩散ClassLoader类和覆载loadClass(String name)方法定义自己的类加载器。了解更多关于java类加器。 39. 类加载器的不同类型是什么？在java中提供以下三个内建的类加载器： 引导类加载器（Bootstrap Class Loader）：它用来加载JDK内存类，典型的加载rt.jar和其他核心类。它是用原生代码来实现的，并不继承自 java.lang.ClassLoader。 扩展类加载器（Extensions Class Loader）：它用来加载 JDK 的扩展库。常常加载$jAVA_HOME/lib/ext目录库。 系统类加载器（System Class Loader）：它根据 java 应用的类路径（CLASSPATH）来加载 java 类。一般来说，java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 40. java中的三元操作符是什么？java三元操作符仅是一个带三个表达式的条件操作符。可以使用if-then-else语句替换。例如a==b?a:b。 41. super关键字做什么用的？super用作子类中访问父类构造器或父类方法。访问类构造器是须放在第一条语句且只能在构造器中访问。 42. break和continue语句是什么，怎么用？放在循环语句中用来结束循环，break结束整个循环，continue结束本次循环。 43. this关键字是什么，怎么用？用于访问当前对象的引用。大多被用于确保是当前对象的变量（相对于入参变量来说），也可以用来调用当前对象的其他构造器。 44. 默认构造器是什么？类的无参构造器被称为默认构造器。在我们没有定义任何类构造器时，java编译器会自动创建类的默认无参构造器。如果定义了有其他构造器，则编译器不会为我们创建默认构造器。 45. try可以不带catch语句块吗？可以。可以有try-finally语句块，于是就避免带catch语句块了。 46. 垃圾收集器Garbage Collection是什么？垃圾收集器查看堆内存的处理器，识别哪个对象在使用中和哪个不在使用中，然后删除不使用的对象。销毁内存是通过垃圾收集器自动进行处理的。 我们可以使用代码Runtime.getRuntime().gc()或者使用工具方法System.gc()运行垃圾收集器。更多堆内存和垃圾收集器详细分析，请阅读“垃圾收集器”。 47. 序列化Serialization和反序列化Deserialization是什么？我们把java对象转换成二进制流的过程被称做为序列化。一旦一个对象被转换成二进制流，它就可以侦破到文件或通过网络发送或在套接字连接中使用。 对象应当实现序列化Serializable接口，这样我们就可以使用java.io.ObjectOutputStream写入对象到文件或者任何输出流OutputStream对象了。阅读更多java序列化知识。 把二进制流数据转换成对象的过程被称做为反序列化。阅读更多java反序列化知识。 48. 通过命令提示行怎样运行JAR文件？能使用命令行运行jar包文件，但需要在jar清单文件中有Main入口类。含Main的类是jar包的入口点，用来通过java命令执行。 49. System类的用途是什么？java System类是核心类之一，System.out.print()是其中一个方法。在调试时，它是最简单的记录日志信息的方法。 System类被声明为final的。因此无法被子类继承和覆盖其行为。也不提供任何公共构造器，因此也不能实例这个类。也是为什么它的所有方法是静态static的原因。 System类提供了数组拷贝、获取当前时间、读环境变化等助手类方法。阅读更多java System类知识。 50. instanceof关键字的用途是什么？instanceof关键字用来检测是否属于某个类。我们应当尽可能的避免使用它。 51. switch case语句中能使用字符串类型吗？java 7引入的新特性之一，switch case语句中可以使用字符串类型。因此java 7或更高版本可以使用。 52. java是通过值传递还是通过引用传递？这个问题非常具有迷惑性。我们知道对象变量在堆空间中包含引用的对象。在我们调用任何方法时，这个变量的拷贝被转递并存储在方法的栈内存中。我们能够检测到任何语言它是通过引用或通过值传递通过一个简单的交换方法，请阅读更多。由此我们得出java是通过值传递而不是通过引用传递的。 53. 堆Heap和栈Stack内存有什么区别？堆和栈主要的区别如下： 所有应用的部分都使用堆内存，然而只有执行线程使用栈内存。 每当对象被创建时，它总是存在堆空间中，栈内存包含它的引用。栈内存仅包括本地的原始变量，在堆空间中的对象的引用变量。*栈内存是通后进先出LIFO的方法管理的，然而在堆内存中因为它是全局使用，所以它的管理方式更加复杂。 在同一程序中更加详细的解释，请阅读java堆vs栈内存 54. java编译器是存储在JDK，JRE或JVM哪一个中？java编译器的任务是转换java程序到字节码，我们使用javac命令执行即可实现。因此它必须要存在JDK中。 55. 如下程序将输出什么？ 在类中的静态方法 12345678910111213package tests;public class Test &#123; public static String toString()&#123; System.out.println(\"Test toString called\"); return \"\"; &#125; public static void main(String args[])&#123; System.out.println(toString()); &#125;&#125; 答：以上代码不能编译。因为所有类对继承根对象类Object。以上会编译错误提示静态方法不能覆盖实例方法。 静态方法调用 1234567891011121314package tests;public class Test &#123; public static String foo()&#123; System.out.println(\"Test foo called\"); return \"\"; &#125; public static void main(String args[])&#123; Test obj = null; System.out.println(obj.foo()); &#125;&#125; 答：这是个奇怪的使用场景。NULL空对象调用方法是总会报NullPointerException异常，且该方法是属于类的静态方法，但该程序能工作并打印”Test foo called”。 原因是编译器做了编译优化。在java编译转换成字节码时，它指向的foo()是静态方法，而不是对象方法，因此编译从obj.foo()调整到Test.foo()，于是也没有了NullPointerException异常。 原文","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"/categories/java/"}],"tags":[{"name":"java,core,interview,核心技术,编程,面试","slug":"java-core-interview-核心技术-编程-面试","permalink":"/tags/java-core-interview-核心技术-编程-面试/"}]},{"title":"如何在CentOS上搭建迷你版的java应用","slug":"build-mini-java-app-env-on-centos","date":"2018-11-26T05:54:44.369Z","updated":"2018-02-09T15:10:44.470Z","comments":true,"path":"2018/11/26/build-mini-java-app-env-on-centos/","link":"","permalink":"/2018/11/26/build-mini-java-app-env-on-centos/","excerpt":"开发好一个基本spring-boot和nodejs应用后，如何使用最少的工具在纯净版的CentOS上搭建运行环境。本文提供了一个可行的方案。","text":"开发好一个基本spring-boot和nodejs应用后，如何使用最少的工具在纯净版的CentOS上搭建运行环境。本文提供了一个可行的方案。 运行环境需求 后端运行环境 JRE 数据库 mysql 实施过程安装Java 8 JRE1 选择Oracle的JDK主要是为了保证开发和生产一致性。当然视情况也可以选择OpenJRE。 123456cd ~wget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"http://download.oracle.com/otn-pub/java/jdk/8u162-b12/0da788060d494f5095bf8624735fa2f1/jre-8u162-linux-i586.rpm\"sudo yum localinstall jre-8u162-linux-i586.rpmrm ~/jre-8u162-linux-i586.rpm 2 接下来设置环境变量 123456--针对当前用户export JAVA_HOME=/usr/java/jdk1.8.0_60/jre--针对所有用户sudo sh -c \"echo export JAVA_HOME=/usr/java/jdk1.8.0_60/jre &gt;&gt; /etc/environment\"--显示设置的环境变量echo $JAVA_HOME 3 卸载安装包 1234--列出所安装的jreyum list | grep jre--执行卸载yum remove jre1.8 ref 安装mysql下载并添加仓库，然后更新 123wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmsudo rpm -ivh mysql-community-release-el7-5.noarch.rpmyum update 安装mysql并启动服务 12sudo yum install mysql-serversudo systemctl start mysqld ref 延伸阅读以下为实现自动化，可能需要安装的工具。 安装git以管理员方式，使用yum安装 1sudo yum install git-all ref 安装nodejs方法一 安装多版本nodejs1 获取脚本并执行1curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash 2 刷新资源1source ~/.bash_profile 3 查看远程版本后选择安装1234nvm --查看帮助nvm ls-remotenvm install v8.9.4nvm use v8.9.4 4 验证安装 12node -vnpm version ref 方法二 通过下载二进制安装nodejs1 下载 123456789wget https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x86.tar.xz``` 2 解压到指定目录 ``` bash sudo mkdir /usr/lib/nodejs sudo tar -xJvf node-v8.9.4-linux-x64.tar.xz -C /usr/lib/nodejs sudo mv /usr/lib/nodejs/node-v8.9.4-linux-x64 /usr/lib/nodejs/node-v8.9.4 3 设置环境变量 ~/.profile 123# Nodejsexport NODEJS_HOME=/usr/lib/nodejs/node-v8.9.4export PATH=$NODEJS_HOME/bin:$PATH 4 刷新profile 1. ~/.profile 5 验证安装 12node -vnpm version ref","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"/categories/linux/"}],"tags":[{"name":"linux,CentOS,java,jvm","slug":"linux-CentOS-java-jvm","permalink":"/tags/linux-CentOS-java-jvm/"}]},{"title":"客户端异步wcf调用","slug":"async-wcf-calls","date":"2018-11-26T05:54:44.356Z","updated":"2017-09-20T06:54:53.515Z","comments":true,"path":"2018/11/26/async-wcf-calls/","link":"","permalink":"/2018/11/26/async-wcf-calls/","excerpt":"一个无需svcUtil产生异步代码的、客户端异步调用同步wcf服务端的实现方法","text":"一个无需svcUtil产生异步代码的、客户端异步调用同步wcf服务端的实现方法 问题要想异步实现调用wcf，有两种方式。方式一：服务端增加异步契约，在客户端是使用专用的异步调用；方式二：是在客户端生成异步调用代码。 方式一增加了契约接口，前后端都增加了维护成本。方式二契约接口统一，代码维护量减少，但是微软的做法是svcUtil生成异步代码（同步代码可以使用ChannelFactory实现，也不需要生成代码）。这样一来，其缺点是一旦契约变动，就需要重新生生成，可维护性不是太友好。 所以若能不生成异步代码，实现异步功能，即解决了我们的问题。 解决方案使用Windsor container and WCF Facility执行异步wcf调用已有同步契约接口即可，示例如下。 目录结构 12345678910111213141516|--Async.Wcf.Calls |--Client |--app.config |--CategoryServiceClient.cs |--Program.cs |--Contracts |--DataContracts |--Category.cs |--ServiceContracts |--ICategoryService.cs |--Services |--CategoryServices |--CategoryService.cs |--ServiceHosts |--CategoryServiceHost.svc |--App.config 契约项目客户端和服务端公用 12345678910111213141516171819202122232425[ServiceContract(Name = \"CategoryService\", Namespace = \"http://northwind.com/categoryservice\")]public interface ICategoryService&#123; [OperationContract] string GetCategoryName(int categoryId); [OperationContract] Category GetCategoryDetails(int categoryId);&#125;[DataContract]public class Category&#123; [DataMember] public int CategoryId &#123; get; set; &#125; [DataMember] public string CategoryName &#123; get; set; &#125; [DataMember] public string CategoryDescription &#123; get; set; &#125; [DataMember] public string CategoryUrl &#123; get; set; &#125;&#125; 注意这是同步版本的服务端契约。 服务端实现如下。 12345678910111213141516171819202122[ServiceBehavior(Name = \"CategoryService\", Namespace = \"http://northwind.com/categoryservice\")]public class CategoryService : ICategoryService&#123; public string GetCategoryName(int categoryId) &#123; Thread.Sleep(5000); return \"Beverages\"; &#125; public Category GetCategoryDetails(int categoryId) &#123; var category = new Category &#123; CategoryId = 1, CategoryName = \"Beverages\", CategoryDescription = \"Soft drinks, coffees, teas, beers, and ales\", CategoryUrl = \"http://northwind.com/Beverages\" &#125;; return category; &#125;&#125; 我们使用svc实现自启动服务,服务端的app.config配置如下。 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\"?&gt;&lt;configuration&gt; &lt;system.web&gt; &lt;compilation debug=\"true\"/&gt; &lt;/system.web&gt; &lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=\"Services.CategoryServices.CategoryService\"&gt; &lt;host&gt; &lt;baseAddresses&gt; &lt;add baseAddress=\"http://localhost:7741/NorthwindServices/CategoryServices/CategoryService\"/&gt; &lt;/baseAddresses&gt; &lt;/host&gt; &lt;endpoint address=\"\" binding=\"wsHttpBinding\" contract=\"Contracts.ServiceContracts.ICategoryService\" bindingNamespace=\"http://northwind.com/categoryservice\"&gt; &lt;/endpoint&gt; &lt;endpoint address=\"mex\" binding=\"mexHttpBinding\" contract=\"IMetadataExchange\"/&gt; &lt;/service&gt; &lt;/services&gt; &lt;behaviors&gt; &lt;serviceBehaviors&gt; &lt;behavior&gt; &lt;serviceMetadata httpGetEnabled=\"True\"/&gt; &lt;serviceDebug includeExceptionDetailInFaults=\"False\"/&gt; &lt;/behavior&gt; &lt;/serviceBehaviors&gt; &lt;/behaviors&gt; &lt;/system.serviceModel&gt;&lt;startup&gt;&lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.0\"/&gt;&lt;/startup&gt;&lt;/configuration&gt; 客户端实现更加简单，app.config无需配置，其他代码实现如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public static class CategoryServiceClient &#123; // Windsor 异步版 public static Task&lt;string&gt; GetCategoryNameAsync(int categoryId) &#123; WindsorContainer container = ConfigureContainer(); var service = container.Resolve&lt;ICategoryService&gt;(\"categegory\"); Task&lt;string&gt; taskResult = Task.Factory.FromAsync&lt;string&gt;(service.BeginWcfCall(p =&gt; p.GetCategoryName(categoryId)), service.EndWcfCall&lt;string&gt;); return taskResult; &#125; // Windsor 同步版 public static string GetCategoryName(int categoryId) &#123; WindsorContainer container = ConfigureContainer(); var instance = container.Resolve&lt;ICategoryService&gt;(\"categegory\"); string categoryName = instance.GetCategoryName(categoryId); return categoryName; &#125; //ChannelFactory 同步版 public static Category GetCategoryDetails(int categoryID) &#123; var category = new Category(); var myBinding = new WSHttpBinding(); var myEndpoint = new EndpointAddress(\"http://localhost:7741/NorthwindServices/CategoryServices/CategoryService\"); var myChannelFactory = new ChannelFactory&lt;ICategoryService&gt;(myBinding, myEndpoint); ICategoryService instance = myChannelFactory.CreateChannel(); category = instance.GetCategoryDetails(categoryID); myChannelFactory.Close(); return category; &#125; private static WindsorContainer ConfigureContainer() &#123; var container = new WindsorContainer(); container.AddFacility&lt;WcfFacility&gt;().Register( Component.For&lt;ICategoryService&gt;() .Named(\"categegory\") .AsWcfClient(new DefaultClientModel &#123; Endpoint = WcfEndpoint.BoundTo(new WSHttpBinding()) .At(\"http://localhost:7741/NorthwindServices/CategoryServices/CategoryService\") &#125;)); return container; &#125; &#125; ``` 启动程序 ```csharp class Program &#123; private static void Main(string[] args) &#123; var p = new Program(); p.ExeSync(); Console.Read(); &#125; private async void ExeSync() &#123; Task&lt;string&gt; taskResult = CategoryServiceClient.GetCategoryNameAsync(10); DoIndependentWork(); string result = await taskResult; Console.WriteLine(result); &#125; private void DoIndependentWork() &#123; Console.WriteLine(\"loding...\"); &#125; &#125; 在配置好Windsor container和WCF Facility后，我们就实现了一个客户端代理。使用WCF Facility就可以奇迹般的异步调用啦。","raw":null,"content":null,"categories":[{"name":"csharp","slug":"csharp","permalink":"/categories/csharp/"}],"tags":[{"name":"asynchronous,wcf, castle, WcfFacility,异步.","slug":"asynchronous-wcf-castle-WcfFacility-异步","permalink":"/tags/asynchronous-wcf-castle-WcfFacility-异步/"}]},{"title":"在win7中访问VirtualBox中的CentOS站点","slug":"access-virtualbox-centos7-site-on-win7-setting","date":"2018-11-26T05:54:44.352Z","updated":"2018-02-09T14:55:27.971Z","comments":true,"path":"2018/11/26/access-virtualbox-centos7-site-on-win7-setting/","link":"","permalink":"/2018/11/26/access-virtualbox-centos7-site-on-win7-setting/","excerpt":"在VirtualBox中建好CentOS站点应用后，首先要做的是看是否能够正常访问。以下描述了具体的实施过程。","text":"在VirtualBox中建好CentOS站点应用后，首先要做的是看是否能够正常访问。以下描述了具体的实施过程。 目标 可通过http正常访问CentOS的站点 实施步骤1. 确保可以访问外网按如下配置完成后，可自动实现虚机访问外网的功能 设置-&gt;网络-&gt;选网络地下转换(NAT)-&gt;..-&gt;确定 启动虚机后检验1ping lexiangmiao.com 2. 主机访问虚机按如下配置完成后，可自动实现虚机访问主机的功能设置-&gt;网络-&gt;仅主机(Host-Only)网络-&gt;..-&gt;确定 启动虚机后检验123ping 192.168.56.1# 查看网卡和虚机地址ip address 3. 永久开放端口12345678910sudo firewall-cmd --zone=public --add-port=5121/tcp --permanent# --zone 作用域# --add-port=5121/tcp 添加端口，格式为：端口/通讯协议# --permanent 永久生效，没有此参数重启后失效sudo firewall-cmd --reload# 检查新的防火墙规则firewall-cmd --list-all 防火墙开关 1234567891011121314# 临时关闭防火墙systemctl stop firewalld# 永久关闭防火墙，开机自启动systemctl disable firewalld# 临时打开防火墙systemctl start firewalld# 永久打开防火墙，开机启动systemctl enable firewalld# 查看防火墙状态systemctl status firewalld","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"/categories/linux/"}],"tags":[{"name":"linux,CentOS,VirtualBox,win7","slug":"linux-CentOS-VirtualBox-win7","permalink":"/tags/linux-CentOS-VirtualBox-win7/"}]},{"title":"开篇","slug":"start","date":"2018-11-26T05:54:02.705Z","updated":"2017-09-26T05:19:30.190Z","comments":true,"path":"2018/11/26/start/","link":"","permalink":"/2018/11/26/start/","excerpt":"摘要","text":"摘要 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment MarkdownMore info: Markdown More info: Writing internal links123456789101112131415&#123;% post_path start %&#125;// /2017/08/11/start/&#123;% post_link start %&#125;// &lt;a href=\"/2017/08/11/start/\"&gt;开篇&lt;/a&gt;&#123;% post_link start 自定义标题 %&#125;// &lt;a href=\"/2017/08/11/hello-world/\"&gt;自定义标题&lt;/a&gt;&#123;% asset_path example.jpg %&#125;// /2017/08/11/hello-world/example.jpg&#123;% asset_link example.jpg %&#125;// &lt;a href=\"/2017/08/11/hello-world/example.jpg\"&gt;example.jpg&lt;/a&gt;&#123;% asset_link example.jpg Example %&#125;// &lt;a href=\"/2017/08/11/hello-world/example.jpg\"&gt;Example&lt;/a&gt;&#123;% asset_img example.jpg %&#125;// &lt;img src=\"/2017/08/11/hello-world/example.jpg\"&gt; /2018/11/26/start/ 开篇 自定义标题 Gallery exampleYou can also add photos between text to create another gallery like this:1![hydric hammock](/gallery/hydric-hammock.jpg \"hydric hammock\") To add a photo gallery placeholder to your post, just add the following lines to your front-matter:1234photos:- https://www.hdwallpapers.net/previews/starry-night-over-corsica-986.jpg- https://www.hdwallpapers.net/previews/water-plant-close-up-979.jpg- /gallery/hydric-hammock.jpg Finally, you can also use Justified Gallery to display you photos in a grid:123456&lt;div class=\"justified-gallery\"&gt;![hydric hammock](/gallery/hydric-hammock.jpg \"aa hydric hammock\")![hydric hammock](/gallery/hydric-hammock.jpg \"bb hydric hammock\")![hydric hammock](/gallery/hydric-hammock.jpg \"aa hydric hammock\")![hydric hammock](/gallery/hydric-hammock.jpg \"bb hydric hammock\")&lt;/div&gt;","raw":null,"content":null,"categories":[{"name":"others","slug":"others","permalink":"/categories/others/"}],"tags":[{"name":"test,hexo","slug":"test-hexo","permalink":"/tags/test-hexo/"}]}]}