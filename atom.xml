<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Footprint</title>
  
  <subtitle>Jes&#39; footprint</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-01-14T01:10:41.173Z</updated>
  <id>/</id>
  
  <author>
    <name>jes shaw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速搭建基于dubbo的微服务</title>
    <link href="/2020/01/13/java-dubbo-start/"/>
    <id>/2020/01/13/java-dubbo-start/</id>
    <published>2020-01-13T08:00:05.301Z</published>
    <updated>2020-01-14T01:10:41.173Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对微服务的使用大多是基于应用层面，较少全局搭建实践，有时候全面了解可能会带来意想不到的收获。<br><a id="more"></a></p><p>阅读完dubbo文档之后，一个完整的dubbo微服务应当包括：一个注册中心，一个监控中心，一个提供服务方和一个消费端</p><h2 id="1-注册中心和监控搭建"><a href="#1-注册中心和监控搭建" class="headerlink" title="1. 注册中心和监控搭建"></a>1. 注册中心和监控搭建</h2><p>新建一个docker-componse文件</p><p>docker-componse -f app.yml up -d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  zookeeper:</span><br><span class="line">    image: zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - 2181:2181</span><br><span class="line">  admin:</span><br><span class="line">    image: apache/dubbo-admin</span><br><span class="line">    depends_on:</span><br><span class="line">      - zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - 8080</span><br><span class="line">    environment:</span><br><span class="line">      - admin.registry.address=zookeeper://zookeeper:2181</span><br><span class="line">      - admin.config-center=zookeeper://zookeeper:2181</span><br><span class="line">      - admin.metadata-report.address=zookeeper://zookeeper:2181</span><br></pre></td></tr></table></figure><h2 id="2-创建一个服务提供方"><a href="#2-创建一个服务提供方" class="headerlink" title="2.创建一个服务提供方"></a>2.创建一个服务提供方</h2><p>拉取dubbo-registry-zookeeper-samples，启动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRegistryZooKeeperProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(DubboRegistryZooKeeperProviderBootstrap.class)</span><br><span class="line">                .listeners((ApplicationListener&lt;ApplicationEnvironmentPreparedEvent&gt;) event -&gt; &#123;</span><br><span class="line">                    Environment environment = event.getEnvironment();</span><br><span class="line">                    <span class="keyword">int</span> port = environment.getProperty(<span class="string">"embedded.zookeeper.port"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">                    <span class="keyword">new</span> EmbeddedZooKeeper(port, <span class="keyword">false</span>).start();</span><br><span class="line">                &#125;)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-创建一个消费方"><a href="#3-创建一个消费方" class="headerlink" title="3.创建一个消费方"></a>3.创建一个消费方</h2><p>启动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-到监控dubbo-admin中即可以看到是否注册和调用成功"><a href="#4-到监控dubbo-admin中即可以看到是否注册和调用成功" class="headerlink" title="4. 到监控dubbo-admin中即可以看到是否注册和调用成功"></a>4. 到监控dubbo-admin中即可以看到是否注册和调用成功</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener">dubbo-admin</a></li><li><a href="https://github.com/apache/dubbo-spring-boot-project/tree/master/dubbo-spring-boot-samples/dubbo-registry-zookeeper-samples" target="_blank" rel="noopener">dubbo-registry-zookeeper-samples</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来对微服务的使用大多是基于应用层面，较少全局搭建实践，有时候全面了解可能会带来意想不到的收获。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
      <category term="duboo" scheme="/categories/java/duboo/"/>
    
    
      <category term="java,dubbo" scheme="/tags/java-dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师该如何编写高效代码？</title>
    <link href="/2020/01/03/java-efficient-code/"/>
    <id>/2020/01/03/java-efficient-code/</id>
    <published>2020-01-03T08:08:50.977Z</published>
    <updated>2020-01-03T08:45:06.110Z</updated>
    
    <content type="html"><![CDATA[<p>世界上只有两种物质：高效率和低效率；世界上只有两种人：高效率的人和低效率的人。——萧伯纳</p><p>同理，世界上只有两种代码：高效代码和低效代码；世界上只有两种人：编写高效代码的人和编写低效代码的人。如何编写高效代码，是每个研发团队都面临的一个重大问题。</p><p>本文作者根据实际经验，查阅了大量资料，总结了”Java高效代码50例”，让每一个Java程序员都能编写出”高效代码”。</p><a id="more"></a><h2 id="1-常量-amp-变量"><a href="#1-常量-amp-变量" class="headerlink" title="1. 常量 &amp; 变量"></a>1. 常量 &amp; 变量</h2><h3 id="1-1-直接赋值常量值，禁止声明新对象"><a href="#1-1-直接赋值常量值，禁止声明新对象" class="headerlink" title="1.1. 直接赋值常量值，禁止声明新对象"></a>1.1. 直接赋值常量值，禁止声明新对象</h3><p>直接赋值常量值，只是创建了一个对象引用，而这个对象引用指向常量值。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long i = <span class="keyword">new</span> Long(<span class="number">1L</span>);</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long i = <span class="number">1L</span>;</span><br><span class="line">String s = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><h3 id="1-2-当成员变量值无需改变时，尽量定义为静态常量"><a href="#1-2-当成员变量值无需改变时，尽量定义为静态常量" class="headerlink" title="1.2. 当成员变量值无需改变时，尽量定义为静态常量"></a>1.2. 当成员变量值无需改变时，尽量定义为静态常量</h3><p>在类的每个对象实例中，每个成员变量都有一份副本，而成员静态常量只有一份实例。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConnection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">5L</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConnection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT = <span class="number">5L</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-尽量使用基本数据类型，避免自动装箱和拆箱"><a href="#1-3-尽量使用基本数据类型，避免自动装箱和拆箱" class="headerlink" title="1.3. 尽量使用基本数据类型，避免自动装箱和拆箱"></a>1.3. 尽量使用基本数据类型，避免自动装箱和拆箱</h3><p>Java 中的基本数据类型 double、float、long、int、short、char、boolean，分别对应包装类 Double、Float、Long、Integer、Short、Character、Boolean。JVM 支持基本类型与对应包装类的自动转换，被称为自动装箱和拆箱。装箱和拆箱都是需要 CPU 和内存资源的，所以应尽量避免使用自动装箱和拆箱。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] values = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : values) &#123;</span><br><span class="line">    sum += value; <span class="comment">// 相当于 result = Integer.valueOf(result.intValue() + value);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] values = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : values) &#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-如果变量的初值会被覆盖，就没有必要给变量赋初值"><a href="#1-4-如果变量的初值会被覆盖，就没有必要给变量赋初值" class="headerlink" title="1.4. 如果变量的初值会被覆盖，就没有必要给变量赋初值"></a>1.4. 如果变量的初值会被覆盖，就没有必要给变量赋初值</h3><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList;</span><br><span class="line"><span class="keyword">if</span> (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-尽量使用函数内的基本类型临时变量"><a href="#1-5-尽量使用函数内的基本类型临时变量" class="headerlink" title="1.5. 尽量使用函数内的基本类型临时变量"></a>1.5. 尽量使用函数内的基本类型临时变量</h3><p>在函数内，基本类型的参数和临时变量都保存在栈（Stack）中，访问速度较快；对象类型的参数和临时变量的引用都保存在栈（Stack）中，内容都保存在堆（Heap）中，访问速度较慢。在类中，任何类型的成员变量都保存在堆（Heap）中，访问速度较慢。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> result = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(@NonNull <span class="keyword">double</span>[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> value : values) &#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> result = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(@NonNull <span class="keyword">double</span>[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>D;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> value : values) &#123;</span><br><span class="line">            sum += value;</span><br><span class="line">        &#125;</span><br><span class="line">        result += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-尽量不要在循环体外定义变量"><a href="#1-6-尽量不要在循环体外定义变量" class="headerlink" title="1.6. 尽量不要在循环体外定义变量"></a>1.6. 尽量不要在循环体外定义变量</h3><p>在老版 JDK 中，建议“尽量不要在循环体内定义变量”，但是在新版的 JDK 中已经做了优化。通过对编译后的字节码分析，变量定义在循环体外和循环体内没有本质的区别，运行效率基本上是一样的。</p><p>反而，根据“ 局部变量作用域最小化 ”原则，变量定义在循环体内更科学更便于维护，避免了延长大对象生命周期导致延缓回收问题 。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserVO userVO;</span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(userDO.getId());</span><br><span class="line">    ...</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(userDO.getId());</span><br><span class="line">    ...</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-不可变的静态常量，尽量使用非线程安全类"><a href="#1-7-不可变的静态常量，尽量使用非线程安全类" class="headerlink" title="1.7. 不可变的静态常量，尽量使用非线程安全类"></a>1.7. 不可变的静态常量，尽量使用非线程安全类</h3><p>不可变的静态常量，虽然需要支持多线程访问，也可以使用非线程安全类。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&gt; CLASS_MAP;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, Class&gt; classMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    classMap.put(<span class="string">"VARCHAR"</span>, java.lang.String.class);</span><br><span class="line">    ...</span><br><span class="line">    CLASS_MAP = Collections.unmodifiableMap(classMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&gt; CLASS_MAP;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, Class&gt; classMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    classMap.put(<span class="string">"VARCHAR"</span>, java.lang.String.class);</span><br><span class="line">    ...</span><br><span class="line">    CLASS_MAP = Collections.unmodifiableMap(classMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-不可变的成员变量，尽量使用非线程安全类"><a href="#1-8-不可变的成员变量，尽量使用非线程安全类" class="headerlink" title="1.8. 不可变的成员变量，尽量使用非线程安全类"></a>1.8. 不可变的成员变量，尽量使用非线程安全类</h3><p>不可变的成员变量，虽然需要支持多线程访问，也可以使用非线程安全类。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Strategy&gt; strategyList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Strategy&gt; strategyMap;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(strategyList)) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>) Math.ceil(strategyList.size() * <span class="number">4.0</span> / <span class="number">3</span>);</span><br><span class="line">            Map&lt;String, Strategy&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">            <span class="keyword">for</span> (Strategy strategy : strategyList) &#123;</span><br><span class="line">                map.put(strategy.getType(), strategy);</span><br><span class="line">            &#125;</span><br><span class="line">            strategyMap = Collections.unmodifiableMap(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Strategy&gt; strategyList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Strategy&gt; strategyMap;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(strategyList)) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>) Math.ceil(strategyList.size() * <span class="number">4.0</span> / <span class="number">3</span>);</span><br><span class="line">            Map&lt;String, Strategy&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(size);</span><br><span class="line">            <span class="keyword">for</span> (Strategy strategy : strategyList) &#123;</span><br><span class="line">                map.put(strategy.getType(), strategy);</span><br><span class="line">            &#125;</span><br><span class="line">            strategyMap = Collections.unmodifiableMap(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="2-对象-amp-类"><a href="#2-对象-amp-类" class="headerlink" title="2. 对象 &amp; 类"></a>2. 对象 &amp; 类</h2><h3 id="2-1-禁止使用-JSON-转化对象"><a href="#2-1-禁止使用-JSON-转化对象" class="headerlink" title="2.1. 禁止使用 JSON 转化对象"></a>2.1. 禁止使用 JSON 转化对象</h3><p>JSON 提供把对象转化为 JSON 字符串、把 JSON 字符串转为对象的功能，于是被某些人用来转化对象。这种对象转化方式，虽然在功能上没有问题，但是在性能上却存在问题。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO.class);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(userDO.getId());</span><br><span class="line">    ...</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-尽量不使用反射赋值对象"><a href="#2-2-尽量不使用反射赋值对象" class="headerlink" title="2.2. 尽量不使用反射赋值对象"></a>2.2. 尽量不使用反射赋值对象</h3><p>用反射赋值对象，主要优点是节省了代码量，主要缺点却是性能有所下降。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    BeanUtils.copyProperties(userDO, userVO);</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(userDO.getId());</span><br><span class="line">    ...</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-采用-Lambda-表达式替换内部匿名类"><a href="#2-3-采用-Lambda-表达式替换内部匿名类" class="headerlink" title="2.3. 采用 Lambda 表达式替换内部匿名类"></a>2.3. 采用 Lambda 表达式替换内部匿名类</h3><p>对于大多数刚接触 JDK8 的同学来说，都会认为 Lambda 表达式就是匿名内部类的语法糖。实际上， Lambda 表达式在大多数虚拟机中采用 invokeDynamic 指令实现，相对于匿名内部类在效率上会更高一些。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = ...;</span><br><span class="line">Collections.sort(userList, <span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User user1, User user2)</span> </span>&#123;</span><br><span class="line">        Long userId1 = user1.getId();</span><br><span class="line">        Long userId2 = user2.getId();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> userId1.compareTo(userId2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = ...;</span><br><span class="line">Collections.sort(userList, (user1, user2) -&gt; &#123;</span><br><span class="line">    Long userId1 = user1.getId();</span><br><span class="line">    Long userId2 = user2.getId();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> userId1.compareTo(userId2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-4-尽量避免定义不必要的子类"><a href="#2-4-尽量避免定义不必要的子类" class="headerlink" title="2.4. 尽量避免定义不必要的子类"></a>2.4. 尽量避免定义不必要的子类</h3><p>多一个类就需要多一份类加载，所以尽量避免定义不必要的子类。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&gt; CLASS_MAP =</span><br><span class="line">    Collections.unmodifiableMap(<span class="keyword">new</span> HashMap&lt;String, Class&gt;(<span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        put(<span class="string">"VARCHAR"</span>, java.lang.String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&gt; CLASS_MAP;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, Class&gt; classMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    classMap.put(<span class="string">"VARCHAR"</span>, java.lang.String.class);</span><br><span class="line">    ...</span><br><span class="line">    CLASS_MAP = Collections.unmodifiableMap(classMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-尽量指定类的-final-修饰符"><a href="#2-5-尽量指定类的-final-修饰符" class="headerlink" title="2.5. 尽量指定类的 final 修饰符"></a>2.5. 尽量指定类的 final 修饰符</h3><p>为类指定 final 修饰符，可以让该类不可以被继承。如果指定了一个类为 final，则该类所有的方法都是 final 的，Java 编译器会寻找机会内联所有的 final 方法。内联对于提升 Java 运行效率作用重大，具体可参见 Java 运行期优化，能够使性能平均提高 50%。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：使用 Spring 的 AOP 特性时，需要对 Bean 进行动态代理，如果 Bean 类添加了 final 修饰，会导致异常。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="3-1-把跟类成员变量无关的方法声明成静态方法"><a href="#3-1-把跟类成员变量无关的方法声明成静态方法" class="headerlink" title="3.1. 把跟类成员变量无关的方法声明成静态方法"></a>3.1. 把跟类成员变量无关的方法声明成静态方法</h3><p>静态方法的好处就是不用生成类的实例就可以直接调用。静态方法不再属于某个对象，而是属于它所在的类。只需要通过其类名就可以访问，不需要再消耗资源去反复创建对象。即便在类内部的私有方法，如果没有使用到类成员变量，也应该声明为静态方法。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  <span class="keyword">return</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  <span class="keyword">return</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-尽量使用基本数据类型作为方法参数类型，避免不必要的装箱、拆箱和空指针判断"><a href="#3-2-尽量使用基本数据类型作为方法参数类型，避免不必要的装箱、拆箱和空指针判断" class="headerlink" title="3.2. 尽量使用基本数据类型作为方法参数类型，避免不必要的装箱、拆箱和空指针判断"></a>3.2. 尽量使用基本数据类型作为方法参数类型，避免不必要的装箱、拆箱和空指针判断</h3><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(Double value1, Double value2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> double1 = Objects.isNull(value1) ? <span class="number">0.0</span>D : value1;</span><br><span class="line">    <span class="keyword">double</span> double2 = Objects.isNull(value2) ? <span class="number">0.0</span>D : value2;</span><br><span class="line">    <span class="keyword">return</span> double1 + double2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> result = sum(<span class="number">1.0</span>D, <span class="number">2.0</span>D);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> value1, <span class="keyword">double</span> value2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value1 + value2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> result = sum(<span class="number">1.0</span>D, <span class="number">2.0</span>D);</span><br></pre></td></tr></table></figure><h3 id="3-3-尽量使用基本数据类型作为方法返回值类型，避免不必要的装箱、拆箱和空指针判断"><a href="#3-3-尽量使用基本数据类型作为方法返回值类型，避免不必要的装箱、拆箱和空指针判断" class="headerlink" title="3.3. 尽量使用基本数据类型作为方法返回值类型，避免不必要的装箱、拆箱和空指针判断"></a>3.3. 尽量使用基本数据类型作为方法返回值类型，避免不必要的装箱、拆箱和空指针判断</h3><p>在 JDK 类库的方法中，很多方法返回值都采用了基本数据类型，首先是为了避免不必要的装箱和拆箱，其次是为了避免返回值的空指针判断。比如：Collection.isEmpty() 和 Map.size()。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isValid</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserDO user = ...;</span><br><span class="line">Boolean isValid = isValid(user);</span><br><span class="line"><span class="keyword">if</span> (Objects.nonNull(isValid) &amp;&amp; isValid.booleanValue()) &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">UserDO user = ...;</span><br><span class="line"><span class="keyword">if</span> (isValid(user)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-协议方法参数值非空，避免不必要的空指针判断"><a href="#3-4-协议方法参数值非空，避免不必要的空指针判断" class="headerlink" title="3.4. 协议方法参数值非空，避免不必要的空指针判断"></a>3.4. 协议方法参数值非空，避免不必要的空指针判断</h3><p>协议编程，可以 @NonNull 和 @Nullable 标注参数，是否遵循全凭调用者自觉。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(@NonNull UserDO user)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-协议方法返回值非空，避免不必要的空指针判断"><a href="#3-5-协议方法返回值非空，避免不必要的空指针判断" class="headerlink" title="3.5. 协议方法返回值非空，避免不必要的空指针判断"></a>3.5. 协议方法返回值非空，避免不必要的空指针判断</h3><p>协议编程，可以 @NonNull 和 @Nullable 标注参数，是否遵循全凭实现者自觉。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;OrderVO&gt; <span class="title">queryUserOrder</span><span class="params">(Long userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;OrderVO&gt; orderList = orderService.queryUserOrder(userId);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(orderList)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (OrderVO order : orderList) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;OrderVO&gt; <span class="title">queryUserOrder</span><span class="params">(Long userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用代码</span></span><br><span class="line">List&lt;OrderVO&gt; orderList = orderService.queryUserOrder(userId);</span><br><span class="line"><span class="keyword">for</span> (OrderVO order : orderList) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-被调用方法已支持判空处理，调用方法无需再进行判空处理"><a href="#3-6-被调用方法已支持判空处理，调用方法无需再进行判空处理" class="headerlink" title="3.6. 被调用方法已支持判空处理，调用方法无需再进行判空处理"></a>3.6. 被调用方法已支持判空处理，调用方法无需再进行判空处理</h3><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserDO user = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">    user = JSON.parseObject(value, UserDO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDO user = JSON.parseObject(value, UserDO.class);</span><br></pre></td></tr></table></figure><h3 id="3-7-尽量避免不必要的函数封装"><a href="#3-7-尽量避免不必要的函数封装" class="headerlink" title="3.7. 尽量避免不必要的函数封装"></a>3.7. 尽量避免不必要的函数封装</h3><p>方法调用会引起入栈和出栈，导致消耗更多的 CPU 和内存，应当尽量避免不必要的函数封装。当然，为了使代码更简洁、更清晰、更易维护，增加一定的方法调用所带来的性能损耗是值得的。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数封装</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVip</span><span class="params">(Boolean isVip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(isVip);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用代码</span></span><br><span class="line"><span class="keyword">boolean</span> isVip = isVip(user.getVip());</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isVip = Boolean.TRUE.equals(user.getVip());</span><br></pre></td></tr></table></figure><h3 id="3-8-尽量指定方法的-final-修饰符"><a href="#3-8-尽量指定方法的-final-修饰符" class="headerlink" title="3.8. 尽量指定方法的 final 修饰符"></a>3.8. 尽量指定方法的 final 修饰符</h3><p>方法指定 final 修饰符，可以让方法不可以被重写，Java 编译器会寻找机会内联所有的 final 方法。内联对于提升 Java 运行效率作用重大，具体可参见 Java 运行期优化，能够使性能平均提高 50%。</p><p>注意：所有的 private 方法会隐式地被指定 final 修饰符，所以无须再为其指定 final 修饰符。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：使用 Spring 的 AOP 特性时，需要对 Bean 进行动态代理，如果方法添加了 final 修饰，将不会被代理。</p><h2 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4. 表达式"></a>4. 表达式</h2><h3 id="4-1-尽量减少方法的重复调用"><a href="#4-1-尽量减少方法的重复调用" class="headerlink" title="4.1. 尽量减少方法的重复调用"></a>4.1. 尽量减少方法的重复调用</h3><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList = ...;</span><br><span class="line"><span class="keyword">int</span> userLength = userList.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userLength; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-尽量避免不必要的方法调用"><a href="#4-2-尽量避免不必要的方法调用" class="headerlink" title="4.2. 尽量避免不必要的方法调用"></a>4.2. 尽量避免不必要的方法调用</h3><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList = userDAO.queryActive();</span><br><span class="line"><span class="keyword">if</span> (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList;</span><br><span class="line"><span class="keyword">if</span> (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-尽量使用移位来代替正整数乘除"><a href="#4-3-尽量使用移位来代替正整数乘除" class="headerlink" title="4.3. 尽量使用移位来代替正整数乘除"></a>4.3. 尽量使用移位来代替正整数乘除</h3><p>用移位操作可以极大地提高性能。对于乘除 2^n(n 为正整数) 的正整数计算，可以用移位操作来代替。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = a * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = a / <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = a &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="4-4-提取公共表达式，避免重复计算"><a href="#4-4-提取公共表达式，避免重复计算" class="headerlink" title="4.4. 提取公共表达式，避免重复计算"></a>4.4. 提取公共表达式，避免重复计算</h3><p>提取公共表达式，只计算一次值，然后重复利用值。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dx = x2 - x1;</span><br><span class="line"><span class="keyword">double</span> dy = y2 - y1;</span><br><span class="line"><span class="keyword">double</span> distance = Math.sqrt(dx * dx + dy * dy);</span><br><span class="line">或</span><br><span class="line"><span class="keyword">double</span> distance = Math.sqrt(Math.pow(x2 - x1, <span class="number">2</span>) + Math.pow(y2 - y1, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="4-5-尽量不在条件表达式中用-取反"><a href="#4-5-尽量不在条件表达式中用-取反" class="headerlink" title="4.5. 尽量不在条件表达式中用! 取反"></a>4.5. 尽量不在条件表达式中用! 取反</h3><p>使用! 取反会多一次计算，如果没有必要则优化掉。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(a &gt;= <span class="number">10</span>)) &#123;</span><br><span class="line">    ... <span class="comment">// 条件处理 1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ... <span class="comment">// 条件处理 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    ... <span class="comment">// 条件处理 1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ... <span class="comment">// 条件处理 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-对于多常量选择分支，尽量使用-switch-语句而不是-if-else-语句"><a href="#4-6-对于多常量选择分支，尽量使用-switch-语句而不是-if-else-语句" class="headerlink" title="4.6. 对于多常量选择分支，尽量使用 switch 语句而不是 if-else 语句"></a>4.6. 对于多常量选择分支，尽量使用 switch 语句而不是 if-else 语句</h3><p>if-else 语句，每个 if 条件语句都要加装计算，直到 if 条件语句为 true 为止。switch 语句进行了跳转优化，Java 中采用 tableswitch 或 lookupswitch 指令实现，对于多常量选择分支处理效率更高。经过试验证明：在每个分支出现概率相同的情况下，低于 5 个分支时 if-else 语句效率更高，高于 5 个分支时 switch 语句效率更高。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    ...; <span class="comment">// 分支 1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">    ...; <span class="comment">// 分支 2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == ...) &#123;</span><br><span class="line">    ...; <span class="comment">// 分支 n</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...; <span class="comment">// 分支 n+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">        ... <span class="comment">// 分支 1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">        ... <span class="comment">// 分支 2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ... :</span><br><span class="line">        ... <span class="comment">// 分支 n</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        ... <span class="comment">// 分支 n+1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：如果业务复杂，可以采用 Map 实现策略模式。</p><h2 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h2><h3 id="5-1-尽量不要使用正则表达式匹配"><a href="#5-1-尽量不要使用正则表达式匹配" class="headerlink" title="5.1. 尽量不要使用正则表达式匹配"></a>5.1. 尽量不要使用正则表达式匹配</h3><p>正则表达式匹配效率较低，尽量使用字符串匹配操作。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String source = <span class="string">"a::1,b::2,c::3,d::4"</span>;</span><br><span class="line">String target = source.replaceAll(<span class="string">"::"</span>, <span class="string">"="</span>);</span><br><span class="line">Stringp[] targets = source.spit(<span class="string">"::"</span>);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String source = <span class="string">"a::1,b::2,c::3,d::4"</span>;</span><br><span class="line">String target = source.replace(<span class="string">"::"</span>, <span class="string">"="</span>);</span><br><span class="line">Stringp[] targets = StringUtils.split(source, <span class="string">"::"</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-尽量使用字符替换字符串"><a href="#5-2-尽量使用字符替换字符串" class="headerlink" title="5.2. 尽量使用字符替换字符串"></a>5.2. 尽量使用字符替换字符串</h3><p>字符串的长度不确定，而字符的长度固定为 1，查找和匹配的效率自然提高了。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String source = <span class="string">"a:1,b:2,c:3,d:4"</span>;</span><br><span class="line"><span class="keyword">int</span> index = source.indexOf(<span class="string">":"</span>);</span><br><span class="line">String target = source.replace(<span class="string">":"</span>, <span class="string">"="</span>);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String source = <span class="string">"a:1,b:2,c:3,d:4"</span>;</span><br><span class="line"><span class="keyword">int</span> index = source.indexOf(<span class="string">':'</span>);</span><br><span class="line">String target = source.replace(<span class="string">':'</span>, <span class="string">'='</span>);</span><br></pre></td></tr></table></figure><h3 id="5-3-尽量使用-StringBuilder-进行字符串拼接"><a href="#5-3-尽量使用-StringBuilder-进行字符串拼接" class="headerlink" title="5.3. 尽量使用 StringBuilder 进行字符串拼接"></a>5.3. 尽量使用 StringBuilder 进行字符串拼接</h3><p>String 是 final 类，内容不可修改，所以每次字符串拼接都会生成一个新对象。StringBuilder 在初始化时申请了一块内存，以后的字符串拼接都在这块内存中执行，不会申请新内存和生成新对象。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        s += <span class="string">','</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">','</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-不要使用-“”-转化字符串"><a href="#5-4-不要使用-“”-转化字符串" class="headerlink" title="5.4. 不要使用 “”+ 转化字符串"></a>5.4. 不要使用 “”+ 转化字符串</h3><p>使用 “”+ 进行字符串转化，使用方便但是效率低，建议使用 String.valueOf.</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line">String s = <span class="string">""</span> + i;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line">String s = String.valueOf(i);</span><br></pre></td></tr></table></figure><h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h2><h3 id="6-1-不要使用循环拷贝数组，尽量使用-System-arraycopy-拷贝数组"><a href="#6-1-不要使用循环拷贝数组，尽量使用-System-arraycopy-拷贝数组" class="headerlink" title="6.1. 不要使用循环拷贝数组，尽量使用 System.arraycopy 拷贝数组"></a>6.1. 不要使用循环拷贝数组，尽量使用 System.arraycopy 拷贝数组</h3><p>推荐使用 System.arraycopy 拷贝数组，也可以使用 Arrays.copyOf 拷贝数组。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] sources = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] targets = <span class="keyword">new</span> <span class="keyword">int</span>[sources.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targets.length; i++) &#123;</span><br><span class="line">    targets[i] = sources[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] sources = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] targets = <span class="keyword">new</span> <span class="keyword">int</span>[sources.length];</span><br><span class="line">System.arraycopy(sources, <span class="number">0</span>, targets, <span class="number">0</span>, targets.length);</span><br></pre></td></tr></table></figure><h3 id="6-2-集合转化为类型-T-数组时，尽量传入空数组-T-0"><a href="#6-2-集合转化为类型-T-数组时，尽量传入空数组-T-0" class="headerlink" title="6.2. 集合转化为类型 T 数组时，尽量传入空数组 T[0]"></a>6.2. 集合转化为类型 T 数组时，尽量传入空数组 T[0]</h3><p>将集合转换为数组有 2 种形式：toArray(new T[n]) 和 toArray(new T[0])。在旧的 Java 版本中，建议使用 toArray(new T[n])，因为创建数组时所需的反射调用非常慢。在 OpenJDK6 后，反射调用是内在的，使得性能得以提高，toArray(new T[0]) 比 toArray(new T[n]) 效率更高。此外，toArray(new T[n]) 比 toArray(new T[0]) 多获取一次列表大小，如果计算列表大小耗时过长，也会导致 toArray(new T[n]) 效率降低。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...);</span><br><span class="line">Integer[] integers = integerList.toArray(<span class="keyword">new</span> Integer[integerList.size()]);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...);</span><br><span class="line">Integer[] integers = integerList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]); <span class="comment">// 勿用 new Integer[]&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>建议：集合应该提供一个 toArray(Class<t> clazz) 方法，避免无用的空数组初始化（new T[0]）。</t></p><h3 id="6-3-集合转化为-Object-数组时，尽量使用-toArray-方法"><a href="#6-3-集合转化为-Object-数组时，尽量使用-toArray-方法" class="headerlink" title="6.3. 集合转化为 Object 数组时，尽量使用 toArray() 方法"></a>6.3. 集合转化为 Object 数组时，尽量使用 toArray() 方法</h3><p>转化 Object 数组时，没有必要使用 toArray[new Object[0]]，可以直接使用 toArray()。避免了类型的判断，也避免了空数组的申请，所以效率会更高。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objectList = Arrays.asList(<span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3</span>, <span class="string">"4"</span>, <span class="number">5</span>, ...);</span><br><span class="line">Object[] objects = objectList.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objectList = Arrays.asList(<span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3</span>, <span class="string">"4"</span>, <span class="number">5</span>, ...);</span><br><span class="line">Object[] objects = objectList.toArray();</span><br></pre></td></tr></table></figure><h2 id="7-集合"><a href="#7-集合" class="headerlink" title="7. 集合"></a>7. 集合</h2><h3 id="7-1-初始化集合时，尽量指定集合大小"><a href="#7-1-初始化集合时，尽量指定集合大小" class="headerlink" title="7.1. 初始化集合时，尽量指定集合大小"></a>7.1. 初始化集合时，尽量指定集合大小</h3><p>Java 集合初始化时都会指定一个默认大小，当默认大小不再满足数据需求时就会扩容，每次扩容的时间复杂度有可能是 O(n)。所以，尽量指定预知的集合大小，就能避免或减少集合的扩容次数。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Long&gt; userSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;UserVO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    userSet.add(userDO.getId());</span><br><span class="line">    userMap.put(userDO.getId(), userDO);</span><br><span class="line">    userList.add(transUser(userDO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line"><span class="keyword">int</span> userSize = userDOList.size();</span><br><span class="line">Set&lt;Long&gt; userSet = <span class="keyword">new</span> HashSet&lt;&gt;(userSize);</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;((<span class="keyword">int</span>) Math.ceil(userSize * <span class="number">4.0</span> / <span class="number">3</span>));</span><br><span class="line">List&lt;UserVO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;(userSize);</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    userSet.add(userDO.getId());</span><br><span class="line">    userMap.put(userDO.getId(), userDO);</span><br><span class="line">    userList.add(transUser(userDO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-不要使用循环拷贝集合，尽量使用-JDK-提供的方法拷贝集合"><a href="#7-2-不要使用循环拷贝集合，尽量使用-JDK-提供的方法拷贝集合" class="headerlink" title="7.2. 不要使用循环拷贝集合，尽量使用 JDK 提供的方法拷贝集合"></a>7.2. 不要使用循环拷贝集合，尽量使用 JDK 提供的方法拷贝集合</h3><p>JDK 提供的方法可以一步指定集合的容量，避免多次扩容浪费时间和空间。同时，这些方法的底层也是调用 System.arraycopy 方法实现，进行数据的批量拷贝效率更高。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; user1List = ...;</span><br><span class="line">List&lt;UserDO&gt; user2List = ...;</span><br><span class="line">List&lt;UserDO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;(user1List.size() + user2List.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user1 : user1List) &#123;</span><br><span class="line">    userList.add(user1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (UserDO user2 : user2List) &#123;</span><br><span class="line">    userList.add(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; user1List = ...;</span><br><span class="line">List&lt;UserDO&gt; user2List = ...;</span><br><span class="line">List&lt;UserDO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;(user1List.size() + user2List.size());</span><br><span class="line">userList.addAll(user1List);</span><br><span class="line">userList.addAll(user2List);</span><br></pre></td></tr></table></figure><h3 id="7-3-尽量使用-Arrays-asList-转化数组为列表"><a href="#7-3-尽量使用-Arrays-asList-转化数组为列表" class="headerlink" title="7.3. 尽量使用 Arrays.asList 转化数组为列表"></a>7.3. 尽量使用 Arrays.asList 转化数组为列表</h3><p>原理与 “ 不要使用循环拷贝集合，尽量使用 JDK 提供的方法拷贝集合 “ 类似。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">typeList.add(<span class="string">"Short"</span>);</span><br><span class="line">typeList.add(<span class="string">"Integer"</span>);</span><br><span class="line">typeList.add(<span class="string">"Long"</span>);</span><br><span class="line"> </span><br><span class="line">String[] names = ...;</span><br><span class="line">List&lt;String&gt; nameList = ...;</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    nameList.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; typeList = Arrays.asList(<span class="string">"Short"</span>, <span class="string">"Integer"</span>, <span class="string">"Long"</span>);</span><br><span class="line"> </span><br><span class="line">String[] names = ...;</span><br><span class="line">List&lt;String&gt; nameList = ...;</span><br><span class="line">nameList.addAll(Arrays.asList(names));</span><br></pre></td></tr></table></figure><h3 id="7-4-直接迭代需要使用的集合"><a href="#7-4-直接迭代需要使用的集合" class="headerlink" title="7.4. 直接迭代需要使用的集合"></a>7.4. 直接迭代需要使用的集合</h3><p>直接迭代需要使用的集合，无需通过其它操作获取数据。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">for</span> (Long userId : userMap.keySet()) &#123;</span><br><span class="line">    UserDO user = userMap.get(userId);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Long, UserDO&gt; userEntry : userMap.entrySet()) &#123;</span><br><span class="line">    Long userId = userEntry.getKey();</span><br><span class="line">    UserDO user = userEntry.getValue();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-不要使用-size-方法检测空，必须使用-isEmpty-方法检测空"><a href="#7-5-不要使用-size-方法检测空，必须使用-isEmpty-方法检测空" class="headerlink" title="7.5. 不要使用 size 方法检测空，必须使用 isEmpty 方法检测空"></a>7.5. 不要使用 size 方法检测空，必须使用 isEmpty 方法检测空</h3><p>使用 size 方法来检测空逻辑上没有问题，但使用 isEmpty 方法使得代码更易读，并且可以获得更好的性能。任何 isEmpty 方法实现的时间复杂度都是 O(1)，但是某些 size 方法实现的时间复杂度有可能是 O(n)。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList = ...;</span><br><span class="line"><span class="keyword">if</span> (userList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">if</span> (userMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserDO&gt; userList = ...;</span><br><span class="line"><span class="keyword">if</span> (userList.isEmpty()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-非随机访问的-List，尽量使用迭代代替随机访问"><a href="#7-6-非随机访问的-List，尽量使用迭代代替随机访问" class="headerlink" title="7.6. 非随机访问的 List，尽量使用迭代代替随机访问"></a>7.6. 非随机访问的 List，尽量使用迭代代替随机访问</h3><p>对于列表，可分为随机访问和非随机访问两类，可以用是否实现 RandomAccess 接口判断。随机访问列表，直接通过 get 获取数据不影响效率。而非随机访问列表，通过 get 获取数据效率极低。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;UserDO&gt; userDOList = ...;</span><br><span class="line"><span class="keyword">int</span> size = userDOList.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    UserDO userDO = userDOList.get(i);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;UserDO&gt; userDOList = ...;</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，不管列表支不支持随机访问，都应该使用迭代进行遍历。</p><h3 id="7-7-尽量使用-HashSet-判断值存在"><a href="#7-7-尽量使用-HashSet-判断值存在" class="headerlink" title="7.7. 尽量使用 HashSet 判断值存在"></a>7.7. 尽量使用 HashSet 判断值存在</h3><p>在 Java 集合类库中，List 的 contains 方法普遍时间复杂度是 O(n)，而 HashSet 的时间复杂度为 O(1)。如果需要频繁调用 contains 方法查找数据，可以先将 List 转换成 HashSet。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; adminIdList = ...;</span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adminIdList.contains(userDO.getId())) &#123;</span><br><span class="line">        userVOList.add(transUser(userDO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Long&gt; adminIdSet = ...;</span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adminIdSet.contains(userDO.getId())) &#123;</span><br><span class="line">        userVOList.add(transUser(userDO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-8-避免先判断存在再进行获取"><a href="#7-8-避免先判断存在再进行获取" class="headerlink" title="7.8. 避免先判断存在再进行获取"></a>7.8. 避免先判断存在再进行获取</h3><p>如果需要先判断存在再进行获取，可以直接获取并判断空，从而避免了二次查找操作。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserVO <span class="title">transUser</span><span class="params">(UserDO user, Map&lt;Long, RoleDO&gt; roleMap)</span> </span>&#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(user.getId());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (roleMap.contains(user.getRoleId())) &#123;</span><br><span class="line">        RoleDO role = roleMap.get(user.getRoleId());</span><br><span class="line">        userVO.setRole(transRole(role));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserVO <span class="title">transUser</span><span class="params">(UserDO user, Map&lt;Long, RoleDO&gt; roleMap)</span> </span>&#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(user.getId());</span><br><span class="line">    ...</span><br><span class="line">    RoleDO role = roleMap.get(user.getRoleId());</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(role)) &#123;</span><br><span class="line">        userVO.setRole(transRole(role));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-异常"><a href="#8-异常" class="headerlink" title="8. 异常"></a>8. 异常</h2><h3 id="8-1-直接捕获对应的异常"><a href="#8-1-直接捕获对应的异常" class="headerlink" title="8.1. 直接捕获对应的异常"></a>8.1. 直接捕获对应的异常</h3><p>直接捕获对应的异常，避免用 instanceof 判断，效率更高代码更简洁。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    saveData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">        log.error(<span class="string">" 保存数据 IO 异常 "</span>, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">" 保存数据其它异常 "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    saveData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">" 保存数据 IO 异常 "</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">" 保存数据其它异常 "</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-尽量避免在循环中捕获异常"><a href="#8-2-尽量避免在循环中捕获异常" class="headerlink" title="8.2. 尽量避免在循环中捕获异常"></a>8.2. 尽量避免在循环中捕获异常</h3><p>当循环体抛出异常后，无需循环继续执行时，没有必要在循环体中捕获异常。因为，过多的捕获异常会降低程序执行效率。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">sum</span><span class="params">(List&lt;String&gt; valueList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">for</span> (String value : valueList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sum += Double.parseDouble(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">sum</span><span class="params">(List&lt;String&gt; valueList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>D;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String value : valueList) &#123;</span><br><span class="line">            sum += Double.parseDouble(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-禁止使用异常控制业务流程"><a href="#8-3-禁止使用异常控制业务流程" class="headerlink" title="8.3. 禁止使用异常控制业务流程"></a>8.3. 禁止使用异常控制业务流程</h3><p>相对于条件表达式，异常的处理效率更低。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-缓冲区"><a href="#9-缓冲区" class="headerlink" title="9. 缓冲区"></a>9. 缓冲区</h2><h3 id="9-1-初始化时尽量指定缓冲区大小"><a href="#9-1-初始化时尽量指定缓冲区大小" class="headerlink" title="9.1. 初始化时尽量指定缓冲区大小"></a>9.1. 初始化时尽量指定缓冲区大小</h3><p>初始化时，指定缓冲区的预期容量大小，避免多次扩容浪费时间和空间。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="number">1024</span>);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h3 id="9-2-尽量重复使用同一缓冲区"><a href="#9-2-尽量重复使用同一缓冲区" class="headerlink" title="9.2. 尽量重复使用同一缓冲区"></a>9.2. 尽量重复使用同一缓冲区</h3><p>针对缓冲区，Java 虚拟机需要花时间生成对象，还要花时间进行垃圾回收处理。所以，尽量重复利用缓冲区。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder1 = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">builder1.append(<span class="string">"update t_user set name = '"</span>).append(userName).append(<span class="string">"' where id = "</span>).append(userId);</span><br><span class="line">statement.executeUpdate(builder1.toString());</span><br><span class="line">StringBuilder builder2 = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">builder2.append(<span class="string">"select id, name from t_user where id = "</span>).append(userId);</span><br><span class="line">ResultSet resultSet = statement.executeQuery(builder2.toString());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">builder.append(<span class="string">"update t_user set name = '"</span>).append(userName).append(<span class="string">"' where id = "</span>).append(userId);</span><br><span class="line">statement.executeUpdate(builder.toString());</span><br><span class="line">builder.setLength(<span class="number">0</span>);</span><br><span class="line">builder.append(<span class="string">"select id, name from t_user where id = "</span>).append(userId);</span><br><span class="line">ResultSet resultSet = statement.executeQuery(builder.toString());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，使用 setLength 方法让缓冲区重新从 0 开始。</p><h3 id="9-3-尽量设计使用同一缓冲区"><a href="#9-3-尽量设计使用同一缓冲区" class="headerlink" title="9.3. 尽量设计使用同一缓冲区"></a>9.3. 尽量设计使用同一缓冲区</h3><p>为了提高程序运行效率，在设计上尽量使用同一缓冲区。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化 XML(UserDO)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toXml</span><span class="params">(UserDO user)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">    builder.append(<span class="string">"&lt;UserDO&gt;"</span>);</span><br><span class="line">    builder.append(toXml(user.getId()));</span><br><span class="line">    builder.append(toXml(user.getName()));</span><br><span class="line">    builder.append(toXml(user.getRole()));</span><br><span class="line">    builder.append(<span class="string">"&lt;/UserDO&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转化 XML(Long)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toXml</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">    builder.append(<span class="string">"&lt;Long&gt;"</span>);</span><br><span class="line">    builder.append(value);</span><br><span class="line">    builder.append(<span class="string">"&lt;/Long&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用代码</span></span><br><span class="line">UserDO user = ...;</span><br><span class="line">String xml = toXml(user);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化 XML(UserDO)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toXml</span><span class="params">(StringBuilder builder, UserDO user)</span> </span>&#123;</span><br><span class="line">    builder.append(<span class="string">"&lt;UserDO&gt;"</span>);</span><br><span class="line">    toXml(builder, user.getId());</span><br><span class="line">    toXml(builder, user.getName());</span><br><span class="line">    toXml(builder, user.getRole());</span><br><span class="line">    builder.append(<span class="string">"&lt;/UserDO&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转化 XML(Long)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toXml</span><span class="params">(StringBuilder builder, Long value)</span> </span>&#123;</span><br><span class="line">    builder.append(<span class="string">"&lt;Long&gt;"</span>);</span><br><span class="line">    builder.append(value);</span><br><span class="line">    builder.append(<span class="string">"&lt;/Long&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用代码</span></span><br><span class="line">UserDO user = ...;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">toXml(builder, user);</span><br><span class="line">String xml = builder.toString();</span><br></pre></td></tr></table></figure><p>去掉每个转化方法中的缓冲区申请，申请一个缓冲区给每个转化方法使用。从时间上来说，节约了大量缓冲区的申请释放时间；从空间上来说，节约了大量缓冲区的临时存储空间。</p><h3 id="9-4-尽量使用缓冲流减少-IO-操作"><a href="#9-4-尽量使用缓冲流减少-IO-操作" class="headerlink" title="9.4. 尽量使用缓冲流减少 IO 操作"></a>9.4. 尽量使用缓冲流减少 IO 操作</h3><p>使用缓冲流 BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream 等，可以大幅较少 IO 次数并提升 IO 速度。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"a"</span>);</span><br><span class="line">    FileOutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"b"</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((size = input.read(temp)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        output.write(temp, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">" 复制文件异常 "</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream input = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"a"</span>));</span><br><span class="line">    BufferedOutputStream output = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"b"</span>))) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((size = input.read(temp)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        output.write(temp, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">" 复制文件异常 "</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，可以根据实际情况手动指定缓冲流的大小，把缓冲流的缓冲作用发挥到最大。</p><h2 id="10-线程"><a href="#10-线程" class="headerlink" title="10. 线程"></a>10. 线程</h2><h3 id="10-1-在单线程中，尽量使用非线程安全类"><a href="#10-1-在单线程中，尽量使用非线程安全类" class="headerlink" title="10.1. 在单线程中，尽量使用非线程安全类"></a>10.1. 在单线程中，尽量使用非线程安全类</h3><p>使用非线程安全类，避免了不必要的同步开销。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="number">128</span>);</span><br><span class="line">buffer.append(<span class="string">"select * from "</span>).append(T_USER).append(<span class="string">" where id = ?"</span>);</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder buffer = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">buffer.append(<span class="string">"select * from "</span>).append(T_USER).append(<span class="string">" where id = ?"</span>);</span><br></pre></td></tr></table></figure><h3 id="10-2-在多线程中，尽量使用线程安全类"><a href="#10-2-在多线程中，尽量使用线程安全类" class="headerlink" title="10.2. 在多线程中，尽量使用线程安全类"></a>10.2. 在多线程中，尽量使用线程安全类</h3><p>使用线程安全类，比自己实现的同步代码更简洁更高效。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    counter.incrementAndGet();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-尽量减少同步代码块范围"><a href="#10-3-尽量减少同步代码块范围" class="headerlink" title="10.3. 尽量减少同步代码块范围"></a>10.3. 尽量减少同步代码块范围</h3><p>在一个方法中，可能只有一小部分的逻辑是需要同步控制的，如果同步控制了整个方法会影响执行效率。所以，尽量减少同步代码块的范围，只对需要进行同步的代码进行同步。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">    ... <span class="comment">// 非同步操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 非同步操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-尽量合并为同一同步代码块"><a href="#10-4-尽量合并为同一同步代码块" class="headerlink" title="10.4. 尽量合并为同一同步代码块"></a>10.4. 尽量合并为同一同步代码块</h3><p>同步代码块是有性能开销的，如果确定可以合并为同一同步代码块，就应该尽量合并为同一同步代码块。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理单一订单</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">handleOrder</span><span class="params">(OrderDO order)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理所有订单</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleOrder</span><span class="params">(List&lt;OrderDO&gt; orderList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (OrderDO order : orderList) &#123;</span><br><span class="line">        handleOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理单一订单</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">handleOrder</span><span class="params">(OrderDO order)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理所有订单</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">handleOrder</span><span class="params">(List&lt;OrderDO&gt; orderList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (OrderDO order : orderList) &#123;</span><br><span class="line">        handleOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5-尽量使用线程池减少线程开销"><a href="#10-5-尽量使用线程池减少线程开销" class="headerlink" title="10.5. 尽量使用线程池减少线程开销"></a>10.5. 尽量使用线程池减少线程开销</h3><p>多线程中两个必要的开销：线程的创建和上下文切换。采用线程池，可以尽量地避免这些开销。</p><p><strong>反例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    executorService.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://mp.weixin.qq.com/s/-ioLU65Sxg8tTmPyItZ2Iw" target="_blank" rel="noopener">原文</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;世界上只有两种物质：高效率和低效率；世界上只有两种人：高效率的人和低效率的人。——萧伯纳&lt;/p&gt;
&lt;p&gt;同理，世界上只有两种代码：高效代码和低效代码；世界上只有两种人：编写高效代码的人和编写低效代码的人。如何编写高效代码，是每个研发团队都面临的一个重大问题。&lt;/p&gt;
&lt;p&gt;本文作者根据实际经验，查阅了大量资料，总结了”Java高效代码50例”，让每一个Java程序员都能编写出”高效代码”。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java, efficient code, 高效代码" scheme="/tags/java-efficient-code-%E9%AB%98%E6%95%88%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose：链接外部容器的几种方式</title>
    <link href="/2019/12/31/docker-compose-external-links/"/>
    <id>/2019/12/31/docker-compose-external-links/</id>
    <published>2019-12-31T06:17:06.668Z</published>
    <updated>2020-01-13T07:43:32.594Z</updated>
    
    <content type="html"><![CDATA[<p>在Docker中，容器之间的链接是一种很常见的操作：它提供了访问其中的某个容器的网络服务而不需要将所需的端口暴露给Docker Host主机的功能。Docker Compose中对该特性的支持同样是很方便的。然而，如果需要链接的容器没有定义在同一个docker-compose.yml中的时候，这个时候就稍微麻烦复杂了点。</p><a id="more"></a><p>在不使用Docker Compose的时候，将两个容器链接起来使用—link参数，相对来说比较简单，以nginx镜像为例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --name test1 -d nginx  <span class="comment">#开启一个实例test1</span></span><br><span class="line">docker run --rm --name test2 --link test1 -d nginx <span class="comment">#开启一个实例test2并与test1建立链接</span></span><br></pre></td></tr></table></figure><p>这样，test2与test1便建立了链接，就可以在test2中使用访问test1中的服务了。</p><p>如果使用Docker Compose，那么这个事情就更简单了，还是以上面的nginx镜像为例子，编辑docker-compose.yml文件为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line">  test2:</span><br><span class="line">    image: nginx</span><br><span class="line">    depends_on:</span><br><span class="line">      - test1</span><br><span class="line">    links:</span><br><span class="line">      - test1</span><br><span class="line">  test1:</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>最终效果与使用普通的Docker命令docker run xxxx建立的链接并无区别。这只是一种最为理想的情况。</p><p>如果容器没有定义在同一个docker-compose.yml文件中，应该如何链接它们呢？<br>又如果定义在docker-compose.yml文件中的容器需要与docker run xxx启动的容器链接，需要如何处理？<br>针对这两种典型的情况，下面给出我个人测试可行的办法：</p><h3 id="方式一：让需要链接的容器同属一个外部网络"><a href="#方式一：让需要链接的容器同属一个外部网络" class="headerlink" title="方式一：让需要链接的容器同属一个外部网络"></a>方式一：让需要链接的容器同属一个外部网络</h3><p>我们还是使用nginx镜像来模拟这样的一个情景：假设我们需要将两个使用Docker Compose管理的nignx容器（test1和test2）链接起来，使得test2能够访问test1中提供的服务，这里我们以能ping通为准。</p><p>首先，我们定义容器test1的docker-compose.yml文件内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line">  test2:</span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: test1</span><br><span class="line">    networks:</span><br><span class="line">      - default</span><br><span class="line">      - app_net</span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    external: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>容器test2内容与test1基本一样，只是多了一个external_links,需要特别说明的是：最近发布的Docker版本已经不需要使用external_links来链接容器，容器的DNS服务可以正确的作出判断，因此如果你你需要兼容较老版本的Docker的话，那么容器test2的docker-compose.yml文件内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line">  test2:</span><br><span class="line">    image: nginx</span><br><span class="line">    networks:</span><br><span class="line">      - default</span><br><span class="line">      - app_net</span><br><span class="line">    external_links:</span><br><span class="line">      - test1</span><br><span class="line">    container_name: test2</span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    external: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>否则的话，test2的docker-compose.yml和test1的定义完全一致，不需要额外多指定一个external_links。相关的问题请参见stackoverflow上的相关问题：docker-compose + external container</p><p>正如你看到的那样，这里两个容器的定义里都使用了同一个外部网络app_net,因此，我们需要在启动这两个容器之前通过以下命令再创建外部网络：</p><p>docker network create app_net<br>之后，通过docker-compose up -d命令启动这两个容器，然后执行docker exec -it test2 ping test1,你将会看到如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it test2 ping test1</span><br><span class="line">PING test1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.091 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.146 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.150 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.145 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=4 ttl=64 time=0.126 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=5 ttl=64 time=0.147 ms</span><br></pre></td></tr></table></figure><p>证明这两个容器是成功链接了，反过来在test1中pingtest2也是能够正常ping通的。</p><p>如果我们通过docker run –rm –name test3 -d nginx这种方式来先启动了一个容器(test3)并且没有指定它所属的外部网络，而需要将其与test1或者test2链接的话，这个时候手动链接外部网络即可：</p><p>docker network connect app_net test3<br>这样，三个容器都可以相互访问了。</p><h3 id="方式二：更改需要链接的容器的网络模式"><a href="#方式二：更改需要链接的容器的网络模式" class="headerlink" title="方式二：更改需要链接的容器的网络模式"></a>方式二：更改需要链接的容器的网络模式</h3><p>通过更改你想要相互链接的容器的网络模式为bridge,并指定需要链接的外部容器（external_links)即可。与同属外部网络的容器可以相互访问的链接方式一不同，这种方式的访问是单向的。</p><p>还是以nginx容器镜像为例子，如果容器实例nginx1需要访问容器实例nginx2，那么nginx2的doker-compose.yml定义为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line">  nginx2:</span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: nginx2</span><br><span class="line">    network_mode: bridge</span><br><span class="line">与其对应的，nginx1的docker-compose.yml定义为：</span><br><span class="line"></span><br><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line">  nginx1:</span><br><span class="line">    image: nginx</span><br><span class="line">    external_links:</span><br><span class="line">      - nginx2</span><br><span class="line">    container_name: nginx1</span><br><span class="line">    network_mode: bridge</span><br></pre></td></tr></table></figure><p>需要特别说明的是，这里的external_links是不能省略的，而且nginx1的启动必须要在nginx2之后，否则可能会报找不到容器nginx2的错误。</p><p>接着我们使用ping来测试下连通性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it nginx1 ping nginx2  <span class="comment"># nginx1 to nginx2</span></span><br><span class="line">PING nginx2 (172.17.0.4): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=0 ttl=64 time=0.141 ms</span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.139 ms</span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.145 ms</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it nginx2 ping nginx1 <span class="comment">#nginx2 to nginx1</span></span><br><span class="line">ping: unknown host</span><br></pre></td></tr></table></figure></p><p>以上也能充分证明这种方式是属于单向联通的。</p><p>在实际应用中根据自己的需要灵活的选择这两种链接方式，如果想偷懒的话，大可选择第二种。不过我更推荐第一种，不难看出无论是联通性还是灵活性，较为更改网络模式的第二种都更为友好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Docker中，容器之间的链接是一种很常见的操作：它提供了访问其中的某个容器的网络服务而不需要将所需的端口暴露给Docker Host主机的功能。Docker Compose中对该特性的支持同样是很方便的。然而，如果需要链接的容器没有定义在同一个docker-compose.yml中的时候，这个时候就稍微麻烦复杂了点。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="/categories/docker/"/>
    
    
      <category term="docker, docker-compose" scheme="/tags/docker-docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>Spring面试问题</title>
    <link href="/2019/07/08/spring-interview-questions/"/>
    <id>/2019/07/08/spring-interview-questions/</id>
    <published>2019-07-08T07:56:42.113Z</published>
    <updated>2019-07-08T07:56:42.113Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架是最受欢迎的Java企业级web应用框架。<em>依赖注入</em>和<em>面象方面</em>是<em>Spring框架</em>的核心。<br><a id="more"></a></p><p>我最近提交了许多<a href="https://www.journaldev.com/2888/spring-tutorial-spring-core-tutorial" target="_blank" rel="noopener">Spring教程</a>，它将有助于帮你详细的解释Spring面试问题的核心概念。</p><h2 id="Spring面试问题列表"><a href="#Spring面试问题列表" class="headerlink" title="Spring面试问题列表"></a>Spring面试问题列表</h2><ol><li>Spring框架是什么？</li><li>Spring框架有些什么重要的特性和优势？</li><li>你对依赖注入的理解是什么？</li><li>Spring框架中怎么样实现依赖注入？</li><li>使用Spring工具套件有什么好处？</li><li>重要的Spring模块名称有哪些？</li><li>你对面向切面编程的理解是什么？</li><li>AOP中的Aspect, Advice, Pointcut, JointPoint and Advice Arguments是什么？</li><li>Spring AOP 和AspectJ AOP有什么区别？</li><li>Spring IoC容器是什么？</li><li>Spring Bean是什么？</li><li>Spring Bean配置文件的重要性是什么？</li><li>把一个类配置成Spring Bean有些什么不同方法？</li><li>Spring Bean有些什么不同作用域？</li><li><a href="#spring-bean-life-cycle">Spring Bean生命周期是什么？</a></li><li>在Spring Bean中怎么获得ServletContext和ServletConfig对象</li><li>Bean装配和@Autowired注解是什么？</li><li>Spring Bean自动装配有几种不同类型？</li><li>Spring Bean是线程安全的吗？</li><li>在Spring MVC的Controller是什么？</li><li>在Spring中 @Component, @Repository 和 @Service注解有什么区别？</li><li>DispatcherServlet 和 ContextLoaderListener是什么？</li><li>在Spring中的ViewResolver是什么？</li><li>MultipartResolver是什么？什么时候使用？</li><li>Spring MVC框架怎样处理异常？</li><li>在Java程序中怎样创建ApplicationContext？</li><li>能有多个Spring配置文件吗？</li><li>ContextLoaderListener是什么？</li><li>为了创建Spring MVC应用，至少需要配置什么？</li><li><a href="#spring-mvc-architecture">相对与MVC架构，你对Spring MVC框架的理解是怎样的？</a></li><li>Spring MVC应用怎样实现平地化？</li><li>使用Spring怎样创建Restful Web服务并返回JSON？</li><li>你使用过哪些重要的Spring注解？</li><li>我们可以发送一个Object作为Controller handler方法的响应吗？</li><li>Spring MVC应用怎样上传文件？</li><li>Spring Web MVC架构怎样验证表单数据？</li><li>Spring MVC拦截器（Interceptor）是什么？怎样使用？</li><li>Spring JdbcTemplate类是什么？怎样使用？</li><li>Spring Web应用中怎样使用Tomcat JNDI数据资源？</li><li>在Spring中怎样实现事务管理？</li><li>Spring DAO是什么？</li><li>怎样集成Spring和Hibernate框架？</li><li>Spring Security是什么？</li><li>怎样注入一个java.util.Properties到Spring Bean？</li><li>Spring框架使用哪些设计模式？</li><li>Spring框架有些什么最佳实践？</li></ol><h2 id="Spring面试问题及答案"><a href="#Spring面试问题及答案" class="headerlink" title="Spring面试问题及答案"></a>Spring面试问题及答案</h2><h3 id="1-Spring框架是什么？"><a href="#1-Spring框架是什么？" class="headerlink" title="1. Spring框架是什么？"></a>1. Spring框架是什么？</h3><p>Spring是使用最为广泛的Java企业级框架。 Spring框架是“依赖注入”和“面向切面编程”。</p><p>Spring框架可以用于一般的java应用中。通过依赖注入的实现不同组件中的松耦合，使用Spring支持的面向切面编程我们可以像日志和认证那样跨截面执行任务。</p><p>我喜欢Spring是因它提供了许多特性和不同的功能模块，如Spring MVC和Spring JDBC。由于它是开源的，有许多在线资源和活跃的社区，使用Spring框架，在相同的时间内，工作起来更加的容易和有趣。</p><h3 id="2-Spring框架有些什么重要的特性和优势？"><a href="#2-Spring框架有些什么重要的特性和优势？" class="headerlink" title="2. Spring框架有些什么重要的特性和优势？"></a>2. Spring框架有些什么重要的特性和优势？</h3><p>Spring框架是基于“依赖注入”和“面向切面编程”两个设计概念建立。</p><p>Spring框架有如下特性：  </p><ul><li>对开发来讲使用该框架有极少的开销，且它是一个轻量级的框架。  </li><li>依赖注入和控制反转编写的组件是相互独立的，Spring容器负责一起装配组件，帮助实现我们的工作。  </li><li>Spring IoC容器管理Spring Bean的生命周期和规划具体的配置，如JNDI查找。 </li><li>Spring MVC框架可以用于创建web应用，也可以创建返回XML或JSON的web服务。 </li><li>只需要非常少的配置便能支持事务管理，JDBC操作，文件上传，异常处理等。配置你可以使用注解或者配置文件实现。</li></ul><p>使用Spring框架有如下优势：  </p><ul><li>减少在应用中两个不同组件的直接依赖，一般来说Spring IoC容器负责初始化资源或beans并注入它们的依赖。  </li><li>在Spring框架中写单元测试更加容易。因为业务逻辑不直接依赖实际的资源实现类。可以容易的编写测试配置和注入测试目的模拟的beans。  </li><li>减少了重复代码的数量，如初始化对象，打开或关闭资源。我很喜欢JdbcTemplate类，是因为它帮助我们移除了所有来自JDBC编程的重复代码。  </li><li>Spring框架被分成多个模块，它帮助我们保证我们的应用变得轻量级。例如若不需要Spring事件管理特性，则可以不添加它的依赖到项目中。  </li><li>Spring框架支持大部分Java企业级特性，甚至更多。它总是与时俱进，如它有Android的Spring项目，帮助我们写出更好的native android的应用。这些使得Spring框架更完整，不需要因为新需求再引入不同的框架。</li></ul><h3 id="3-你对依赖注入的理解是什么？"><a href="#3-你对依赖注入的理解是什么？" class="headerlink" title="3. 你对依赖注入的理解是什么？"></a>3. 你对依赖注入的理解是什么？</h3><p>依赖注入设计模式允许我们移除硬编码依赖，确保应用松耦合，可扩展，可维护。把依赖解析从编译时移动运行时，我们就能够实现依赖注入模式。</p><p>使用依赖注入有这些好处：分享了关注点，减少了重复代码，组件可配置和更易单元测试。</p><h3 id="4-Spring框架中怎么样实现依赖注入？"><a href="#4-Spring框架中怎么样实现依赖注入？" class="headerlink" title="4. Spring框架中怎么样实现依赖注入？"></a>4. Spring框架中怎么样实现依赖注入？</h3><p>在Spring应用中我们可以基于“Spring XML”以及“注解”配置实现依赖注入。更好的理解，请阅读<a href="https://www.journaldev.com/2410/spring-dependency-injection" target="_blank" rel="noopener">Spring依赖注入实例</a>。</p><h3 id="5-使用Spring工具套件有什么好处？"><a href="#5-使用Spring工具套件有什么好处？" class="headerlink" title="5. 使用Spring工具套件有什么好处？"></a>5. 使用Spring工具套件有什么好处？</h3><p>安装扫描件到Eclipse将获得更多Spring工具套件的特性。无论如何，Eclipse中的Spring工具套件有诸如Maven支持，创建不同Spring项目类型的模板和更好Spring应用性能的tc服务。</p><p>我喜欢Spring工具套件，是因为在使用AOP切入点（pointcuts）和APO通知（advices）时，高亮显示了这些Spring组件。它清楚的显示了哪个方法将来自指定的切入点。因此相较与安装每一件小工具，在开发Spring应用时，我更喜欢使用Spring工具套件。</p><h3 id="6-重要的Spring模块名称有哪些？"><a href="#6-重要的Spring模块名称有哪些？" class="headerlink" title="6. 重要的Spring模块名称有哪些？"></a>6. 重要的Spring模块名称有哪些？</h3><p>Spring框架一些重要的模块如下：  </p><ul><li>Spring Context – 用于依赖注入。  </li><li>Spring AOP –用于面向切面编程。  </li><li>Spring DAO – 用于DAO模式的数据操作。  </li><li>Spring JDBC – 用于JDBC和数据的支持。  </li><li>Spring ORM – 用于ORM工具的支持，如Hibernate。</li><li>Spring Web Module – 用于创建web应用。</li><li>Spring MVC – 为创建web应用，web服务等的MVC实现。</li></ul><h3 id="7-你对面向切面编程的理解是什么？"><a href="#7-你对面向切面编程的理解是什么？" class="headerlink" title="7. 你对面向切面编程的理解是什么？"></a>7. 你对面向切面编程的理解是什么？</h3><p>企业级应用有一些对不同类型的对象和应用模块的公用横向关注点是合适必要的。例始日志，事务管理，数据验证，身份认证等。<br>在面向切面编程中，应用模块是通过类实现的。如AOP应用模块是通过配置在不同类的方法上的模向关注点Aspects实现的。</p><p>AOP从类中分离了横向关注点任务的直接依赖，这在一般的面向对象编程中是不可做到的。例如，你可以把日志从类中分离，但这个类不午不将要调用这些方法记录日志数据（AOP就不需要）。</p><h3 id="8-AOP中的连接点（Joinpoint）-切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？"><a href="#8-AOP中的连接点（Joinpoint）-切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？" class="headerlink" title="8. AOP中的连接点（Joinpoint）, 切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？"></a>8. AOP中的连接点（Joinpoint）, 切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？</h3><ul><li>连接点（Joinpoint）<br>程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入通知。连接点由两个信息确定：第一是用方法表示的程序执行点；第二是用相对点表示的方位。连接点是在应用执行过程中能够插入切面的一个点。</li></ul><p>以查电表为例子：电力公司为多个住户提供服务，连接点就是每一家的电表所在的位置（类中的方法的调用前、调用后…）。</p><ul><li>切点（Pointcut）<br>AOP通过“切点”定位特定的连接点。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。其实确切地说，不能称之为查询连接点，因为连接点是方法执行前、执行后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体连接点上，还需要提供方位信息。</li></ul><p>电力公司为每一个抄表员都分别指定某一块区域的住户。切点就是划分的区域。</p><ul><li>通知（Advice）<br>切面的工作被称为通知。是织入到目标类连接点上的一段程序代码。<br>Spring切面可以应用5种类型的通知：<br>-前置通知（Before）：在目标方法被调用之前调用通知功能；<br>-后置通知（After）：在目标方法完成之后调用通知，此时不会关心方 法的输出是什么；<br>-返回通知（After-returning）：在目标方法成功执行之后调用通知；<br>-异常通知（After-throwing）：在目标方法抛出异常后调用通知；<br>-环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调 用之前和调用之后执行自定义的行为。</li></ul><p>抄表员的本职工作是登记用电量，但他们还需要向电力公司汇报的信息。<br>登记用电量是目标对象，汇报的信息就是通知。 </p><ul><li>引介（Introduction）  </li></ul><p>引入允许我们向现有的类添加新方法或属性，是一种特殊的通知。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</p><ul><li>切面（Aspect）</li></ul><p>切面由切点和通知（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义。</p><p>抄表员的开始一天的工作时，他要知道从哪些区域（切点）收集信息，从而进行汇报（通知）。</p><ul><li>织入（Weaving）</li></ul><p>织入是把切面应用到目标对象并创建新的代理对象的过程。<br>AOP有三种织入的方式：<br>a、编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。<br>b、类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增<br>强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。<br>c、运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring<br>AOP就是以这种方式织入切面的。</p><h3 id="9-Spring-AOP-和AspectJ-AOP有什么区别？"><a href="#9-Spring-AOP-和AspectJ-AOP有什么区别？" class="headerlink" title="9. Spring AOP 和AspectJ AOP有什么区别？"></a>9. Spring AOP 和AspectJ AOP有什么区别？</h3><p>AspectJ是面向方向的一个工业标准级实现，而Spring仅实现了一些案例的AOP。Spring AOP 和AspectJ AOP主要有以下区别：</p><ul><li>相较与AspectJ，Spring AOP使用更简单，因为不需要担心织入（weaving）处理。 </li><li>Spring AOP支持AspectJ 注解,因此你熟悉AspectJ，使用Spring AOP也是容易的。</li><li>Spring AOP仅支持基于代理的AOP，因此它仅能应用到方法执行连接点上。AspectJ支持所有种类的切点。</li><li>Spring AOP缺点之一是它通过Spring上下文仅能应用到beans创建时。</li></ul><h3 id="10-Spring-IoC容器是什么？"><a href="#10-Spring-IoC容器是什么？" class="headerlink" title="10. Spring IoC容器是什么？"></a>10. Spring IoC容器是什么？</h3><p>控制反转（Inversion of Control）是在两对象依赖之间实现松耦合的机制。为了实现松耦合和在运行时对象的动态绑定，对象定义依赖是通过其他装配对象被注入的。Spring IoC容器是注入依赖到某个对象和待我们使用的一种程序。</p><p>Spring框架的IoC容器类由<code>org.springframework.beans</code>和<code>org.springframework.context</code>包组成。提供给我们多种不同的方式实现对象依赖的解耦。</p><p>一些常用的应用上下文实现如下：</p><ul><li><code>AnnotationConfigApplicationContext</code>: 对于基于注角配置的独立java应用程序。</li><li><code>ClassPathXmlApplicationContext</code>: 对于基于XML配置的独立java应用程序。</li><li><code>FileSystemXmlApplicationContext</code>: 除xml配置可以在文件系统中的从任何地方加载之外，与<code>ClassPathXmlApplicationContext</code>类似。</li><li><code>AnnotationConfigWebApplicationContext</code> 和 <code>XmlWebApplicationContext</code>：对于web应用程序。</li></ul><h3 id="11-Spring-Bean是什么？"><a href="#11-Spring-Bean是什么？" class="headerlink" title="11. Spring Bean是什么？"></a>11. Spring Bean是什么？</h3><p>Spring IoC容器初始化任何普通的java类被称为Spring Bean。我们使用Spring ApplicationContext得到Spring Bean实例.</p><p>Spring IoC容器管理Spring Bean生命周期，bean作用域并在bean中注入任何所需要的依赖关系。</p><h3 id="12-Spring-Bean配置文件的重要性是什么？"><a href="#12-Spring-Bean配置文件的重要性是什么？" class="headerlink" title="12. Spring Bean配置文件的重要性是什么？"></a>12. Spring Bean配置文件的重要性是什么？</h3><p>我们使用Spring Bean配置文件定义的所有beans将通过Spring Context初始化。在我们创建Spring ApplicationContext的实例时，它将读取spring bean xml文件和初始化所有的实例。一旦ApplicationContext初始化成功，我们就能够使用它得到不同的bean实例了。</p><p>除了Spring Bean配置外，该文件还包含Spring MVC拦截器，视图解析器和其他元素，以支持基于注释的配置。</p><h3 id="13-把一个类配置成Spring-Bean有些什么不同方法？"><a href="#13-把一个类配置成Spring-Bean有些什么不同方法？" class="headerlink" title="13. 把一个类配置成Spring Bean有些什么不同方法？"></a>13. 把一个类配置成Spring Bean有些什么不同方法？</h3><p>有以下三种方案配置Spring Bean：</p><p><strong>XML 配置</strong>: 这是非常受欢迎的配置方式，我们可以使用在context文件中的元素来配置Spring Bean。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"com.journaldev.spring.beans.MyBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>基于Java的配置</strong>：如果仅使用注释，则可以使用@Bean注释配置Spring Bean。 此注释与@Configuration类配合使用即配置成Spring bean。 示例配置如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.journaldev.spring.main"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyService();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了从spring context得到这个bean，我们需要使用所以代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(</span><br><span class="line">MyConfiguration.class);</span><br><span class="line">MyService service = ctx.getBean(MyService.class);</span><br></pre></td></tr></table></figure><p><strong>基于注解的配置</strong>：我们还可以使用@Component，@Service，@Repository和@Controller注释与类配置为spring bean。 对于这些，我们需要提供基本的包位置来扫描这些类。 例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.journaldev.spring"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="14-Spring-Bean有些什么不同作用域？"><a href="#14-Spring-Bean有些什么不同作用域？" class="headerlink" title="14. Spring Bean有些什么不同作用域？"></a>14. Spring Bean有些什么不同作用域？</h3><p>Spring Beans定义了5种作用域。</p><p><strong>singleton</strong>: 将为每个容器创建一个Bean的一个实例。 这是Spring bean的默认作用域。 在使用此作用域时，确保spring bean没有共享实例变量，否则可能导致数据不一致性问题，因为它不是线程安全的。<br><strong>prototype</strong>: 每次请求bean时都会创建一个新的实例。<br><strong>request</strong>: 这与prototype作用域相同，但它意在用于Web应用程序。 将为每个HTTP请求创建一个新的bean实例。该作用域仅在基于web的Spring上下文中才有效。该作用域仅在基于web的Spring上下文中才有效。<br><strong>session</strong>: 将为容器的每个HTTP会话创建一个新的bean。该作用域仅在基于web的Spring上下文中才有效。<br><strong>global-session</strong>: 这用于为Portlet应用程序创建全局会话bean。该作用域仅在Portlet上下文中才有效。<br>Spring框架是可扩展的，我们也可以创建我们自己的作用域，但是大多数时候，我们使用框架提供的作用域就够了。</p><p>要设置Spring bean作用域，我们可以在bean元素或@Scope注解中使用“scope”属性来进行基于注解的配置。</p><p><a name="spring-bean-life-cycle"></a></p><h3 id="15-Spring-Bean生命周期是什么？"><a href="#15-Spring-Bean生命周期是什么？" class="headerlink" title="15. Spring Bean生命周期是什么？"></a>15. Spring Bean生命周期是什么？</h3><p>Spring Beans通过Spring容器被初始化并所有依赖也被注入。在上下文多销毁时，所有初始化的beans也销毁。这在大多数情况下运行良好，但有时我们希望初始化其他资源或进行一些验证，然后才能使我们的bean准备被使用。Spring框架提供了对Spring bean中的初始化后和销毁前方法的支持。</p><p>我们可以通过两种方法来实现 - 通过在Spring bean配置中实现InitializingBean和DisposableBean接口或使用init-method和destroy-method属性。有关更多详细信息，请参阅<a href="https://www.journaldev.com/2637/spring-bean-life-cycle" target="_blank" rel="noopener">Spring Bean生命周期方法</a>。</p><h3 id="16-在Spring-Bean中怎么获得ServletContext和ServletConfig对象"><a href="#16-在Spring-Bean中怎么获得ServletContext和ServletConfig对象" class="headerlink" title="16. 在Spring Bean中怎么获得ServletContext和ServletConfig对象"></a>16. 在Spring Bean中怎么获得ServletContext和ServletConfig对象</h3><p>在Spring Bean中有两种方法获得容器指定的对象。</p><ol><li>实现Spring * Aware接口。对于这些ServletContextAware和ServletConfigAware接口，有关这些aware接口的完整示例，请阅读<a href="https://www.journaldev.com/2637/spring-bean-life-cycle" target="_blank" rel="noopener">Spring Aware Interfaces</a>。   </li><li>使用@Autowired注释与类型为ServletContext和ServletConfig的Bean变量。 它们只能在servlet容器的特定环境中工作。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ServletContext servletContext;</span><br></pre></td></tr></table></figure></li></ol><h3 id="17-Bean装配和-Autowired注解是什么？"><a href="#17-Bean装配和-Autowired注解是什么？" class="headerlink" title="17. Bean装配和@Autowired注解是什么？"></a>17. Bean装配和@Autowired注解是什么？</h3><p>spring bean依赖注入的处理，在初始化它时被称作spring bean装配。</p><p>通常来讲显示的装配所有的bean依赖是最佳实践，但spring框架也支持自动装配。我们也可以使用@Autowired注解和域或方法通过类型的方式自动装配。为了使此注解工作，我们还需要在spring bean配置文件中启用基于注释的配置。 这可以通过上下文来完成：annotation-config元素。</p><p>有关@Autowired注释的更多详细信息，请阅读<a href="https://www.journaldev.com/2623/spring-autowired-annotation" target="_blank" rel="noopener">Spring Autowire示例</a>。</p><h3 id="18-Spring-Bean自动装配有几种不同类型？"><a href="#18-Spring-Bean自动装配有几种不同类型？" class="headerlink" title="18. Spring Bean自动装配有几种不同类型？"></a>18. Spring Bean自动装配有几种不同类型？</h3><p>spring框架有4种类型的自动装配：</p><ol><li>据名称自动装配  </li><li>据类型自动装配  </li><li>据构造类自动装配  </li><li>据@Autowired和@Qualifier注解自动装配<br>Prior to Spring 3.1, autowire by autodetect was also supported that was similar to autowire by constructor or byType. For more details about these options, please read Spring Bean Autowiring.</li></ol><p>在Spring 3.1之前，据自动探测自动装配也被支持，它类似于构造器或按类型自动装配。有关这些选项的更多详细信息，请参阅<a href="https://www.journaldev.com/2623/spring-autowired-annotation" target="_blank" rel="noopener">Spring Bean自动装配</a>。</p><h3 id="19-Spring-Bean是线程安全的吗？"><a href="#19-Spring-Bean是线程安全的吗？" class="headerlink" title="19. Spring Bean是线程安全的吗？"></a>19. Spring Bean是线程安全的吗？</h3><p>Spring bean的默认作用域是单例的，因此每个上下文只有一个实例。 这意味着所有类级别的变量在任何线程可以更新它，导致数据不一致。 因此，在默认模式下，spring bean不是线程安全的。</p><p>但是我们可以改变spring bean的作用域到request, prototype or session，在牺牲性能的基础上，来实现线程安全。 这是一个设计决策，并根据项目要求。</p><h3 id="20-在Spring-MVC的Controller是什么？"><a href="#20-在Spring-MVC的Controller是什么？" class="headerlink" title="20. 在Spring MVC的Controller是什么？"></a>20. 在Spring MVC的Controller是什么？</h3><p>就像MVC设计模式一样，Controller是负责处理所有客户端请求的类，并将它们分发到配置的资源去处理它。在Spring MVC中，org.springframework.web.servlet.DispatcherServlet是基于spring bean配置初始化上下文的前端控制器类。</p><p>Controller类负责根据请求映射来处理不同类型的客户端请求。 我们可以使用@Controller注解创建一个控制器类。 通常它与@RequestMapping注释一起使用来指定特定URI映射的处理程序方法。</p><h3 id="21-在Spring中-Component-Repository-和-Service注解有什么区别？"><a href="#21-在Spring中-Component-Repository-和-Service注解有什么区别？" class="headerlink" title="21. 在Spring中 @Component, @Repository 和 @Service注解有什么区别？"></a>21. 在Spring中 @Component, @Repository 和 @Service注解有什么区别？</h3><p><code>@Component</code>注解用于指示该类是一个组件。 当使用基于注解的配置时，这些类将自动检测并配置为bean被使用。</p><p><code>@Controller</code>注解是一种特定类型的组件，用于MVC应用程序，大多与@RequestMapping注解一起使用。</p><p><code>@Repository</code>注解用于指示组件用作存储库，以及用于存储/检索/搜索数据的机制。 我们可以使用DAO模式实现类应用此注解。</p><p><code>@Service</code>注解用于表示该类是一个服务。 通常会提供一些服务的业务门面类使用该注解。</p><p>为了类可以自动检测到，我们可以使用任何以上注解，但不同的类型的注解被提供后，你可以轻松区分类的意图。</p><h3 id="22-DispatcherServlet-和-ContextLoaderListener是什么？"><a href="#22-DispatcherServlet-和-ContextLoaderListener是什么？" class="headerlink" title="22. DispatcherServlet 和 ContextLoaderListener是什么？"></a>22. DispatcherServlet 和 ContextLoaderListener是什么？</h3><p><code>DispatcherServlet</code>是Spring MVC应用程序中的前台控制器，它加载spring bean配置文件并初始化配置的所有bean。 如果注解已启用，它还会扫描程序包和配置使用<code>@Component</code>，<code>@Controller</code>，<code>@Repository</code>或<code>@Service</code>注解的任何bean。</p><p><code>ContextLoaderListener</code>是启动和关闭Spring的根<code>WebApplicationContext</code>的侦听器。 重要的功能是将<code>ApplicationContext</code>的生命周期与<code>ServletContext</code>的生命周期结合起来，并自动创建<code>ApplicationContext</code>。 我们可以跨越不同spring上下文中,使用它定义共享bean。</p><h3 id="23-在Spring中的ViewResolver是什么？"><a href="#23-在Spring中的ViewResolver是什么？" class="headerlink" title="23. 在Spring中的ViewResolver是什么？"></a>23. 在Spring中的ViewResolver是什么？</h3><p><code>ViewResolver</code>实现被用于按名称解析视图页面。 通常我们在spring bean配置文件中配置它。 例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>InternalResourceViewResolver</code>是<code>ViewResolver</code>接口的实现之一，我们通过bean属性提供了view pages目录和后缀位置。 因此，如果控制器处理程序方法返回“home”，则视图解析器将使用位于/WEB-INF/views/home.jsp的视图页面。</p><h3 id="24-MultipartResolver是什么？什么时候使用？"><a href="#24-MultipartResolver是什么？什么时候使用？" class="headerlink" title="24. MultipartResolver是什么？什么时候使用？"></a>24. MultipartResolver是什么？什么时候使用？</h3><p><code>MultipartResolver</code>接口用于上传文件 - <code>CommonsMultipartResolver</code>和<code>StandardServletMultipartResolver</code>是由spring框架提供的用于文件上传的两个实现。 默认情况下，没有配置多部分解析器，但是要使用它们来上传文件，我们需要在spring bean配置中定义一个名为“multipartResolver”的bean，其类型为MultipartResolver。</p><p>一旦配置完成后，任何多部分请求将由配置的<code>MultipartResolver</code>解析，并传递一个包装的<code>HttpServletRequest</code>。 然后在控制器类中使用它来获取文件并处理它。 这里提供一个完整的例子，请阅读<a href="https://www.journaldev.com/2573/spring-mvc-file-upload-example-single-multiple-files" target="_blank" rel="noopener">Spring MVC文件上传示例</a>。</p><h3 id="25-Spring-MVC框架怎样处理异常？"><a href="#25-Spring-MVC框架怎样处理异常？" class="headerlink" title="25. Spring MVC框架怎样处理异常？"></a>25. Spring MVC框架怎样处理异常？</h3><p>Spring MVC框架提供了以下方法来帮助我们实现强大的异常处理。</p><ol><li><strong>基于控制器</strong> - 我们可以在控制器类中定义异常处理程序方法。 我们需要的是使用@ExceptionHandler注解来注解这些方法。</li><li><strong>全局异常处理程序</strong> - 异常处理是一个横切关注的问题，Spring提供了<code>@ControllerAdvice</code>注解，让我们可以使用任何类来定义我们的全局异常处理程序。  </li><li><strong><code>HandlerExceptionResolver</code>实现</strong> - 对于一般异常，大多数时候我们提供静态页面。 Spring Framework提供了<code>HandlerExceptionResolver</code>接口，我们可以实现这个接口来创建全局异常处理程序。 这种额外的方法来定义全局异常处理程序的原因是Spring框架还提供了我们可以在spring bean配置文件中定义的默认实现类，以获得Spring框架异常处理的好处。</li></ol><p>有关完整的示例，请参阅<a href="https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver" target="_blank" rel="noopener">Spring异常处理</a>示例。</p><h3 id="26-在Java程序中怎样创建ApplicationContext？"><a href="#26-在Java程序中怎样创建ApplicationContext？" class="headerlink" title="26. 在Java程序中怎样创建ApplicationContext？"></a>26. 在Java程序中怎样创建ApplicationContext？</h3><p>在独立的java程序中创建<code>ApplicationContext</code>有以下几种方法。</p><ol><li><strong><code>AnnotationConfigApplicationContext</code></strong>：如果我们在独立的Java应用程序中使用Spring，并使用注解进行配置，那么我们可以使用它来初始化容器并获取bean对象。  </li><li><strong><code>ClassPathXmlApplicationContext</code></strong>：如果我们在独立应用程序中有spring bean配置xml文件，那么我们可以使用此类来加载文件并获取容器对象。  </li><li><strong><code>FileSystemXmlApplicationContext</code></strong>：类似于<code>ClassPathXmlApplicationContext</code>，除了可以从文件系统中的任何位置之外的任何地方加载xml配置文件。 </li></ol><h3 id="27-能有多个Spring配置文件吗？"><a href="#27-能有多个Spring配置文件吗？" class="headerlink" title="27. 能有多个Spring配置文件吗？"></a>27. 能有多个Spring配置文件吗？</h3><p>对于Spring MVC应用程序，我们可以通过contextConfigLocation定义多个Spring上下文配置文件。 该位置字符串可以由多个位置组成，并以任意数量的逗号和空格分隔。 例如;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/appServlet/servlet-context.xml,/WEB-INF/spring/appServlet/servlet-jdbc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们还可以定义多个根级Spring配置，并通过上下文参数加载它们。 例如;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/root-context.xml /WEB-INF/spring/root-security.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>另一个选择是在上下文配置文件中使用import元素来导入其他配置，例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans:import</span> <span class="attr">resource</span>=<span class="string">"spring-jdbc.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="28-ContextLoaderListener是什么？"><a href="#28-ContextLoaderListener是什么？" class="headerlink" title="28. ContextLoaderListener是什么？"></a>28. ContextLoaderListener是什么？</h3><p>ContextLoaderListener是用于加载根上下文的侦听器类，并定义将对所有其他上下文可见的spring bean配置。 它在web.xml文件中配置为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="29-为了创建Spring-MVC应用，至少需要配置什么？"><a href="#29-为了创建Spring-MVC应用，至少需要配置什么？" class="headerlink" title="29. 为了创建Spring MVC应用，至少需要配置什么？"></a>29. 为了创建Spring MVC应用，至少需要配置什么？</h3><p>要创建一个简单的Spring MVC应用程序，我们需要执行以下任务。</p><ol><li>在项目中添加spring-context和spring-webmvc依赖项。</li><li>在web.xml文件中配置DispatcherServlet，以通过spring容器处理请求。</li><li>Spring bean配置文件来定义bean，如果使用注解，那么必须在这里配置。 此外，我们还需要为视图页面配置视图解析器。</li><li>控制器类与请求映射定义为处理客户端请求。<br>以上步骤应该足以创建一个简单的Spring MVC Hello World应用程序。</li></ol><p><a name="spring-mvc-architecture"></a></p><h3 id="30-相对与MVC架构，你对Spring-MVC框架的理解是怎样的？"><a href="#30-相对与MVC架构，你对Spring-MVC框架的理解是怎样的？" class="headerlink" title="30. 相对与MVC架构，你对Spring MVC框架的理解是怎样的？"></a>30. 相对与MVC架构，你对Spring MVC框架的理解是怎样的？</h3><p>正如名称所示，Spring MVC建立在Model-View-Controller架构之上。 DispatcherServlet是Spring MVC应用程序中的前端控制器，负责处理所有传入的请求并将其委托给不同的控制器处理程序方法。</p><p>模型可以是Spring框架中的任何Java Bean，就像任何其他MVC框架Spring一样，提供了将表单数据自动绑定到java bean。 我们可以将模型bean设置为在视图页面中使用的属性。</p><p>查看页面可以是JSP，静态HTML等，视图解析器负责查找正确的视图页面。 一旦查看页面被识别到，控制将返回给DispatcherServlet控制器。 DispatcherServlet负责呈现视图，并向客户端返回最终响应。</p><h3 id="31-Spring-MVC应用怎样实现本地化？"><a href="#31-Spring-MVC应用怎样实现本地化？" class="headerlink" title="31. Spring MVC应用怎样实现本地化？"></a>31. Spring MVC应用怎样实现本地化？</h3><p>Spring通过资源包为本地化或i18n提供了极好的支持。 使我们的应用程序本地化所需的基本步骤是：</p><ol><li>为不同的区域设置创建消息资源束，如messages_en.properties，messages_fr.properties等。</li><li>在<code>ResourceBundleMessageSource</code>或<code>ReloadableResourceBundleMessageSource</code>类型的spring bean配置文件中定义messageSource bean。</li><li><p>要更改区域设置支持，请定义类型为CookieLocaleResolver的localeResolver bean并配置LocaleChangeInterceptor拦截器。<br>示例配置可以如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"classpath:messages"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"defaultLocale"</span> <span class="attr">value</span>=<span class="string">"en"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"cookieName"</span> <span class="attr">value</span>=<span class="string">"myAppLocaleCookie"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"cookieMaxAge"</span> <span class="attr">value</span>=<span class="string">"3600"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"paramName"</span> <span class="attr">value</span>=<span class="string">"locale"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在具有键名称的视图页面中使用spring:message元素，DispatcherServlet选择相应的值，并将页面呈现在相应的区域设置中，并作为响应返回。</p></li></ol><p>有关完整的示例，请阅读<a href="https://www.journaldev.com/2610/spring-mvc-internationalization-i18n-and-localization-l10n-example" target="_blank" rel="noopener">Spring本地化</a>示例 。</p><h3 id="32-使用Spring怎样创建Restful-Web服务并返回JSON？"><a href="#32-使用Spring怎样创建Restful-Web服务并返回JSON？" class="headerlink" title="32. 使用Spring怎样创建Restful Web服务并返回JSON？"></a>32. 使用Spring怎样创建Restful Web服务并返回JSON？</h3><p>我们可以使用Spring Framework创建返回JSON数据的Restful Web服务。 Spring提供与<a href="https://www.journaldev.com/2324/jackson-json-java-parser-api-example-tutorial" target="_blank" rel="noopener">Jackson JSON</a> API的集成，我们可以使用它在安静的Web服务中发送JSON响应。</p><p>我们需要执行以下步骤来配置我们的Spring MVC应用程序以发送JSON响应：</p><ol><li><p>添加Jackson JSON依赖项，如果您使用Maven，可以使用以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Jackson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.databind-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Spring bean配置文件中配置RequestMappingHandlerAdapter bean，并将messageConverters属性设置为MappingJackson2HttpMessageConverter bean。 样品配置将是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Configure to plugin JSON as request and response in method handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">beans:list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">beans:ref</span> <span class="attr">bean</span>=<span class="string">"jsonMessageConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">beans:list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Configure bean to convert JSON to POJO and vice versa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"jsonMessageConverter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在控制器处理程序方法中，使用@ResponseBody注释返回Object作为响应。 示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = EmpRestURIConstants.GET_EMP, method = RequestMethod.GET)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Employee <span class="title">getEmployee</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> empId) </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Start getEmployee. ID="</span>+empId);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> empData.get(empId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>您可以通过任何API调用其余服务，但是如果要使用Spring，那么我们可以使用RestTemplate类来轻松实现。<br>有关一个完整的例子，请阅读<a href="https://www.journaldev.com/2552/spring-rest-example-tutorial-spring-restful-web-services" target="_blank" rel="noopener">Spring Restful Webservice</a>示例 。</p></li></ol><h3 id="33-你使用过哪些重要的Spring注解？"><a href="#33-你使用过哪些重要的Spring注解？" class="headerlink" title="33. 你使用过哪些重要的Spring注解？"></a>33. 你使用过哪些重要的Spring注解？</h3><p>我在项目中使用的一些Spring注解是：</p><p><strong>@Controller</strong> - 用于Spring MVC项目中的控制器类。<br><strong>@RequestMapping</strong> - 用于在控制器处理程序方法中配置URI映射。 这是一个非常重要的注释。<br><strong>@ResponseBody</strong> - 用于发送Object作为响应，通常用于发送XML或JSON数据作为响应。<br><strong>@PathVariable</strong> - 用于将动态值从URI映射到处理程序方法参数。<br><strong>@Autowired</strong> - 用于spring bean的自动装配依赖。<br><strong>@Qualifier</strong> - 与@Autowired注解一起使用，以避免多个Bean类型的实例存在混淆。<br><strong>@Service</strong> - 用于服务类。<br><strong>@Scope</strong> - 用于配置spring bean的作用域。<br><strong>@Configuration</strong>， <strong>@ComponentScan</strong>和<strong>@Bean</strong> - 用于基于Java的配置。<br>用于配置切面和通知的AspectJ注解， <strong>@Aspect</strong> ， <strong>@Before</strong> ， <strong>@After</strong> ， <strong>@Around</strong> ， <strong>@Pointcut</strong>等。</p><h3 id="34-我们可以发送一个Object作为Controller-handler方法的响应吗？"><a href="#34-我们可以发送一个Object作为Controller-handler方法的响应吗？" class="headerlink" title="34. 我们可以发送一个Object作为Controller handler方法的响应吗？"></a>34. 我们可以发送一个Object作为Controller handler方法的响应吗？</h3><p>可以，我们可以使用@ResponseBody注解。 这就是我们如何在restful的Web服务中发送基于JSON或XML的响应。</p><h3 id="35-Spring-MVC应用怎样上传文件？"><a href="#35-Spring-MVC应用怎样上传文件？" class="headerlink" title="35. Spring MVC应用怎样上传文件？"></a>35. Spring MVC应用怎样上传文件？</h3><p>Spring提供内置的支持，可通过MultipartResolver接口实现上传文件。 它非常易于使用，只需要配置更改才能使其正常工作。 显然，我们需要编写控制器处理程序方法来处理传入的文件并进行处理。 有关完整的示例，请参阅<a href="https://www.journaldev.com/2573/spring-mvc-file-upload-example-single-multiple-files" target="_blank" rel="noopener">Spring文件上传</a>示例 。</p><h3 id="36-Spring-Web-MVC架构怎样验证表单数据？"><a href="#36-Spring-Web-MVC架构怎样验证表单数据？" class="headerlink" title="36. Spring Web MVC架构怎样验证表单数据？"></a>36. Spring Web MVC架构怎样验证表单数据？</h3><p>Spring支持基于JSR-303注释的验证，并提供我们可以实现的Validator接口来创建我们自己的自定义验证器。 对于使用基于JSR-303的验证，我们需要使用所需的验证来注释bean变量。</p><p>对于自定义验证器实现，我们需要在controller类中进行配置。 有关完整的示例，请参阅<a href="https://www.journaldev.com/2668/spring-validation-example-mvc-validator" target="_blank" rel="noopener">Spring MVC表单验证</a>示例 。</p><h3 id="37-Spring-MVC拦截器（Interceptor）是什么？怎样使用？"><a href="#37-Spring-MVC拦截器（Interceptor）是什么？怎样使用？" class="headerlink" title="37. Spring MVC拦截器（Interceptor）是什么？怎样使用？"></a>37. Spring MVC拦截器（Interceptor）是什么？怎样使用？</h3><p>Spring MVC拦截器就像Servlet过滤器，允许我们拦截客户端请求并处理它。 我们可以在三个地方拦截客户端请求 - <strong>preHandle</strong> ， <strong>postHandle</strong>和<strong>afterCompletion</strong> 。</p><p>我们可以通过实现HandlerInterceptor接口或扩展抽象类HandlerInterceptorAdapter来创建spring拦截器。</p><p>我们需要在spring bean配置文件中配置拦截器。 我们可以定义拦截器来拦截所有的客户端请求，也可以为特定的URI映射进行配置。 有关详细的示例，请参考<a href="https://www.journaldev.com/2676/spring-mvc-interceptor-example-handlerinterceptor-handlerinterceptoradapter" target="_blank" rel="noopener">Spring MVC拦截器</a>示例 。</p><h3 id="38-Spring-JdbcTemplate类是什么？怎样使用？"><a href="#38-Spring-JdbcTemplate类是什么？怎样使用？" class="headerlink" title="38. Spring JdbcTemplate类是什么？怎样使用？"></a>38. Spring JdbcTemplate类是什么？怎样使用？</h3><p>Spring Framework提供与JDBC API的良好集成，并提供JdbcTemplate实用程序类，我们可以使用它来避免数据库操作逻辑（如打开/关闭连接，ResultSet，PreparedStatement等）的bolier-plate代码。</p><p>对于JdbcTemplate示例，请参考<a href="https://www.journaldev.com/2593/spring-jdbc-example" target="_blank" rel="noopener">Spring JDBC</a>示例 。</p><h3 id="39-Spring-Web应用中怎样使用Tomcat-JNDI数据资源？"><a href="#39-Spring-Web应用中怎样使用Tomcat-JNDI数据资源？" class="headerlink" title="39. Spring Web应用中怎样使用Tomcat JNDI数据资源？"></a>39. Spring Web应用中怎样使用Tomcat JNDI数据资源？</h3><p>对于使用servlet容器配置的JNDI DataSource，我们需要在spring bean配置文件中进行配置，然后将其注入spring beans作为依赖关系。 然后我们可以使用它与JdbcTemplate来执行数据库操作。</p><p>示例配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"dbDataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jndi.JndiObjectFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"jndiName"</span> <span class="attr">value</span>=<span class="string">"java:comp/env/jdbc/MyLocalDB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>有关完整的例子，请参考<a href="https://www.journaldev.com/2597/spring-datasource-jndi-with-tomcat-example" target="_blank" rel="noopener">Spring Tomcat JNDI</a>示例 。</p><h3 id="40-在Spring中怎样实现事务管理？"><a href="#40-在Spring中怎样实现事务管理？" class="headerlink" title="40. 在Spring中怎样实现事务管理？"></a>40. 在Spring中怎样实现事务管理？</h3><p>Spring框架通过声明式事务管理以及编程式事务管理来提供事务管理支持。 声明式事务管理被广泛使用，因为它在大多数情况下易于使用和工作。</p><p>我们使用@Transactional注释的注释方法进行声明式事务管理。 我们需要在Spring bean配置文件中为DataSource配置事务管理器。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="41-Spring-DAO是什么？"><a href="#41-Spring-DAO是什么？" class="headerlink" title="41. Spring DAO是什么？"></a>41. Spring DAO是什么？</h3><p>提供Spring DAO支持，以一致和简单的方式处理JDBC，Hibernate等数据访问技术。 例如，对于各自的技术，我们有<code>JdbcDaoSupport</code> ， <code>HibernateDaoSupport</code> ， <code>JdoDaoSupport</code>和<code>JpaDaoSupport</code> 。</p><p>Spring DAO还提供了异常层次结构的一致性，我们不需要捕获特定的异常。</p><h3 id="42-怎样集成Spring和Hibernate框架？"><a href="#42-怎样集成Spring和Hibernate框架？" class="headerlink" title="42. 怎样集成Spring和Hibernate框架？"></a>42. 怎样集成Spring和Hibernate框架？</h3><p>我们可以使用Spring ORM模块来集成Spring和Hibernate框架，如果您正在使用Hibernate 3+，SessionFactory提供当前会话，那么您应该避免使用<code>HibernateTemplate</code>或<code>HibernateDaoSupport</code>类，并更好地使用依赖注入的DAO模式进行集成。</p><p>Spring ORM还提供对使用Spring声明性事务管理的支持，所以您应该利用这一点，而不是使用hibernate的锅炉代码进行事务管理。</p><p>为了更好地理解，您应该请阅读以下教程：</p><p><a href="https://www.journaldev.com/3524/spring-hibernate-integration-example-tutorial" target="_blank" rel="noopener">Spring Hibernate集成</a>示例<br><a href="https://www.journaldev.com/3531/spring-mvc-hibernate-mysql-integration-crud-example-tutorial" target="_blank" rel="noopener">Spring MVC Hibernate集成</a>示例</p><h3 id="43-Spring-Security是什么？"><a href="#43-Spring-Security是什么？" class="headerlink" title="43. Spring Security是什么？"></a>43. Spring Security是什么？</h3><p>Spring Security框架关注的焦点是在java应用程序中提供身份验证和授权。 它解决了大多数常见的安全漏洞问题，如CSRF攻击。</p><p>通过使用注解,如@EnableWebSecurity ，在Web应用程序中使用Spring Security是很有好处的且易于使用。 您应该通过以下文章来了解如何使用Spring Security框架。</p><p><a href="https://www.journaldev.com/2715/spring-security-example-tutorial" target="_blank" rel="noopener">Servlet Web应用程序中的Spring Security</a><br><a href="https://www.journaldev.com/2736/spring-security-example-userdetailsservice" target="_blank" rel="noopener">Spring MVC和Spring Security集成</a>示例</p><h3 id="44-怎样注入一个java-util-Properties到Spring-Bean？"><a href="#44-怎样注入一个java-util-Properties到Spring-Bean？" class="headerlink" title="44. 怎样注入一个java.util.Properties到Spring Bean？"></a>44. 怎样注入一个java.util.Properties到Spring Bean？</h3><p>我们需要定义propertyConfigurer bean，该bean将从给定的属性文件加载属性。 然后我们可以使用Spring EL支持将属性注入其他bean依赖关系。 例如;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/application.properties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.journaldev.spring.EmployeeDaoImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxReadResults"</span> <span class="attr">value</span>=<span class="string">"$&#123;results.read.max&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果您使用注解来配置spring bean，则可以像下面那样注入属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;maxReadResults&#125;"</span>) </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxReadResults;</span><br></pre></td></tr></table></figure></p><h3 id="45-Spring框架使用哪些设计模式？"><a href="#45-Spring框架使用哪些设计模式？" class="headerlink" title="45. Spring框架使用哪些设计模式？"></a>45. Spring框架使用哪些设计模式？</h3><p>Spring框架正在使用很多设计模式，其中一些常见的是：</p><ol><li>单例模式：创建具有默认范围的bean。</li><li>工厂模式 ：Bean Factory类</li><li>原型模式 ：Bean作用域</li><li>适配器模式 ：Spring Web和Spring MVC</li><li>代理模式 ：Spring Aspect面向编程支持</li><li>模板方法模式 ：JdbcTemplate，HibernateTemplate等</li><li>前端控制器：Spring MVC DispatcherServlet</li><li>数据访问对象：Spring DAO支持</li><li>依赖注入和面向方面的编程</li></ol><h3 id="46-Spring框架有些什么最佳实践？"><a href="#46-Spring框架有些什么最佳实践？" class="headerlink" title="46. Spring框架有些什么最佳实践？"></a>46. Spring框架有些什么最佳实践？</h3><p>Spring Framework的一些最佳实践是：</p><ol><li>避免模​​式引用中的版本号，以确保我们有最新的配置。</li><li>根据spring-jdbc.xml，spring-security.xml等关注的问题来分隔spring bean配置。</li><li>对于在Spring MVC中的多个上下文中使用的spring bean，在根上下文中创建它们并使用listener进行初始化。</li><li>尽可能多地配置bean依赖关系，尽量避免自动装配。</li><li>对于应用程序级属性，最佳方法是创建一个属性文件，并在spring bean配置文件中读取它。</li><li>对于较小的应用程序，注解是有用的，但对于较大的应用程序注解可能会变得很痛苦。 如果我们在xml文件中有所有配置，维护它将会更容易。</li><li>为组件使用正确的注解，轻松了解其意图。 对于服务，使用@Service和DAO bean使用@Repository。</li><li>Spring框架有很多模块，使用你需要的。 删除通过Spring Tool Suite模板创建项目时添加的所有额外的依赖项。</li><li>如果您正在使用Aspects，请确保连接点范围尽可能的窄，以避免对不需要的方法的发送通知。 考虑更容易使用的自定义注解，可以避免任何问题。</li><li>当有实际利益时，使用依赖注入，只是为了松散耦合而不使用它，因为它更难维护。</li></ol><p>这就是Spring Framework面试的问题。 我希望这些问题能帮助您进行Java EE面试。 一旦有新的面试问题我将即时更新！</p><p><a href="https://www.journaldev.com/2696/spring-interview-questions-and-answers" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring框架是最受欢迎的Java企业级web应用框架。&lt;em&gt;依赖注入&lt;/em&gt;和&lt;em&gt;面象方面&lt;/em&gt;是&lt;em&gt;Spring框架&lt;/em&gt;的核心。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,interview,面试" scheme="/tags/java-spring-interview-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot热部署：spring-boot-devtools</title>
    <link href="/2019/07/08/spring-hot-deploy/"/>
    <id>/2019/07/08/spring-hot-deploy/</id>
    <published>2019-07-08T07:56:42.113Z</published>
    <updated>2019-07-08T07:56:42.113Z</updated>
    
    <content type="html"><![CDATA[<p>spring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是热部署。</p><a id="more"></a><p>当我们修改了classpath下的文件（包括类文件、属性文件、页面等）时，会重新启动应用（由于其采用的双类加载器机制，这个启动会非常快，另外也可以选择使用jrebel）。</p><p>spring-boot-devtools使用了两个类加载器来实现重启（restart）机制：</p><p>base类加载器（base ClassLoader）, restart类加载器（restart ClassLoader）。</p><ul><li>base ClassLoader：用于加载不会改变的jar（eg.第三方依赖的jar）</li><li>restart ClassLoader：用于加载我们正在开发的jar（eg.整个项目里我们自己编写的类）。当应用重启后，原先的restart ClassLoader被丢掉、重新new一个restart ClassLoader来加载这些修改过的东西，而base ClassLoader却不需要动一下。这就是devtools重启速度快的原因。</li></ul><p>使用devtools，需要添加其依赖即可 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，<br><code>/META-INF/maven，/META-INF/resources，/resources，/static，/templates，/public</code><br>这些文件夹下的文件修改不会使应用重启，但是会重新加载（devtools内嵌了一个LiveReload server，当资源发生改变时，浏览器刷新）。</p><p>另外，使用Intellij的可能会遇到这个问题，即使项目使用了spring-boot-devtools，修改了类或者html、js等，idea还是不会自动重启，非要手动去make一下或者重启，就更没有使用热部署一样。出现这种情况，并不是你的配置问题，其根本原因是因为Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。</p><p>首先，IDEA设置里面Setting-&gt;Builder,Excution,Deployment-&gt;Compiler的Make project automatically，把这个选项打勾</p><p>然后 Shift+Ctrl+Alt+/(Mac: Shift+Command+Alt+/)，选择Registry<br>把compiler.automake.allow.when.app.running 打勾</p><p>OK了，重启一下项目，然后改一下类里面的内容，IDEA就会自动去make了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;spring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是热部署。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,spring boot,spring-boot-devtools,热部署" scheme="/tags/java-spring-spring-boot-spring-boot-devtools-%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2019/07/08/linux-usefully-command/"/>
    <id>/2019/07/08/linux-usefully-command/</id>
    <published>2019-07-08T07:56:42.097Z</published>
    <updated>2019-12-25T01:14:27.688Z</updated>
    
    <content type="html"><![CDATA[<p>收集平时常用的一些linux命令。<br><a id="more"></a></p><h2 id="ssh几个超时参数"><a href="#ssh几个超时参数" class="headerlink" title="ssh几个超时参数"></a>ssh几个超时参数</h2><h3 id="客户端方案"><a href="#客户端方案" class="headerlink" title="客户端方案"></a>客户端方案</h3><p>Host *<br>    ServerAliveInterval 60</p><h3 id="服务器方案"><a href="#服务器方案" class="headerlink" title="服务器方案"></a>服务器方案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>#ClientAliveInterval 0改为ClientAliveInterval 500     （每500秒往客户端发送会话请求，保持连接）</p><p>#ClientAliveCountMax 3      （去掉注释即可，3表示重连3次失败后，重启SSH会话）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd   <span class="comment">#重启sshd服务</span></span><br></pre></td></tr></table></figure></p><p><a href="http://www.361way.com/ssh-autologout/4679.html" target="_blank" rel="noopener">http://www.361way.com/ssh-autologout/4679.html</a></p><h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  passwd</span><br></pre></td></tr></table></figure><h2 id="查看大文本"><a href="#查看大文本" class="headerlink" title="查看大文本"></a>查看大文本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  more filename</span><br></pre></td></tr></table></figure><h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ more /proc/version</span><br><span class="line">Linux version 3.10.0-514.26.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) ) <span class="comment">#1 SMP Tue Jul 4 15:04:05 UTC 2017</span></span><br><span class="line"></span><br><span class="line">$ more /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.2.1511 (Core)</span><br><span class="line"></span><br><span class="line">$ uname -a</span><br><span class="line">Linux izbp1hsmr9thgc19em3gl8z 3.10.0-514.26.2.el7.x86_64 <span class="comment">#1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://mirrors.163.com/centos/7/os/x86_64/Packages/iptables-1.4.21-33.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">$ vim /etc/sysconfig/iptables-config</span><br><span class="line"></span><br><span class="line">$ systemctl restart iptables</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集平时常用的一些linux命令。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="linux,linux" scheme="/tags/linux-linux/"/>
    
  </entry>
  
  <entry>
    <title>model</title>
    <link href="/2019/07/08/model/"/>
    <id>/2019/07/08/model/</id>
    <published>2019-07-08T07:56:42.097Z</published>
    <updated>2019-07-08T07:56:42.097Z</updated>
    
    <content type="html"><![CDATA[<p>model</p><a id="more"></a><h2 id="后台架构"><a href="#后台架构" class="headerlink" title="后台架构"></a>后台架构</h2><h3 id="数据概述"><a href="#数据概述" class="headerlink" title="数据概述"></a>数据概述</h3><p>今日订单数总数</p><p>今日营业额</p><p>今日ip访问量</p><p>今日新增会员</p><p>今日新增代言人</p><p>今日新增合伙人</p><p>今日新增董事</p><p>今日已发货</p><p>累计营业额</p><p>累计订单数</p><p>累计用户人数</p><p>累计分公司数</p><p>累计董事数</p><p>累计合伙人数</p><p>累计代言人数</p><p>累计用户数</p><p>实时订单地图显示</p><h3 id="订单管理"><a href="#订单管理" class="headerlink" title="订单管理"></a>订单管理</h3><h4 id="待发货"><a href="#待发货" class="headerlink" title="待发货"></a>待发货</h4><p>订单编号</p><p>姓名</p><p>时间</p><p>收货人</p><p>收货电话</p><p>收货地址</p><p>产品名称</p><p>产品数量</p><p>产品型号</p><p>订单留言</p><p>支付方式</p><ul><li><p>支付宝</p></li><li><p>微信支付</p></li><li><p>银联支付</p></li><li><p>预付款支付</p><ul><li>预付款支付不计算业绩</li></ul></li></ul><p>订单处理代理</p><ul><li><p>规则</p><ol><li><p>下级提交上级</p></li><li><p>同级提交上级</p></li><li><p>董事提交公司</p></li><li><p>订单提交第一个预存款级别扣除, 然后订单到仓库</p></li></ol></li></ul><p>预存款扣除金额</p><p>上级处理</p><ul><li><p>未处理</p></li><li><p>已处理</p></li></ul><p>发货状态</p><ul><li>未发货</li></ul><p>物流公司</p><ul><li>无</li></ul><p>快递单号</p><ul><li>无</li></ul><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h4 id="仓库发货订单"><a href="#仓库发货订单" class="headerlink" title="仓库发货订单"></a>仓库发货订单</h4><h4 id="已发货"><a href="#已发货" class="headerlink" title="已发货"></a>已发货</h4><h4 id="已完成订单"><a href="#已完成订单" class="headerlink" title="已完成订单"></a>已完成订单</h4><h4 id="作废订单"><a href="#作废订单" class="headerlink" title="作废订单"></a>作废订单</h4><h4 id="学习订单"><a href="#学习订单" class="headerlink" title="学习订单"></a>学习订单</h4><p>会务费</p><ul><li><p>订单编号</p></li><li><p>姓名</p></li><li><p>时间</p></li><li><p>联系电话</p></li><li><p>产品数量</p></li><li><p>产品型号</p></li><li><p>订单留言</p></li><li><p>支付方式</p><ul><li><p>支付宝</p></li><li><p>微信支付</p></li><li><p>银联支付</p></li></ul></li><li><p>上级名字</p></li><li><p>订单详情</p></li><li><p>会务费</p></li><li><p>课程付费</p></li><li><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul></li></ul><p>课程费</p><ul><li><p>订单编号</p></li><li><p>姓名</p></li><li><p>时间</p></li><li><p>联系电话</p></li><li><p>产品数量</p></li><li><p>产品型号</p></li><li><p>订单留言</p></li><li><p>支付方式</p><ul><li><p>支付宝</p></li><li><p>微信支付</p></li><li><p>银联支付</p></li></ul></li><li><p>上级名字</p></li><li><p>订单详情</p></li><li><p>会务费</p></li><li><p>课程付费</p></li><li><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul></li></ul><h3 id="预存款管理"><a href="#预存款管理" class="headerlink" title="预存款管理"></a>预存款管理</h3><h4 id="预存款审核"><a href="#预存款审核" class="headerlink" title="预存款审核"></a>预存款审核</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>预存款金额</p><p>预存款时间</p><p>公司处理</p><ul><li><p>已处理</p><ul><li>通过审核则计算业绩</li></ul></li><li><p>未处理</p></li></ul><p>公司处理人</p><h4 id="添加预存款"><a href="#添加预存款" class="headerlink" title="添加预存款"></a>添加预存款</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>预存款金额</p><ul><li>添加预存款则计算业绩</li></ul><p>预存款时间</p><p>公司添加人</p><h4 id="预存款消费记录"><a href="#预存款消费记录" class="headerlink" title="预存款消费记录"></a>预存款消费记录</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>预存款金额剩余</p><p>预存款消费记录</p><h3 id="代理管理"><a href="#代理管理" class="headerlink" title="代理管理"></a>代理管理</h3><h4 id="代理管理-1"><a href="#代理管理-1" class="headerlink" title="代理管理"></a>代理管理</h4><h5 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h5><h5 id="备份代理"><a href="#备份代理" class="headerlink" title="备份代理"></a>备份代理</h5><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p>代理级别</p><ul><li><p>代言人</p></li><li><p>合伙人</p></li><li><p>董事</p></li></ul><p>名字/id/电话号码</p><h5 id="代理信息"><a href="#代理信息" class="headerlink" title="代理信息"></a>代理信息</h5><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>钱包</p><ul><li><p>预存款</p><ul><li>购买记录</li></ul></li><li><p>可提现金额</p><ul><li><p>预存款变现</p></li><li><p>营销收入</p></li><li><p>计算方法</p><ol><li><p>有预存款</p><ol><li><p>预存款减去进货金额</p></li><li><p>可提现金额出现支付金额</p></li></ol></li><li><p>没有预存款</p><p> 可提现金额出现支付金额    </p></li></ol></li></ul></li><li><p>营销收入明细</p><ul><li><p>个人销售收入</p><p>  零售价减去进货价</p></li><li><p>代理销售</p><p>  当前级别进货金额减去下级代理进货金额</p></li><li><p>公司返点</p><ul><li><p>返点规则</p><ul><li><p>董事级别</p><ol><li><p>下级董事每销售一盒奖励6元</p></li><li><p>下级董事的下级董事销售一盒奖励6元</p></li><li><p>最多两级董事</p></li><li><p>成为董事业绩断开</p></li></ol></li><li><p>合伙人级别</p><ol><li><p>下级合伙人每销售一盒奖励6元</p></li><li><p>下级合伙人的下级合伙人销售一盒奖励6元</p></li><li><p>最多两级合伙人</p></li><li><p>成为董事业绩断开</p></li><li><p>每位合伙人返点一笔金额则上级董事返点金额里减去相等金额</p></li></ol></li><li><p>代言人没有公司返点</p></li></ul></li></ul></li><li><p>月份收入记录</p></li></ul></li><li><p>提现记录</p></li></ul><p>上级董事</p><p>上级合伙人</p><p>邀请人数</p><p>下级代理树</p><ul><li><p>下级代理/会员列表</p></li><li><p>画出关系树</p></li></ul><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>会员主页</p><ul><li><p>时间</p><ul><li>历史时间</li></ul></li><li><p>BMI</p><ul><li>历史记录</li></ul></li><li><p>体脂率</p><ul><li>历史记录</li></ul></li><li><p>体水分</p><ul><li>历史记录</li></ul></li><li><p>固含量</p><ul><li>历史记录</li></ul></li><li><p>基础代谢</p><ul><li>历史记录</li></ul></li><li><p>内脏脂肪</p><ul><li>历史记录</li></ul></li><li><p>身体年龄</p><ul><li>历史记录</li></ul></li><li><p>蛋白率</p><ul><li>历史记录</li></ul></li><li><p>标准体重</p><ul><li>历史记录</li></ul></li><li><p>脂肪量</p><ul><li>历史记录</li></ul></li><li><p>肌肉量</p><ul><li>历史记录</li></ul></li><li><p>蛋白量</p><ul><li>历史记录</li></ul></li><li><p>肥胖等级</p><ul><li>历史记录</li></ul></li></ul><p>积分</p><p>操作</p><ul><li><p>通过</p></li><li><p>修改</p></li><li><p>删除</p></li></ul><h4 id="代理审核（同上代理信息）"><a href="#代理审核（同上代理信息）" class="headerlink" title="代理审核（同上代理信息）"></a>代理审核（同上代理信息）</h4><h4 id="代理关系"><a href="#代理关系" class="headerlink" title="代理关系"></a>代理关系</h4><p>代理树图</p><h4 id="新晋代理"><a href="#新晋代理" class="headerlink" title="新晋代理"></a>新晋代理</h4><p>新晋统计表格</p><h4 id="代理发展统计"><a href="#代理发展统计" class="headerlink" title="代理发展统计"></a>代理发展统计</h4><p>每月新增代理发展统计曲线图</p><h3 id="分公司管理"><a href="#分公司管理" class="headerlink" title="分公司管理"></a>分公司管理</h3><h4 id="分公司管理-1"><a href="#分公司管理-1" class="headerlink" title="分公司管理"></a>分公司管理</h4><h5 id="添加分公司"><a href="#添加分公司" class="headerlink" title="添加分公司"></a>添加分公司</h5><h5 id="备份分公司"><a href="#备份分公司" class="headerlink" title="备份分公司"></a>备份分公司</h5><h5 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h5><p>代理级别</p><ul><li><p>代言人</p></li><li><p>合伙人</p></li><li><p>董事</p></li></ul><p>名字/id/电话号码</p><h5 id="分公司信息"><a href="#分公司信息" class="headerlink" title="分公司信息"></a>分公司信息</h5><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>钱包</p><ul><li>同前所述</li></ul><p>上级董事</p><p>上级合伙人</p><p>邀请人数</p><p>下级代理树</p><ul><li><p>下级代理/会员列表</p></li><li><p>画出关系树</p></li></ul><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>健康数据</p><ul><li>同前所述</li></ul><h4 id="分公司审核（同上代理信息）"><a href="#分公司审核（同上代理信息）" class="headerlink" title="分公司审核（同上代理信息）"></a>分公司审核（同上代理信息）</h4><h3 id="会员管理"><a href="#会员管理" class="headerlink" title="会员管理"></a>会员管理</h3><p>同前所述 （分公司管理）</p><h3 id="业绩查询"><a href="#业绩查询" class="headerlink" title="业绩查询"></a>业绩查询</h3><h4 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h4><p>时间</p><p>id号</p><p>名字</p><p>电话</p><h4 id="分公司"><a href="#分公司" class="headerlink" title="分公司"></a>分公司</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h4 id="董事"><a href="#董事" class="headerlink" title="董事"></a>董事</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h4 id="合伙人"><a href="#合伙人" class="headerlink" title="合伙人"></a>合伙人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h4 id="代言人"><a href="#代言人" class="headerlink" title="代言人"></a>代言人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级合伙人</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h3 id="商品管理"><a href="#商品管理" class="headerlink" title="商品管理"></a>商品管理</h3><h4 id="商品管理-1"><a href="#商品管理-1" class="headerlink" title="商品管理"></a>商品管理</h4><h5 id="添加商品"><a href="#添加商品" class="headerlink" title="添加商品"></a>添加商品</h5><p>商品名称</p><p>商品规格</p><p>商品型号</p><p>商品图片</p><p>商品详情</p><p>商品属性</p><ul><li><p>正品销售</p></li><li><p>积分兑换</p></li></ul><p>商品价格</p><ul><li><p>统一零售价</p></li><li><p>代言人价格</p></li><li><p>合伙人价格</p></li><li><p>董事价格</p></li></ul><p>是否计算业绩</p><p>是否扫码发货</p><p>是否上架下架</p><h5 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h5><p>商品名称</p><p>商品规格</p><p>商品型号</p><p>商品属性</p><ul><li><p>正品销售</p></li><li><p>积分兑换</p></li></ul><p>商品价格</p><ul><li><p>统一零售价</p></li><li><p>代言人价格</p></li><li><p>合伙人价格</p></li><li><p>董事价格</p></li></ul><p>是否计算业绩</p><p>是否扫码发货</p><p>是否上架下架</p><p>库存数量</p><ul><li>不可修改</li></ul><p>操作</p><ul><li><p>删除</p></li><li><p>修改</p></li></ul><h4 id="库存管理"><a href="#库存管理" class="headerlink" title="库存管理"></a>库存管理</h4><h5 id="商品列表-1"><a href="#商品列表-1" class="headerlink" title="商品列表"></a>商品列表</h5><p>商品名称</p><p>商品规格</p><p>商品型号</p><p>商品价格</p><ul><li><p>统一零售价</p></li><li><p>代言人价格</p></li><li><p>合伙人价格</p></li><li><p>董事价格</p></li></ul><p>是否计算业绩</p><p>是否扫码发货</p><p>是否上架下架</p><p>库存数量</p><p>入库</p><h5 id="出库发货记录"><a href="#出库发货记录" class="headerlink" title="出库发货记录"></a>出库发货记录</h5><p>每日订单发货详情</p><h3 id="素材管理"><a href="#素材管理" class="headerlink" title="素材管理"></a>素材管理</h3><h4 id="商学院"><a href="#商学院" class="headerlink" title="商学院"></a>商学院</h4><h5 id="添加素材"><a href="#添加素材" class="headerlink" title="添加素材"></a>添加素材</h5><ul><li><p>添加素材</p><ul><li><p>音频</p><ul><li><p>图文标题</p></li><li><p>作者</p></li><li><p>图文封面</p><ul><li>上传图片</li></ul></li><li><p>简介</p></li><li><p>销售模式</p><ul><li><p>作为单篇销售</p><ul><li>价格：</li></ul></li><li><p>作为专栏内内容</p><ul><li>选择专栏</li></ul></li><li><p>代理专项</p><ul><li><p>董事</p></li><li><p>合伙人</p></li><li><p>代言人</p></li></ul></li></ul></li><li><p>是否上架</p></li><li><p>完整音频</p></li><li><p>图文详情</p></li></ul></li><li><p>视频</p><ul><li><p>图文标题</p></li><li><p>作者</p></li><li><p>图文封面</p><ul><li>上传图片</li></ul></li><li><p>简介</p></li><li><p>销售模式</p><ul><li><p>作为单篇销售</p><ul><li>价格：</li></ul></li><li><p>作为专栏内内容</p><ul><li>选择专栏</li></ul></li><li><p>代理专项</p><ul><li><p>董事</p></li><li><p>合伙人</p></li><li><p>代言人</p></li></ul></li></ul></li><li><p>是否上架</p></li><li><p>完整视频</p></li><li><p>图文详情</p></li></ul></li></ul></li></ul><ul><li><p>添加专栏</p><ul><li><p>专栏名称</p></li><li><p>作者</p></li><li><p>专栏封面</p></li><li><p>专栏介绍</p></li><li><p>价格</p></li><li><p>专栏详情介绍</p></li></ul></li></ul><h5 id="素材列表"><a href="#素材列表" class="headerlink" title="素材列表"></a>素材列表</h5><ul><li><p>内容列表</p><ul><li><p>内容名称</p></li><li><p>销售数量</p></li><li><p>状态</p><ul><li><p>已上架</p></li><li><p>未上架</p></li></ul></li><li><p>上架时间</p></li><li><p>操作</p><ul><li><p>编辑</p></li><li><p>删除</p></li></ul></li></ul></li><li><p>专栏列表</p><ul><li><p>专栏名称</p></li><li><p>已更新篇数</p></li><li><p>销售数量</p></li><li><p>状态</p><ul><li><p>已上架</p></li><li><p>未上架</p></li></ul></li><li><p>上架时间</p></li><li><p>操作</p><ul><li><p>编辑</p></li><li><p>删除</p></li></ul></li></ul></li></ul><h4 id="一键转发朋友圈素材"><a href="#一键转发朋友圈素材" class="headerlink" title="一键转发朋友圈素材"></a>一键转发朋友圈素材</h4><h5 id="添加素材-1"><a href="#添加素材-1" class="headerlink" title="添加素材"></a>添加素材</h5><p>日期</p><p>文字</p><p>图片或视频</p><h5 id="历史素材列表"><a href="#历史素材列表" class="headerlink" title="历史素材列表"></a>历史素材列表</h5><p>搜索</p><ul><li>按日期</li></ul><p>日期</p><p>文字</p><p>图片或视频</p><p>操作</p><ul><li><p>删除</p></li><li><p>修改</p></li></ul><h5 id="晒场"><a href="#晒场" class="headerlink" title="晒场"></a>晒场</h5><p>搜索</p><ul><li><p>id</p></li><li><p>姓名</p></li><li><p>电话</p></li></ul><p>列表</p><ul><li><p>id</p></li><li><p>姓名</p></li><li><p>电话</p></li><li><p>粉丝</p></li><li><p>关注</p></li><li><p>评论</p></li><li><p>帖子内容</p></li><li><p>会员主页</p><ul><li>同前所述</li></ul></li><li><p>推荐精选</p><ul><li><p>推荐</p></li><li><p>正常</p></li></ul></li><li><p>状态</p><ul><li><p>正常</p></li><li><p>举报</p></li></ul></li><li><p>操作</p><ul><li><p>删除</p></li><li><p>操作</p><ul><li>是否推荐精选</li></ul></li><li><p>正常</p></li></ul></li></ul><p>精选</p><ul><li><p>精选列表</p><ul><li>同前列表所述</li></ul></li></ul><p>口碑</p><ul><li><p>口碑列表</p><ul><li>同前列表所述</li></ul></li></ul><p>举报</p><ul><li><p>精选列表</p><ul><li>同前列表所述</li></ul></li></ul><h3 id="积分管理"><a href="#积分管理" class="headerlink" title="积分管理"></a>积分管理</h3><h4 id="积分获得记录"><a href="#积分获得记录" class="headerlink" title="积分获得记录"></a>积分获得记录</h4><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>上级董事</p><p>上级合伙人</p><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>邀请人数积分</p><p>上称次数积分</p><p>购买商品获积分</p><p>获积分赏</p><p>积分</p><ul><li><p>获积分规则</p><ul><li><p>上称获积分</p></li><li><p>分享链接推荐新人注册获积分</p></li><li><p>积分打赏获积分</p></li></ul></li></ul><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h4 id="积分兑换记录"><a href="#积分兑换记录" class="headerlink" title="积分兑换记录"></a>积分兑换记录</h4><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>上级董事</p><p>上级合伙人</p><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>打赏积分使用记录</p><p>兑换商品记录</p><p>积分结余</p><ul><li><p>获积分规则</p><ul><li><p>上称获积分</p></li><li><p>分享链接推荐新人注册获积分</p></li><li><p>积分打赏获积分</p></li></ul></li></ul><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h3 id="财务管理"><a href="#财务管理" class="headerlink" title="财务管理"></a>财务管理</h3><h4 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h4><p>月度营业额</p><ul><li>详情</li></ul><p>月度订单数</p><ul><li>详情</li></ul><p>月度可提现</p><ul><li>详情</li></ul><p>月度已打款</p><ul><li>详情</li></ul><p>月度盈利</p><ul><li>详情</li></ul><h4 id="搜索查找-1"><a href="#搜索查找-1" class="headerlink" title="搜索查找"></a>搜索查找</h4><p>时间</p><p>id号</p><p>名字</p><p>电话</p><h4 id="分公司-1"><a href="#分公司-1" class="headerlink" title="分公司"></a>分公司</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改</li></ul><h4 id="董事-1"><a href="#董事-1" class="headerlink" title="董事"></a>董事</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改</li></ul><h4 id="合伙人-1"><a href="#合伙人-1" class="headerlink" title="合伙人"></a>合伙人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改修改</li></ul><h4 id="代言人-1"><a href="#代言人-1" class="headerlink" title="代言人"></a>代言人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改</li></ul><h3 id="管理员管理"><a href="#管理员管理" class="headerlink" title="管理员管理"></a>管理员管理</h3><h4 id="添加管理员"><a href="#添加管理员" class="headerlink" title="添加管理员"></a>添加管理员</h4><p>姓名</p><p>电话</p><p>身份证号码</p><p>职位</p><p>登陆账号</p><p>登陆密码</p><p>使用权限</p><h4 id="管理员列表"><a href="#管理员列表" class="headerlink" title="管理员列表"></a>管理员列表</h4><p>姓名</p><p>电话</p><p>职位</p><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h3 id="商品防伪"><a href="#商品防伪" class="headerlink" title="商品防伪"></a>商品防伪</h3><h4 id="防伪码生成"><a href="#防伪码生成" class="headerlink" title="防伪码生成"></a>防伪码生成</h4><h5 id="导出唯一防伪码"><a href="#导出唯一防伪码" class="headerlink" title="导出唯一防伪码"></a>导出唯一防伪码</h5><p>一大箱一个大码</p><ul><li>大编码下面N个小编码</li></ul><h4 id="已经入库编码"><a href="#已经入库编码" class="headerlink" title="已经入库编码"></a>已经入库编码</h4><p>扫码入库</p><h4 id="未出库编码"><a href="#未出库编码" class="headerlink" title="未出库编码"></a>未出库编码</h4><p>扫码出库</p><h3 id="投诉建议"><a href="#投诉建议" class="headerlink" title="投诉建议"></a>投诉建议</h3><p>会员投诉</p><p>代理投诉</p><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><h4 id="积分设置"><a href="#积分设置" class="headerlink" title="积分设置"></a>积分设置</h4><p>上称一次获积分</p><p>消费1元获积分</p><p>打赏获积分</p><p>分享链接获积分</p><h4 id="代理返利设置"><a href="#代理返利设置" class="headerlink" title="代理返利设置"></a>代理返利设置</h4><p>分公司奖励</p><p>董事平级奖励</p><h4 id="升级门槛设置（千元）"><a href="#升级门槛设置（千元）" class="headerlink" title="升级门槛设置（千元）"></a>升级门槛设置（千元）</h4><p>分公司</p><ul><li>400k</li></ul><p>董事</p><ul><li>54k</li></ul><p>合伙人</p><ul><li>9k</li></ul><p>代言人</p><ul><li>1.28k</li></ul><h4 id="代理证书设置"><a href="#代理证书设置" class="headerlink" title="代理证书设置"></a>代理证书设置</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;model&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="model" scheme="/tags/model/"/>
    
  </entry>
  
  <entry>
    <title>JVM，JRE和JDK</title>
    <link href="/2019/07/08/jvm-jre-jdk/"/>
    <id>/2019/07/08/jvm-jre-jdk/</id>
    <published>2019-07-08T07:56:42.082Z</published>
    <updated>2019-07-08T07:56:42.082Z</updated>
    
    <content type="html"><![CDATA[<p>不要只从编程语言的角度来看Java，这只会看到“冰山一角”<br><a id="more"></a></p><p>这可以用Java SE Technologies中的图来印证： </p><p><img src="/gallery/java-se-platform.jpg" alt="Java SE platform" title="Java SE platform"></p><p>如果你安装JDK，就会安装这全部的东西，而Java Language只是最左上角一小部份。 </p><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p>在上图中，Platforms表示Solaris、Linux、Windows各种作业系统平台，在这些平台上架构了Java虚拟机，也就是JVM，JVM让Java可以跨平台，但是跨平台是怎么一回事？在这之前，你得先了解不能跨平台是怎么一回事。 </p><p>对于电脑而言，只认识一种语言，也就是0、1序列组成的机器指令。 当你使用C/C++等高阶语言编写程序时，其实这些语言，是比较贴近人类可阅读的文法，也就是比较接近英语文法的语言。 这是为了方便人类阅读及编写，电脑其实看不懂C/C++这类语言，为了将C/C++翻译为0、1序列组成的机器指令，你必须有个翻译员，担任翻译员工作的就是编译器（Compiler）。 </p><p>问题在于，每个平台认识的0、1序列并不一样。 某个指令在Windows上也许是0101，在Linux下也许是1010，因此必须使用不同的编译器为不同平台编译出可执行的机器码，在Windows平台上编译好的程序，不能直接拿到Linux等其它平台执行，也就是说，你的应用程序无法达到「编译一次，到处执行」的跨平台目的。 </p><p>Java是个高级语言，要让电脑执行你编写的程序，也得通过编译器的翻译。 不过Java在编译时，并不直接编译为相依于某平台的0、1序列，而是翻译为中介格式的字节码（Byte code）。 </p><p>Java源码扩展名为<em>.java ，经过编译器翻译后为扩展名</em>.class的字节码。 如果想要执行字节码文件，目标平台必须安装JVM（Java Virtual Machine）。 JVM会将字节码翻译为相应平台的机器码。 </p><p>不同的平台必须安装专属该平台的JVM。 这就好比你讲中文（<em>.java），Java编译器帮你翻译为英语（</em>.class），之后这份英语文件，到各国家之后，再由当地看得懂英文的人（JVM）翻译为当地语言（机器码）。 </p><p>所以 <strong>JVM担任的职责之一就是当地翻译员，将字节码文档翻译为当前平台看得懂的0、1序列，有了JVM，你的Java程序就可以达到「编译一次，到处到处执行」的跨平台目的</strong>。 除了了解JVM具有让Java程序跨平台的重要任务之外，编写Java程序时，对JVM的重要认知就是： </p><p>对Java程序而言，只认识一种作业系统，这个系统叫JVM，字节码文件（扩展名为.class的文件）就是JVM的可执行文件。 </p><p>Java程序理想上，并不用理会真正执行于哪个平台，只要知道如何执行于JVM就可以了，至于JVM实际上如何与底层平台作沟通，则是JVM自己的事！ 由于JVM实际上就相当于Java程序的作业系统，JVM就负责了Java程序的各种资源管理。 </p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>之后会学到的第一个Java程序，其中会有这么一段程序码： </p><p>System.out.println(“Hello World”);</p><p>先前曾经谈过，Java是个标准，System、out、println这些名称，都是标准中所规范的名称，实际上必须要有人根据标准编写出System.java，编译为System.class，如此你才能在编写第一个Java程序时，使用System类别（Class）上out物件（Object）的println()方法（Method）。 </p><p>谁来实现System.java？ 谁来编译为.class？ 可能是Oracle、IBM、Apache，无论如何，这些厂商必须根据相关的JSR标准文件，将标准程序库实现出来，如此你编写的第一个Java程序，在Oracle、IBM、Apache等厂商实现的JVM上运行时，引用如System这些标准API，你的第一个Java程序，才可能轻易地运行在不同的平台。 </p><p>在上图中右边可以看到Java SE API ，涵盖了各式常用的程序库，像是通用的群集（Collection）、输入输出、连接数据库的JDBC、编写窗口程序的AWT与Swing等，这些都是在各个JSR标准文件规范之中， </p><p><strong>Java Runtime Environment就是Java执行环境，简称JRE， 包括了Java SE API与JVM</strong>。只要你使用Java SE API中的程序库，在安装有JRE的电脑上就可以直接运行，无需额外在你的程序中再包装标准程序库，而可以由JRE直接提供。 </p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>先前说过，你要在.java中编写Java程序语言，使用编译器编译为.class文档，那么像编译器这样的工具程序是由谁提供？ 答案就是JDK，全名为Java Developer Killer ！ 呃！ 不对！ 是Java Development Kit ！</p><p>正如上图所示，JDK包括了javac、appletviewer、javadoc等工具程序，对于要开发Java程序的人，必须安装的是JDK，如此才有这些工具程序可以使用，JDK本身包括了JRE，如此你才能执行Java程序，所以总结就是 <strong>JDK包括了Java程序语言、工具程序与JRE，JRE则包括了部署技术、Java SE API与JVM</strong> 。</p><p>编写Java程序的人才需要JDK，如果你的程序只是想让朋友执行呢？ 那他只要装JRE就可以了，不用安装JDK，因为他不需要javac这些工具程序，但他需要Java SE API与JVM。</p><p>对初学者来说，JDK确实很不友善，这大概是Java阵营的哲学，假设你懂得如何准备相关开发环境，因此装好JDK之后，该自己设定的变数或选项就要自己设定，JDK不会代劳，过去戏称JDK全名为Java Developer Killer其实是其来于这。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要只从编程语言的角度来看Java，这只会看到“冰山一角”&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="JVM,JRE, JDK,javv虚拟面,java运行时环境,java开发工具包" scheme="/tags/JVM-JRE-JDK-javv%E8%99%9A%E6%8B%9F%E9%9D%A2-java%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83-java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="/2019/07/08/git-usefully-command/"/>
    <id>/2019/07/08/git-usefully-command/</id>
    <published>2019-07-08T07:56:42.082Z</published>
    <updated>2019-07-31T01:58:59.148Z</updated>
    
    <content type="html"><![CDATA[<p>收集平时常用的一些maven命令。<br><a id="more"></a></p><h2 id="打标签并推送到远程"><a href="#打标签并推送到远程" class="headerlink" title="打标签并推送到远程"></a>打标签并推送到远程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于当前节点打tag</span></span><br><span class="line"></span><br><span class="line">git tag -a v0.9.0.RELEASE -m <span class="string">'接手之前的版本'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指琮前节点打tag</span></span><br><span class="line"></span><br><span class="line">git tag -a v0.9.0.RELEASE -m <span class="string">'接手之前的版本'</span> 033133b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示tag内容</span></span><br><span class="line">git show v0.9.0.RELEASE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送tag到远程</span></span><br><span class="line">git push origin v0.9.0.RELEASE</span><br></pre></td></tr></table></figure><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>git revert <commit> …对所有n个提交做回滚，然后push到远程，保留了修改历史记录。</commit></p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p> git reset –hard HEAD~n 重设到指定分支，若push到远程，可能被阻止，可以使用git push -f 强制更新。</p><h2 id="回滚远程提交"><a href="#回滚远程提交" class="headerlink" title="回滚远程提交"></a>回滚远程提交</h2><h3 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h3><p>git revert <commit> …对所有n个提交做回滚，然后push到远程，保留了修改历史记录。</commit></p><h3 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h3><p> git reset –hard HEAD~n 重设到指定分支，若push到远程，可能被阻止，可以使用git push -f 强制更新。</p><h2 id="git-clone查定分支和目录"><a href="#git-clone查定分支和目录" class="headerlink" title="git clone查定分支和目录"></a>git clone查定分支和目录</h2><p>$ git clone<br>will give you the whole repository.</p><p>After the clone, you can list the tags with $ git tag -l and then checkout a specific tag:</p><p>$ git checkout tags/<tag_name><br>Even better, checkout and create a branch (otherwise you will be on a branch named after the revision number of tag):</tag_name></p><p>$ git checkout tags/<tag_name> -b <branch_name></branch_name></tag_name></p><h2 id="查看远程地址"><a href="#查看远程地址" class="headerlink" title="查看远程地址"></a>查看远程地址</h2><p>查看全名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>短名方式查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h2 id="创建临时版本"><a href="#创建临时版本" class="headerlink" title="创建临时版本"></a>创建临时版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev20170803</span><br></pre></td></tr></table></figure><h2 id="git-bash连接linux"><a href="#git-bash连接linux" class="headerlink" title="git bash连接linux"></a>git bash连接linux</h2><ol><li>linux上执行，ssh-keygen 生成公私钥对</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"><span class="comment"># 据提示输入文件名称，如id_rsa.trainmall</span></span><br></pre></td></tr></table></figure><ol><li>公钥添加到authorized_keys</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><ol><li>修改配置文件允许使用秘钥登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>PubkeyAuthentication yes<br>AuthorizedKeysFile      .ssh/authorized_keys<br>PasswordAuthentication yes</p><ol><li><p>重启ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>复制linux服务器上的私钥到本地机</p></li></ol><p>scp root@192.168.1.168:/root/.ssh/id_rsa ~/.ssh</p><ol><li><p>需要本地配置多个ssh，则要进行config配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加以下配置</span></span><br><span class="line"><span class="comment"># trainmall</span></span><br><span class="line">Host trainmall</span><br><span class="line">Hostname 47.96.102.25</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa.trainmall</span><br><span class="line">User jesshaw@126.com</span><br></pre></td></tr></table></figure></li><li><p>测试是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@trainmall</span><br></pre></td></tr></table></figure></li></ol><h2 id="管理git生成的多个ssh-key"><a href="#管理git生成的多个ssh-key" class="headerlink" title="管理git生成的多个ssh key"></a>管理git生成的多个ssh key</h2><ol><li><p>生成公私钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"jeshaw@lexiangmiao.com"</span></span><br><span class="line"><span class="comment"># 根据提示输入文件名称，如id_rsa.lexiangmiao</span></span><br></pre></td></tr></table></figure></li><li><p>添加公钥到需要上传的代码网站</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.lexiangmiao.pub</span><br></pre></td></tr></table></figure><ol><li><p>配置config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br><span class="line"></span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host mygithub github.com</span><br><span class="line">Hostname github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa.github</span><br><span class="line">User jesshaw@lexiangmiao.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># lexiangmiao</span></span><br><span class="line">Host code.lexiangmiao.com</span><br><span class="line">Hostname code.lexiangmiao.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa.lexiangmiao</span><br><span class="line">User jesshaw@lexiangmiao.com</span><br></pre></td></tr></table></figure></li><li><p>添加私钥到本地</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先要启动ssh-agent才能添加</span></span><br><span class="line"><span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line"></span><br><span class="line">ssh-add ~/.ssh/id_rsa.lexiangmiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除私钥 hostname配置在config中</span></span><br><span class="line">ssh-keygen -R hostname</span><br></pre></td></tr></table></figure><ol><li><p>测试是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#调试方式查看是否成功</span></span><br><span class="line">ssh -vT git@code.lexiangmiao.com</span><br></pre></td></tr></table></figure></li><li><p>配置当前库的用户和邮箱</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"Firstname Lastname"</span></span><br><span class="line">git config user.email <span class="string">"your_email@example.com"</span></span><br><span class="line">git config --<span class="built_in">local</span> -l</span><br><span class="line"><span class="comment"># 查看全局配置</span></span><br><span class="line">git config --global -l</span><br></pre></td></tr></table></figure><ol><li>配置新的url<br>git remote set-url origin git@github.com-worker_user1:worker_user1/repo_name.git</li></ol><h2 id="拉不到代码，原因是因为不是以管理方式运行的git-bash"><a href="#拉不到代码，原因是因为不是以管理方式运行的git-bash" class="headerlink" title="拉不到代码，原因是因为不是以管理方式运行的git bash"></a>拉不到代码，原因是因为不是以管理方式运行的git bash</h2><p>git@git.dev.sh.ctripcorp.com: Permission denied (ssh key error).<br>fatal: Could not read from remote repository.</p><p>Please make sure you have the correct access rights<br>and the repository exists.</p><h2 id="改用https方式作为库地址时，保留输入用户名和密码"><a href="#改用https方式作为库地址时，保留输入用户名和密码" class="headerlink" title="改用https方式作为库地址时，保留输入用户名和密码"></a>改用https方式作为库地址时，保留输入用户名和密码</h2><p>git config –global credential.helper store</p><h2 id="箭头键不能工作"><a href="#箭头键不能工作" class="headerlink" title="箭头键不能工作"></a>箭头键不能工作</h2><p>经常碰到在bash中执行命名后需要使用上下箭头键来完成选择，但是偏偏在win7中不能使用。(当然换到cmd中是可以的，不使用此方式的原因你懂的)</p><p>实际上我们是实现选择的工作，虽然体验上是差了一些，但以下方法是行的</p><p>即使用输入”数字+回车”实现选择的功能，如下示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yo generate</span><br><span class="line">what would you like to <span class="keyword">do</span>? (Use arrow keys)</span><br><span class="line">Run a generator</span><br><span class="line">Bootstrap</span><br><span class="line">Loopback</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">## 输入2+回车即选择了Bootstrap</span></span><br></pre></td></tr></table></figure></p><h2 id="设置提交的用户名和邮箱"><a href="#设置提交的用户名和邮箱" class="headerlink" title="设置提交的用户名和邮箱"></a>设置提交的用户名和邮箱</h2><h5 id="列出所有配置"><a href="#列出所有配置" class="headerlink" title="列出所有配置"></a>列出所有配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config [--<span class="built_in">local</span>|--global|--system] -l</span><br></pre></td></tr></table></figure><h5 id="设置某个配置项的值"><a href="#设置某个配置项的值" class="headerlink" title="设置某个配置项的值"></a>设置某个配置项的值</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config [--<span class="built_in">local</span>|--global|--system] section.key value</span><br><span class="line"></span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">"lexiangmiao"</span></span><br></pre></td></tr></table></figure><h5 id="查看某项的当前值"><a href="#查看某项的当前值" class="headerlink" title="查看某项的当前值"></a>查看某项的当前值</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config name</span><br><span class="line"></span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>回滚前两次提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~2</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>push之后会增加一条revert “引用上一次提交的备注”的提交记录</p><h2 id="获取分支"><a href="#获取分支" class="headerlink" title="获取分支"></a>获取分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev.0.1 origin/dev.0.1 </span><br><span class="line">$ git checkout dev.0.1</span><br></pre></td></tr></table></figure><h2 id="以ssh方式复制项目（不需要输入帐户）"><a href="#以ssh方式复制项目（不需要输入帐户）" class="headerlink" title="以ssh方式复制项目（不需要输入帐户）"></a>以ssh方式复制项目（不需要输入帐户）</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:jesshaw/node-sample-project.git</span><br></pre></td></tr></table></figure><h2 id="日志输出更友好"><a href="#日志输出更友好" class="headerlink" title="日志输出更友好"></a>日志输出更友好</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</span><br><span class="line">$ git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%C(bold cyan)%h%C(reset) -%C(yellow)%d%C(reset) %s %C(green)(%cr) %C(bold magenta)&lt;%an&gt;%C(reset)' --abbrev-commit"</span></span><br><span class="line">$ git config --global alias.lgl <span class="string">"log --color --graph --pretty=format:'%C(bold cyan)%h%C(reset) -%C(yellow)%d%C(reset) %s %C(green)(%ci) %C(bold magenta)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">$ git config --global --<span class="built_in">unset</span> alias.lg</span><br><span class="line">$ git config --global --<span class="built_in">unset</span> alias.lgl</span><br></pre></td></tr></table></figure><h2 id="怎样移除远程的提交日志"><a href="#怎样移除远程的提交日志" class="headerlink" title="怎样移除远程的提交日志"></a>怎样移除远程的提交日志</h2><h5 id="示例数据如下"><a href="#示例数据如下" class="headerlink" title="示例数据如下"></a>示例数据如下</h5><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git lg -5</span><br><span class="line">* 728e3ed - (HEAD -&gt; master, origin/master, origin/HEAD) test4 (26 minutes ago) &lt;ximing&gt;</span><br><span class="line">* c8f834f - (mywork) test3 (19 hours ago) &lt;ximing&gt;</span><br><span class="line">* 3992e9c - test2 (19 hours ago) &lt;ximing&gt;</span><br><span class="line">* abbe339 - test1 (19 hours ago) &lt;ximing&gt;</span><br><span class="line">* 2936159 - add bookmark (21 hours ago) &lt;ximing&gt;</span><br></pre></td></tr></table></figure></code></pre><h5 id="方法1-2"><a href="#方法1-2" class="headerlink" title="方法1"></a>方法1</h5><p>移除c8f834f之后的提交历史</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3992e9c</span><br><span class="line">$ git push origin -f  master</span><br></pre></td></tr></table></figure></code></pre><h5 id="方法2-2"><a href="#方法2-2" class="headerlink" title="方法2"></a>方法2</h5><ol><li><p>仅移除abbe339的提交，其他保留</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i 2936159</span><br><span class="line">error: could not apply 3992e9c... test2</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run <span class="string">"git rebase --continue"</span>.</span><br><span class="line">If you prefer to skip this patch, run <span class="string">"git rebase --skip"</span> instead.</span><br><span class="line">To check out the original branch and stop rebasing, run <span class="string">"git rebase --abort"</span>.</span><br><span class="line">Could not apply 3992e9c9ac3a6e6bb64e0876dace165980990b45... test2</span><br></pre></td></tr></table></figure></li><li><p>此时应当解决冲突，然后多次执行以下命令直至没有error: could not apply 3992e9c… test2此类错误为止</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git add -A </span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li><li><p>提交到远程</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> push origin +master</span><br></pre></td></tr></table></figure></li></ol><h2 id="清除远程上某个文件的所有提交日志"><a href="#清除远程上某个文件的所有提交日志" class="headerlink" title="清除远程上某个文件的所有提交日志"></a>清除远程上某个文件的所有提交日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> current directory</span><br><span class="line">$ git filter-branch --force --index-filter <span class="string">'git rm --cached --ignore-unmatch 文件名'</span> --prune-empty --tag-name-filter cat -- --all</span><br><span class="line">$ git push origin master --force</span><br><span class="line">$ rm -rf .git/refs/original/</span><br><span class="line">$ git reflog expire --expire=now --all</span><br><span class="line">$ git gc --prune=now</span><br><span class="line">$ git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure><h2 id="提交所有更改的文件"><a href="#提交所有更改的文件" class="headerlink" title="提交所有更改的文件"></a>提交所有更改的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">"提交备注"</span></span><br></pre></td></tr></table></figure><h2 id="取消远程某次或某几次提交-远程日志保留"><a href="#取消远程某次或某几次提交-远程日志保留" class="headerlink" title="取消远程某次或某几次提交(远程日志保留)"></a>取消远程某次或某几次提交(远程日志保留)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git revert --no-commit b49eb8e 1d8b062</span><br><span class="line"><span class="comment">## 解决冲突后提交</span></span><br><span class="line">$ git commit -a -m <span class="string">"Revert commits b49eb8e and 1d8b062"</span></span><br></pre></td></tr></table></figure><h2 id="取消本地文件修改"><a href="#取消本地文件修改" class="headerlink" title="取消本地文件修改"></a>取消本地文件修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout file1.js file2.js</span><br></pre></td></tr></table></figure><h2 id="选择某个（dev1）分支上指定的提交合并到其他（bugfix）分支"><a href="#选择某个（dev1）分支上指定的提交合并到其他（bugfix）分支" class="headerlink" title="选择某个（dev1）分支上指定的提交合并到其他（bugfix）分支"></a>选择某个（dev1）分支上指定的提交合并到其他（bugfix）分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev1</span><br><span class="line">$ git rebase -i bugfix <span class="comment">#基于bugfix，列出提交的记录，选择需要的提交执行。有时需要解决冲突</span></span><br><span class="line">$ git checkout bugfix</span><br><span class="line">$ git merge dev1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集平时常用的一些maven命令。&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="/categories/git/"/>
    
    
      <category term="git,git命令" scheme="/tags/git-git%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="/2019/07/08/docker-usefully-command/"/>
    <id>/2019/07/08/docker-usefully-command/</id>
    <published>2019-07-08T07:56:42.066Z</published>
    <updated>2020-01-13T07:49:36.866Z</updated>
    
    <content type="html"><![CDATA[<p>收集平时常用的一些docker命令。<br><a id="more"></a></p><p>###<br>docker build src/main/docker -t trainmall:v3 </p><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull</span><br></pre></td></tr></table></figure><h5 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build</span><br></pre></td></tr></table></figure><h5 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h5 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><h5 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 1adbdsaf</span><br></pre></td></tr></table></figure><h5 id="删除所有已出的容器"><a href="#删除所有已出的容器" class="headerlink" title="删除所有已出的容器"></a>删除所有已出的容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi `docker ps -a | grep  <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br></pre></td></tr></table></figure><h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 1232a</span><br></pre></td></tr></table></figure><h5 id="删除所有none镜像"><a href="#删除所有none镜像" class="headerlink" title="删除所有none镜像"></a>删除所有none镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi `docker images | grep  <span class="string">"&lt;none&gt;"</span> | awk <span class="string">'&#123;print $3&#125;'</span>`</span><br></pre></td></tr></table></figure><h5 id="在host和container之间拷贝文件"><a href="#在host和container之间拷贝文件" class="headerlink" title="在host和container之间拷贝文件"></a>在host和container之间拷贝文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp</span><br><span class="line"></span><br><span class="line">docker cp &lt;containerId&gt;:/file/path/within/container /host/path/targe</span><br></pre></td></tr></table></figure><h5 id="保存改动为新的镜像"><a href="#保存改动为新的镜像" class="headerlink" title="保存改动为新的镜像"></a>保存改动为新的镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit</span><br></pre></td></tr></table></figure><h5 id="进行docker容器"><a href="#进行docker容器" class="headerlink" title="进行docker容器"></a>进行docker容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it [container id] bash</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it [container id] /bin/sh</span><br></pre></td></tr></table></figure><h5 id="启动docker的jenkins时给jenkins授权-1000-1000为jenkins用户和用户组"><a href="#启动docker的jenkins时给jenkins授权-1000-1000为jenkins用户和用户组" class="headerlink" title="启动docker的jenkins时给jenkins授权,1000:1000为jenkins用户和用户组"></a>启动docker的jenkins时给jenkins授权,1000:1000为jenkins用户和用户组</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R 1000:1000 /home/docker/jenkins</span><br></pre></td></tr></table></figure><h5 id="配置客户端访问私有仓库"><a href="#配置客户端访问私有仓库" class="headerlink" title="配置客户端访问私有仓库"></a>配置客户端访问私有仓库</h5><ol><li>vim /etc/docker/daemon.json 增加以下接点</li></ol><p>“insecure-registries” : [“47.100.28.49:5000”]</p><ol><li><p>sudo systemctl daemon-reload</p></li><li><p>sudo systemctl restart docker</p></li><li><p>验证</p></li></ol><p>docker login -u jes -p jes1@lexiangmiao.com 47.100.28.49:5000</p><h5 id="登录拉取私有库数据，并启动"><a href="#登录拉取私有库数据，并启动" class="headerlink" title="登录拉取私有库数据，并启动"></a>登录拉取私有库数据，并启动</h5><p>docker login -u jes -p jes1@lexiangmiao.com localhost:5000</p><p>docker pull localhost:5000/jesshaw/retail:lastest</p><p>docker-componse -f retail.yml up -d</p><p>retail.yml</p><p>version: ‘2’<br>services:<br>    retail-app:<br>        image: localhost:5000/jesshaw/retail:latest<br>        environment:</p><pre><code>    - _JAVA_OPTIONS=-Xmx512m -Xms256m    - SPRING_PROFILES_ACTIVE=prod,swagger    - SPRING_DATASOURCE_URL=jdbc:mysql://lxm-mysql:3306/retail?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false    - JHIPSTER_SLEEP=10 # gives time for the database to boot before the applicationports:    - 8090:8080</code></pre><ol><li>shell启用 retail</li></ol><p>start-retail</p><p>start.sh</p><p>chmod 777  start.sh</p><p>#!/bin/sh</p><p>echo “—————remove images—————————-“<br>docker-compose down<br>echo “—————remove sucess —————————“</p><p>echo “—————remove images—————————-“<br>sudo docker rmi -f  localhost:5000/jesshaw/retail<br>echo “—————remove sucess —————————“</p><p>echo “—————login localhost registry————–”<br>sudo docker login -u jes -p jes1@lexiangmiao.com localhost:5000<br>echo “—————login sucess ————————–”</p><p>echo “—————pull images—————————-“<br>sudo docker pull localhost:5000/jesshaw/retail<br>echo “—————pull sucess —————————“</p><p>echo “—————–start api start———————“<br>docker-compose up -d<br>echo “—————–start api end———————“</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集平时常用的一些docker命令。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="/categories/docker/"/>
    
    
      <category term="docker,docker命令" scheme="/tags/docker-docker%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下安装Docker</title>
    <link href="/2019/07/08/docker-install/"/>
    <id>/2019/07/08/docker-install/</id>
    <published>2019-07-08T07:56:42.066Z</published>
    <updated>2019-07-08T07:56:42.066Z</updated>
    
    <content type="html"><![CDATA[<p>Docker意为搬运工人。负责将开发出来的代码部署到指定的系统环境当中。相对于原始的手动或虚拟机部署，Docker极大的提高了生产效率。</p><a id="more"></a><h2 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h2><p>Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！</p><p>无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，用以提高生产效率，节约有限的生命。</p><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>Docker有两个版本，分别是社区版本：Community Edition (CE)和企业版本：Enterprise Edition (EE)。一般使用CE版。</li><li>CE版本仅支持64位系统。</li><li>Docker安装方式有很多种，因为线路原因，综合考虑使用从安装包安装的方式。</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1 下载stable版本的包 </p><p>到<a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/" target="_blank" rel="noopener">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a> 下载需要装的版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/package.rpm</span><br></pre></td></tr></table></figure></p><p>注意: 如要下载edge包，则需要改变路径。stable版每季度发版一次，提供4个月的支持。<br>edge版每月发版一次，仅当月提供支持。</p><p>2 安装Docker CE  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install /path/to/package.rpm</span><br></pre></td></tr></table></figure><p>3 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>4 验证</p><p>通过运行hell-world镜像，验证是否安装正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="Docker国内镜像配置"><a href="#Docker国内镜像配置" class="headerlink" title="Docker国内镜像配置"></a>Docker国内镜像配置</h2><p>由于种种原因，下载镜像会很慢，配置国内镜像是明智选择。</p><p>1 停止docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br></pre></td></tr></table></figure><p>2 配置镜像</p><p>创建或修改daemon.json<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/docker/daemon.json</span><br></pre></td></tr></table></figure></p><p>在daemon.json中增加以下配置<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>, <span class="string">"http://hub-mirror.c.163.com"</span>,<span class="string">"https://registry.docker-cn.com"</span>],</span><br><span class="line"><span class="attr">"max-concurrent-downloads"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3 启动docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-ce" target="_blank" rel="noopener">在centos中，从安装包安装Docker</a></li><li><a href="https://docker_practice.gitee.io/introduction/what.html" target="_blank" rel="noopener">Docker最佳实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker意为搬运工人。负责将开发出来的代码部署到指定的系统环境当中。相对于原始的手动或虚拟机部署，Docker极大的提高了生产效率。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="/categories/docker/"/>
    
    
      <category term="CentOS, docker, install,安装" scheme="/tags/CentOS-docker-install-%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>java核心技术面试问题</title>
    <link href="/2019/07/08/core-java-interview-questions/"/>
    <id>/2019/07/08/core-java-interview-questions/</id>
    <published>2019-07-08T07:56:42.050Z</published>
    <updated>2019-07-08T07:56:42.050Z</updated>
    
    <content type="html"><![CDATA[<p>是否是一位新手或者具有丰富经验专业的程序员，java核心技术在任何java/JEE面试中都扮演重要的角色。<br><a id="more"></a></p><h2 id="java核心技术面试问题列表"><a href="#java核心技术面试问题列表" class="headerlink" title="java核心技术面试问题列表"></a>java核心技术面试问题列表</h2><p>在许多面试中，java核心技术是喜欢考察的知识点，并且在决定你的面试结果中扮演关键的角色。这篇文章关于java核心技术的问题，它直接来自于我10多年java编程和许多面试经历。</p><p>我已经写过许多java面试问题的具体文章，如字符串String，集合Collections和多线程Multithreading等主题。</p><p>这里我先给出一些重要的java核心技术面试问题，让你重新加快下你所知道的知识点。</p><ol><li>java 8发布了什么重要特性？</li><li>你对java的平台独立性的理解是什么？</li><li>JVM是什么？JVM是平台独立的吗？</li><li>JDK和JVM的区别是什么？</li><li>JVM和JRE的区别是什么？</li><li>所有类的的超类是哪个类？</li><li>为什么java不支持多继承？</li><li>为什么java不是纯面向对象的语言？</li><li>path和classpath变量的区别是什么？</li><li>java中main方法的重要性是什么？</li><li>java中的重载overloading和覆载overriding是什么？</li><li>能重载main方法吗？</li><li>在一个java源文件中能有多个公共类吗？</li><li>java包是什么？那个包默认被引入？</li><li>java的访问修饰符有哪些？</li><li>final关键字有什么作用？</li><li>static关键字有什么作用？</li><li>java中的finally和finalize有什么作用？</li><li>能声明一个类为静态static类吗？</li><li>静态static引入是什么？</li><li>java带资源的try语句是什么，有什么作用？</li><li>java的多catch语句块是什么，有什么作用？</li><li>静态static语句块是什么，有什么作用？</li><li>接口是什么，有什么作用?</li><li>抽象类是什么，有什么作用？</li><li>抽象类和接口有什么区别？</li><li>接口能否实现或扩展另一个接口？</li><li>标记接口Marker interface是什么，有什么作用？</li><li>包装类是什么？</li><li>java中的枚举是什么？</li><li>java注解是什么？</li><li>java反射API是什么？为什么它非常重要？</li><li>java中的组合是什么？</li><li>组合相对与继承有什么好处？</li><li>java中怎样对自定义对象集合进行排序？</li><li>java中的内部类是什么?</li><li>匿名内部类是什么？</li><li>java类加载器Classloader是什么？</li><li>类加载器的不同类型是什么？</li><li>java中的三元操作符是什么？</li><li>super关键字做什么用的？</li><li>break和continue语句是什么，怎么用？</li><li>this关键字是什么，怎么用？</li><li>默认构造器是什么？</li><li>try可以不带catch语句块吗？</li><li>垃圾收集器Garbage Collection是什么？</li><li>序列化Serialization和反序列化Deserialization是什么？</li><li>通过命令提示行怎样运行JAR文件</li><li>System类的用途是什么？</li><li>instanceof关键字用途是什么？</li><li>switch case语句中能使用String类型吗？</li><li>java是通过值传递还是通过引用传递？</li><li>堆Heap和栈Stack内存有什么区别？</li><li>java编译器是存储在JDK，JRE或JVM哪一个中？</li><li>如下程序将输出什么？</li></ol><h2 id="java核心技术面试问题及答案"><a href="#java核心技术面试问题及答案" class="headerlink" title="java核心技术面试问题及答案"></a>java核心技术面试问题及答案</h2><h3 id="1-java-8发布了什么重要特性？"><a href="#1-java-8发布了什么重要特性？" class="headerlink" title="1. java 8发布了什么重要特性？"></a>1. java 8发布了什么重要特性？</h3><p>java 8于2014年3月发布，因此是java面试中的热点问题。如果你清楚的回答这个问题，将展示出你对新技术的关注度。</p><p>在java 5引入注解和泛型后，java 8是最大（变化）的发布版之一。 java 8有如下重要新特性：</p><ol><li><a href="https://www.journaldev.com/2752/java-8-interface-changes-static-method-default-method" target="_blank" rel="noopener">接口可以带默认和静态方法。</a></li><li><a href="https://www.journaldev.com/2763/java-8-functional-interfaces" target="_blank" rel="noopener">函数式接口和Lambda表达式。</a></li><li><a href="https://www.journaldev.com/2774/java-8-stream" target="_blank" rel="noopener">为集合引入的java Stream API。</a></li><li><a href="https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant" target="_blank" rel="noopener">java 新的日期时间API。</a></li></ol><p>强烈推荐打开链接了作深入理解，也可以看一下java 8的新特性。</p><h3 id="2-你对java的平台独立性Platform-independence的理解是什么？"><a href="#2-你对java的平台独立性Platform-independence的理解是什么？" class="headerlink" title="2. 你对java的平台独立性Platform independence的理解是什么？"></a>2. 你对java的平台独立性Platform independence的理解是什么？</h3><p>平台独立性意思是在任何操作系统中运行同样的java程序。例如你可以在Windows上写java程序运行在Mac OS上。</p><h3 id="3-JVM是什么？JVM是平台独立的吗？"><a href="#3-JVM是什么？JVM是平台独立的吗？" class="headerlink" title="3. JVM是什么？JVM是平台独立的吗？"></a>3. JVM是什么？JVM是平台独立的吗？</h3><p>JVM是java虚拟机（Java Virtual Machine）的缩写，它是java语言的核心。JVM的责任就是转换字节码到可读的机器码。JVM不是平台独立的，也是为什么我们在不同的操作系统需要不同的JVM的原因。我们用java可选项可以自定义分配内存最小和最大值。java虚拟机之所以被叫做虚拟，是因为他提了一个不依赖于底层操作系统的接口。</p><p>阅读更多知识，请访问 <a href="/2019/07/08/jvm-jre-jdk/" title="JVM、JRE和JDK">JVM、JRE和JDK</a> 一文。</p><h3 id="4-JDK和JVM的区别是什么？"><a href="#4-JDK和JVM的区别是什么？" class="headerlink" title="4. JDK和JVM的区别是什么？"></a>4. JDK和JVM的区别是什么？</h3><p>JDK是java开发工具包（java Development Kit）的缩写，它是用于开发目的工具集合。JVM是执行java程序的部分。  </p><p>JDK除了包含了一批用于Java开发的组件，还包含JRE,java运行时环境，也包括了用于产品环境的各种库类，如基础类库rt.jar，以及给开发人员使用的补充库，如国际化与本地化的类库、IDL库等等。JDK中还包括各种样例程序，用以展示Java API中的各部分。</p><p>JVM是java平台的可执行的部分。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。由于JVM并不是专为Java所实现的运行时，实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。</p><h3 id="5-JVM和JRE的区别是什么？"><a href="#5-JVM和JRE的区别是什么？" class="headerlink" title="5. JVM和JRE的区别是什么？"></a>5. JVM和JRE的区别是什么？</h3><p>JRE是java运行时环境的缩写（Java Runtime Environment），它是JVM的一种实现。JRE由JVM,java二节文件和其他成功执行任何程序的其他类组成。JRE不包含任何像编译器、调试器等那样的开发工具。如果你想执行任何java程序，你应当安装JRE。</p><h3 id="6-所有类的的超类是哪个类？"><a href="#6-所有类的的超类是哪个类？" class="headerlink" title="6. 所有类的的超类是哪个类？"></a>6. 所有类的的超类是哪个类？</h3><p><code>java.lang.Object</code>是所有类的根类，不需要扩展它。</p><h3 id="7-为什么java不支持多继承？"><a href="#7-为什么java不支持多继承？" class="headerlink" title="7. 为什么java不支持多继承？"></a>7. 为什么java不支持多继承？</h3><p>因是“钻石问题（菱形继承问题）” 导致java类不支持多继承。想了解更多“钻石问题”，请阅读<a href="https://www.journaldev.com/1775/multiple-inheritance-in-java" target="_blank" rel="noopener">java中的多继承</a>。</p><p>然后多继承在接口中是支持的。一个接口可以扩展多个接口，因为仅仅是声明方法，实现类中将实现它接口的方法。因此在接口中就没有“<br>钻石问题（菱形继承问题）”了。</p><h3 id="8-为什么java不是纯面向对象的语言？"><a href="#8-为什么java不是纯面向对象的语言？" class="headerlink" title="8. 为什么java不是纯面向对象的语言？"></a>8. 为什么java不是纯面向对象的语言？</h3><p>说java不是纯面向对象语言，是因为它支持如int、byte、short、long等原始类型。我相信在写代码时它带来了简捷性。很显然地java有原始类型对应的包装类型表示，从所周知，包装类型除了添加了一些方法，它们没有带来任何好处。</p><h3 id="9-path和classpath变量的区别是什么？"><a href="#9-path和classpath变量的区别是什么？" class="headerlink" title="9. path和classpath变量的区别是什么？"></a>9. path和classpath变量的区别是什么？</h3><p>PATH是一个用在操作系统中定位可执行文件的环境变量（不仅java可执行文件，还有其他如C#,C++等可执行文件）。这就是为什么在安装java时或想任何可执行文件被找到时，我们需要配置目录路径到Path变量的原因。</p><p>Classpath是为java指定的用于java可执行文件定位class字节文件的路径变量。在运行java应用程序时将查找这个classpath路径，它可以是目录、ZIP文件、JAR文件等。</p><h3 id="10-java中main方法的重要性是什么？"><a href="#10-java中main方法的重要性是什么？" class="headerlink" title="10. java中main方法的重要性是什么？"></a>10. java中main方法的重要性是什么？</h3><p>main()方法是任何独立的java应用程序的入口点。main的语法是：<code>public static void main(String args[])</code>.</p><p>main方法是公用且静态的，输入参数是数组，可以转入运行时参数给它。</p><h3 id="11-java中的重载overloading和覆载overriding是什么？"><a href="#11-java中的重载overloading和覆载overriding是什么？" class="headerlink" title="11. java中的重载overloading和覆载overriding是什么？"></a>11. java中的重载overloading和覆载overriding是什么？</h3><p>有超过一个方法存在相同名称、不同参时，我们称它为重载。</p><p>覆载指的是父子类之间存在相同签名的方法。在子类中可以使用@Override注解覆盖父类的方法。</p><h3 id="12-能重载main方法吗？"><a href="#12-能重载main方法吗？" class="headerlink" title="12. 能重载main方法吗？"></a>12. 能重载main方法吗？</h3><p>可以，在类中可以有多个main名字的方法。然而运行时的入口仅查找这个方法<code>public static void main(String args[])</code>.</p><h3 id="13-在一个java源文件中能有多个公共类吗？"><a href="#13-在一个java源文件中能有多个公共类吗？" class="headerlink" title="13. 在一个java源文件中能有多个公共类吗？"></a>13. 在一个java源文件中能有多个公共类吗？</h3><p>在单个java源文件中，不能超过一个公共类。但单个源文件中可以有多个非公共的类。</p><h3 id="14-java包是什么？那个包默认被引入？"><a href="#14-java包是什么？那个包默认被引入？" class="headerlink" title="14. java包是什么？那个包默认被引入？"></a>14. java包是什么？那个包默认被引入？</h3><p>java包是组织java类文件的一种机制。这个组织逻辑可以基于功能或模块。一个类的完整类名应包含包及类名，例如，<code>java.lang.Object</code>是Object类的完整类名，它是java.lang包的一部分。</p><p><code>java.lang</code>包是被默认引入的，任何类中它不需要明确引入。</p><h3 id="15-java的访问修饰符有哪些？"><a href="#15-java的访问修饰符有哪些？" class="headerlink" title="15. java的访问修饰符有哪些？"></a>15. java的访问修饰符有哪些？</h3><p>java提供公有public, 私有private和保护protected访问修饰符。若未使用任何修饰符，则被叫做默认default访问修饰符。</p><p>java类仅有公有和默认访问修饰符。阅读更多关于<a href="https://www.journaldev.com/2345/java-access-modifiers" target="_blank" rel="noopener">java访问修饰符</a>的知识。</p><h3 id="16-final关键字有什么作用？"><a href="#16-final关键字有什么作用？" class="headerlink" title="16. final关键字有什么作用？"></a>16. final关键字有什么作用？</h3><p>final关键用于确保其他类不能扩展它。如String类就带有final，我们就不能扩展它。</p><p>方法前也可以使用final关键字用来确保子类不能覆盖它。</p><p>final关键字用在变量前确保只能分配一次值。然而变量的状态是可以改变的，例如可以分配到final变量一次，但是变量的值，在分配之后是可以改变的。</p><p>java接口的变量默认就是final且静态static的。</p><h3 id="17-static关键字有什么作用？"><a href="#17-static关键字有什么作用？" class="headerlink" title="17. static关键字有什么作用？"></a>17. static关键字有什么作用？</h3><p>static关键字用在类级别全局的变量，如所有对象将共享同一个变量。</p><p>static关键字也可以用在方法前。静态方法仅能访问类的静态变量和调用静态方法。</p><p>static关键字用作静态块。静态块是通过java类加载器一次性加载到内存的。常用来初始化静态变量，大多用来创建静态资源。</p><p>static关键字用作静态嵌套类。此时能访问变部静态类的静态方法或静态变量。</p><p>static关键字用作静态引入。如<code>import static java.lang.Math.PI;</code>，这样就可以直接在当前类中使用PI参数了。</p><h3 id="18-java中的finally和finalize有什么作用？"><a href="#18-java中的finally和finalize有什么作用？" class="headerlink" title="18. java中的finally和finalize有什么作用？"></a>18. java中的finally和finalize有什么作用？</h3><p>finally块用作在try-catch块之后你总想执行的东西。甚至在抛出异常时也会执行。它大多用来释放在try块中创建的资源。</p><p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p><p>finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但java中的finalize的调用具有不确定性。</p><p>不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：<br> a.清理本地对象(通过JNI创建的对象)；<br> b.作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。</p><h3 id="19-能声明一个类为静态static类吗？"><a href="#19-能声明一个类为静态static类吗？" class="headerlink" title="19. 能声明一个类为静态static类吗？"></a>19. 能声明一个类为静态static类吗？</h3><p>不能声明一个类为顶级静态类，但可以声明为嵌套静态类。</p><h3 id="20-静态static引入是什么？"><a href="#20-静态static引入是什么？" class="headerlink" title="20. 静态static引入是什么？"></a>20. 静态static引入是什么？</h3><p>我们访问静态变量或方法一般是通过类访问的。但也可以通过静态引入的方式<code>import static java.lang.Math.PI;</code>使用它。</p><p>使用静态引入带来困惑，最好避免使用它，同时使用它还会使代码的可维护性和可读性变差。</p><h3 id="21-java带资源的try语句是什么，有什么作用？"><a href="#21-java带资源的try语句是什么，有什么作用？" class="headerlink" title="21. java带资源的try语句是什么，有什么作用？"></a>21. java带资源的try语句是什么，有什么作用？</h3><p>java 7的新特性,带资源的try语句，用于自动释放资源，相当于try-catch语句块执行了finnaly块。</p><h3 id="22-java的多个catch语句块是什么，有什么作用？"><a href="#22-java的多个catch语句块是什么，有什么作用？" class="headerlink" title="22. java的多个catch语句块是什么，有什么作用？"></a>22. java的多个catch语句块是什么，有什么作用？</h3><p>如果一个try块中有多个异常要被捕获，catch块中的代码会变丑陋的同时还要用多余的代码来记录异常。有鉴于此，java 7的一个新特征是：一个catch子句中可以捕获多个异常。使用管道符(|),如’catch(IOException | SQLException | Exception ex)’捕获异常。</p><h3 id="23-静态static语句块是什么，有什么作用？"><a href="#23-静态static语句块是什么，有什么作用？" class="headerlink" title="23. 静态static语句块是什么，有什么作用？"></a>23. 静态static语句块是什么，有什么作用？</h3><p>静态块是一组语句块，通过java类加载器一次性加载到内存的。常用来初始化静态变量，大多用来创建静态资源。</p><h3 id="24-接口是什么，有什么作用"><a href="#24-接口是什么，有什么作用" class="headerlink" title="24. 接口是什么，有什么作用?"></a>24. 接口是什么，有什么作用?</h3><p>接口是java语言的核心部分，不但用在许多JDK中而且也用在许多框架、工具和java设计模式中。在java中，接口提供了一用实现方式的抽象，用来定义子类需要实现的契约。</p><p>在代码中，接口有利于定义类型起始点和创建顶层结构。自从java接口能实现多个接口后，在许多场景下，使用接口更优于超类。</p><h3 id="25-抽象类是什么，有什么作用？"><a href="#25-抽象类是什么，有什么作用？" class="headerlink" title="25. 抽象类是什么，有什么作用？"></a>25. 抽象类是什么，有什么作用？</h3><p>抽象类为子类创建一些默认方法的实现。抽象类可以有未实现的抽象方法。</p><p>abstract关键字用来创建抽象类。抽象类不能被实例化，大多是用于子类的扩展。</p><h3 id="26-抽象类和接口有什么区别？"><a href="#26-抽象类和接口有什么区别？" class="headerlink" title="26. 抽象类和接口有什么区别？"></a>26. 抽象类和接口有什么区别？</h3><ul><li>abstract用于创建抽象类，而interface用来创建接口。</li><li>子类用extends扩展抽象类，而接口使用implements实现接口。</li><li>抽象类可以有实现方法，但接口没有。</li><li>抽象类有构造器，但接口没有。</li><li>抽象类的方法有public, private, protected, static修饰符，但接口的方法是隐式的public和abstract，不需要使用任何的修饰符。</li><li>一个类只能扩展最多一个抽象类，但接口可以扩展一个或多个接口。</li><li>抽象类可以扩展其他类和实现其他接口，但接口只能扩展其他接口。</li><li>抽象类有main入口方法，是可以运行的，但时接口不能。</li><li>接口常用来定义契约，但抽象定义契约的同时还可以有方法实现。</li></ul><h3 id="27-接口能否实现或扩展另一个接口？"><a href="#27-接口能否实现或扩展另一个接口？" class="headerlink" title="27. 接口能否实现或扩展另一个接口？"></a>27. 接口能否实现或扩展另一个接口？</h3><p>接口不能实现另一个接口，但可以扩展它。因为接口没有实现就没有“钻石问题”。</p><h3 id="28-标记接口Marker-interface是什么，有什么作用？"><a href="#28-标记接口Marker-interface是什么，有什么作用？" class="headerlink" title="28. 标记接口Marker interface是什么，有什么作用？"></a>28. 标记接口Marker interface是什么，有什么作用？</h3><p>标记接口是一个没有任何方法实现的空接口，用于标记实现类有某些功能。从所周知的Serializable和Cloneable就是标记接口。</p><h3 id="29-包装类是什么？"><a href="#29-包装类是什么？" class="headerlink" title="29. 包装类是什么？"></a>29. 包装类是什么？</h3><p>java包装类是8个原始类型对应的对象表示形式。所有的包装类都是不能被继承final和一成不变immutable的。</p><h3 id="30-java中的枚举是什么？"><a href="#30-java中的枚举是什么？" class="headerlink" title="30. java中的枚举是什么？"></a>30. java中的枚举是什么？</h3><p>枚举作为一个新类型，在java 1.5版本引入。它的域由一些固定的常量构成。如，在java中可以使用EAST, WEST, NORTH, SOUTH创建Direction方向的枚举。</p><p>与类相似，我们使用enum关键字用于创建一个枚举类型。枚举常量是隐式的静态不能继承的。</p><h3 id="31-java注解是什么？"><a href="#31-java注解是什么？" class="headerlink" title="31. java注解是什么？"></a>31. java注解是什么？</h3><p>java注解提供关于代码的描述信息。它不直接影响代码。注解在java5中被引入。注解是关于嵌套在程序自己中的元数据。可以用过注解解析工具或编译器解析。我们常指定注释在编译时或者在运行时可用。java盎的注解有@Override, @Deprecated and @SuppressWarnings。 </p><h3 id="32-java反射API是什么？为什么有它非常重要？"><a href="#32-java反射API是什么？为什么有它非常重要？" class="headerlink" title="32. java反射API是什么？为什么有它非常重要？"></a>32. java反射API是什么？为什么有它非常重要？</h3><p>java反射API提供查看和修改java应用程序的运行时行为的能力。我们可以查看java类，接口，枚举和它们的方法和域的详情。反射API是一个高级主题，一般的应用中应当避免它。反射API用于反设计模式的场景，如单例模式中调用私有构造器，建返访问修饰调用。</p><p>即然一般的应用中应当避免使用反射API，但有它的话还是非常重要。因为我们不能没有如Spring，Hibernate或者Tomcat服务，JBoss之类的框架。它们通过反射API调用适当的方法和实体，使用它做了许多处理。</p><h3 id="33-java中的组合（Composition）是什么？"><a href="#33-java中的组合（Composition）是什么？" class="headerlink" title="33. java中的组合（Composition）是什么？"></a>33. java中的组合（Composition）是什么？</h3><p>组合是在类中实现<code>有has-a</code>关系的一种设计技术。使用对象组合是为了代码重用。</p><p>java组合通过引用其他对象的实例变量实现的。使用组合的好处是，我们能够控制其他对象的可见性，在我们需要的时候重用。</p><h3 id="34-组合相对与继承有什么好处？"><a href="#34-组合相对与继承有什么好处？" class="headerlink" title="34. 组合相对与继承有什么好处？"></a>34. 组合相对与继承有什么好处？</h3><p>java编程的最佳实践之一是“组合（Composition）优于继承（Inheritance）”。有以下原因：</p><ul><li>尽管我们可以不使用超类的方法，但在超类中的任何改变也可能影响到子类。例如，假如我们在子类中有一个方法<code>test()</code>，突然某人在父类引入一个方法<code>test()</code>，那么我们在子类中出现编译错误。组合从没有这种问题，是因为我们仅在需要方法时才使用。</li><li>若我们在设计超类时没有掌控，继承会暴露了所有超类的方法和变量到客户端，这样也能导致安全漏洞。组合允许我们对方法提供限制的访问，因此更加安全。</li><li>在组合中我们可以运行时绑定，继承绑定是在编译时。因此组合的方法调用更加灵活。</li></ul><p>你可以在<a href="https://www.journaldev.com/1775/multiple-inheritance-in-java" target="_blank" rel="noopener">java组合vs继承</a>一文中，阅读更多关于组合优于继承的知识。</p><h3 id="35-java中怎样对自定义对象集合进行排序？"><a href="#35-java中怎样对自定义对象集合进行排序？" class="headerlink" title="35. java中怎样对自定义对象集合进行排序？"></a>35. java中怎样对自定义对象集合进行排序？</h3><p>自定义对象集合支持排序需要实现比较Comparable接口。比较接口有<code>compareTo(T obj)</code>方法，它被用于排序的实现，我们可以提供默认的排序方法。</p><p>然后，如果想基于不同条件，如员工集合中基于薪资或年龄的排序。我们可以创建多个匿名类的比较器实例实现。</p><h3 id="36-java中的内部类是什么"><a href="#36-java中的内部类是什么" class="headerlink" title="36. java中的内部类是什么?"></a>36. java中的内部类是什么?</h3><p>我们把定义在类的内部的类称为嵌套类。任何非静态的嵌套类被称之为内部类。内部类与类的对象实例相关。它能访问所有变量和外部类的方法。即然内部类是与实例相关，那么它就没有任何静态变量。</p><p>在类的内部，可以有本地内部类和匿名内部类。详情请阅读<a href="https://www.journaldev.com/996/java-inner-class" target="_blank" rel="noopener">java内部类</a>。</p><h3 id="37-匿名内部类是什么？"><a href="#37-匿名内部类是什么？" class="headerlink" title="37. 匿名内部类是什么？"></a>37. 匿名内部类是什么？</h3><p>一个本地不带名字的类被叫做匿名内部类。在单个语句中匿名类定义后并立即实例化。匿名内部类总是扩展自一个类或者实现一个接口。</p><p>既然匿名类没有名字，那么它也没有定义构造器。匿名内部类仅在定义的地方可以访问。</p><h3 id="38-java类加载器Classloader是什么？"><a href="#38-java类加载器Classloader是什么？" class="headerlink" title="38. java类加载器Classloader是什么？"></a>38. java类加载器Classloader是什么？</h3><p>java类加载器是在我们想访问任何类时，加载字节码程序到内存的一种程序。我们也可以扩散ClassLoader类和覆载loadClass(String name)方法定义自己的类加载器。了解更多关于<a href="https://www.journaldev.com/349/java-classloader" target="_blank" rel="noopener">java类加器</a>。</p><h3 id="39-类加载器的不同类型是什么？"><a href="#39-类加载器的不同类型是什么？" class="headerlink" title="39. 类加载器的不同类型是什么？"></a>39. 类加载器的不同类型是什么？</h3><p>在java中提供以下三个内建的类加载器：</p><ol><li>引导类加载器（Bootstrap Class Loader）：它用来加载JDK内存类，典型的加载rt.jar和其他核心类。它是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</li><li>扩展类加载器（Extensions Class Loader）：它用来加载 JDK 的扩展库。常常加载$jAVA_HOME/lib/ext目录库。</li><li>系统类加载器（System Class Loader）：它根据 java 应用的类路径（CLASSPATH）来加载 java 类。一般来说，java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li></ol><h3 id="40-java中的三元操作符是什么？"><a href="#40-java中的三元操作符是什么？" class="headerlink" title="40. java中的三元操作符是什么？"></a>40. java中的三元操作符是什么？</h3><p>java三元操作符仅是一个带三个表达式的条件操作符。可以使用if-then-else语句替换。例如<code>a==b?a:b</code>。</p><h3 id="41-super关键字做什么用的？"><a href="#41-super关键字做什么用的？" class="headerlink" title="41. super关键字做什么用的？"></a>41. super关键字做什么用的？</h3><p>super用作子类中访问父类构造器或父类方法。访问类构造器是须放在第一条语句且只能在构造器中访问。</p><h3 id="42-break和continue语句是什么，怎么用？"><a href="#42-break和continue语句是什么，怎么用？" class="headerlink" title="42. break和continue语句是什么，怎么用？"></a>42. break和continue语句是什么，怎么用？</h3><p>放在循环语句中用来结束循环，break结束整个循环，continue结束本次循环。</p><h3 id="43-this关键字是什么，怎么用？"><a href="#43-this关键字是什么，怎么用？" class="headerlink" title="43. this关键字是什么，怎么用？"></a>43. this关键字是什么，怎么用？</h3><p>用于访问当前对象的引用。大多被用于确保是当前对象的变量（相对于入参变量来说），也可以用来调用当前对象的其他构造器。</p><h3 id="44-默认构造器是什么？"><a href="#44-默认构造器是什么？" class="headerlink" title="44. 默认构造器是什么？"></a>44. 默认构造器是什么？</h3><p>类的无参构造器被称为默认构造器。在我们没有定义任何类构造器时，java编译器会自动创建类的默认无参构造器。如果定义了有其他构造器，则编译器不会为我们创建默认构造器。</p><h3 id="45-try可以不带catch语句块吗？"><a href="#45-try可以不带catch语句块吗？" class="headerlink" title="45. try可以不带catch语句块吗？"></a>45. try可以不带catch语句块吗？</h3><p>可以。可以有try-finally语句块，于是就避免带catch语句块了。</p><h3 id="46-垃圾收集器Garbage-Collection是什么？"><a href="#46-垃圾收集器Garbage-Collection是什么？" class="headerlink" title="46. 垃圾收集器Garbage Collection是什么？"></a>46. 垃圾收集器Garbage Collection是什么？</h3><p>垃圾收集器查看堆内存的处理器，识别哪个对象在使用中和哪个不在使用中，然后删除不使用的对象。销毁内存是通过垃圾收集器自动进行处理的。</p><p>我们可以使用代码<code>Runtime.getRuntime().gc()</code>或者使用工具方法<code>System.gc()</code>运行垃圾收集器。更多堆内存和垃圾收集器详细分析，请阅读“<a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">垃圾收集器</a>”。</p><h3 id="47-序列化Serialization和反序列化Deserialization是什么？"><a href="#47-序列化Serialization和反序列化Deserialization是什么？" class="headerlink" title="47. 序列化Serialization和反序列化Deserialization是什么？"></a>47. 序列化Serialization和反序列化Deserialization是什么？</h3><p>我们把java对象转换成二进制流的过程被称做为序列化。一旦一个对象被转换成二进制流，它就可以侦破到文件或通过网络发送或在套接字连接中使用。</p><p>对象应当实现序列化Serializable接口，这样我们就可以使用<code>java.io.ObjectOutputStream</code>写入对象到文件或者任何输出流OutputStream对象了。阅读更多<a href="https://www.journaldev.com/927/objectoutputstream-java-write-object-file" target="_blank" rel="noopener">java序列化</a>知识。</p><p>把二进制流数据转换成对象的过程被称做为反序列化。阅读更多<a href="https://www.journaldev.com/933/objectinputstream-java-read-object-file" target="_blank" rel="noopener">java反序列化</a>知识。</p><h3 id="48-通过命令提示行怎样运行JAR文件？"><a href="#48-通过命令提示行怎样运行JAR文件？" class="headerlink" title="48. 通过命令提示行怎样运行JAR文件？"></a>48. 通过命令提示行怎样运行JAR文件？</h3><p>能使用命令行运行jar包文件，但需要在jar清单文件中有Main入口类。含Main的类是jar包的入口点，用来通过java命令执行。</p><h3 id="49-System类的用途是什么？"><a href="#49-System类的用途是什么？" class="headerlink" title="49. System类的用途是什么？"></a>49. System类的用途是什么？</h3><p>java System类是核心类之一，<code>System.out.print()</code>是其中一个方法。在调试时，它是最简单的记录日志信息的方法。</p><p>System类被声明为final的。因此无法被子类继承和覆盖其行为。也不提供任何公共构造器，因此也不能实例这个类。也是为什么它的所有方法是静态static的原因。</p><p>System类提供了数组拷贝、获取当前时间、读环境变化等助手类方法。阅读更多<a href="https://www.journaldev.com/1847/java-system-java-lang-system-class" target="_blank" rel="noopener">java System类</a>知识。</p><h3 id="50-instanceof关键字的用途是什么？"><a href="#50-instanceof关键字的用途是什么？" class="headerlink" title="50. instanceof关键字的用途是什么？"></a>50. instanceof关键字的用途是什么？</h3><p>instanceof关键字用来检测是否属于某个类。我们应当尽可能的避免使用它。</p><h3 id="51-switch-case语句中能使用字符串类型吗？"><a href="#51-switch-case语句中能使用字符串类型吗？" class="headerlink" title="51. switch case语句中能使用字符串类型吗？"></a>51. switch case语句中能使用字符串类型吗？</h3><p>java 7引入的新特性之一，switch case语句中可以使用字符串类型。因此java 7或更高版本可以使用。</p><h3 id="52-java是通过值传递还是通过引用传递？"><a href="#52-java是通过值传递还是通过引用传递？" class="headerlink" title="52. java是通过值传递还是通过引用传递？"></a>52. java是通过值传递还是通过引用传递？</h3><p>这个问题非常具有迷惑性。我们知道对象变量在堆空间中包含引用的对象。在我们调用任何方法时，这个变量的拷贝被转递并存储在方法的栈内存中。我们能够检测到任何语言它是通过引用或通过值传递通过一个简单的交换方法，请阅读<a href="https://www.journaldev.com/3884/java-is-pass-by-value-and-not-pass-by-reference" target="_blank" rel="noopener">更多</a>。由此我们得出java是通过值传递而不是通过引用传递的。</p><h3 id="53-堆Heap和栈Stack内存有什么区别？"><a href="#53-堆Heap和栈Stack内存有什么区别？" class="headerlink" title="53. 堆Heap和栈Stack内存有什么区别？"></a>53. 堆Heap和栈Stack内存有什么区别？</h3><p>堆和栈主要的区别如下：</p><ul><li>所有应用的部分都使用堆内存，然而只有执行线程使用栈内存。</li><li>每当对象被创建时，它总是存在堆空间中，栈内存包含它的引用。栈内存仅包括本地的原始变量，在堆空间中的对象的引用变量。<br>*栈内存是通后进先出LIFO的方法管理的，然而在堆内存中因为它是全局使用，所以它的管理方式更加复杂。</li></ul><p>在同一程序中更加详细的解释，请阅读<a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">java堆vs栈内存</a></p><h3 id="54-java编译器是存储在JDK，JRE或JVM哪一个中？"><a href="#54-java编译器是存储在JDK，JRE或JVM哪一个中？" class="headerlink" title="54. java编译器是存储在JDK，JRE或JVM哪一个中？"></a>54. java编译器是存储在JDK，JRE或JVM哪一个中？</h3><p>java编译器的任务是转换java程序到字节码，我们使用<code>javac</code>命令执行即可实现。因此它必须要存在JDK中。</p><h3 id="55-如下程序将输出什么？"><a href="#55-如下程序将输出什么？" class="headerlink" title="55. 如下程序将输出什么？"></a>55. 如下程序将输出什么？</h3><ol><li>在类中的静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tests;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test toString called"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        System.out.println(toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：以上代码不能编译。因为所有类对继承根对象类Object。以上会编译错误提示静态方法不能覆盖实例方法。</p><ol><li>静态方法调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tests;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test foo called"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Test obj = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(obj.foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：这是个奇怪的使用场景。NULL空对象调用方法是总会报<code>NullPointerException</code>异常，且该方法是属于类的静态方法，但该程序能工作并打印”Test foo called”。</p><p>原因是编译器做了编译优化。在java编译转换成字节码时，它指向的foo()是静态方法，而不是对象方法，因此编译从<code>obj.foo()</code>调整到<code>Test.foo()</code>，于是也没有了<code>NullPointerException</code>异常。</p><p><a href="https://www.journaldev.com/2366/core-java-interview-questions-and-answers#public-class" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是否是一位新手或者具有丰富经验专业的程序员，java核心技术在任何java/JEE面试中都扮演重要的角色。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,core,interview,核心技术,编程,面试" scheme="/tags/java-core-interview-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>为Spring设置restful基础路径</title>
    <link href="/2018/11/26/spring-restcontrooler-specific-basepath/"/>
    <id>/2018/11/26/spring-restcontrooler-specific-basepath/</id>
    <published>2018-11-26T05:54:44.936Z</published>
    <updated>2017-10-19T01:12:36.551Z</updated>
    
    <content type="html"><![CDATA[<p>由于某些原因，我们会把前端和后端的放在一个站点上，但如果前后端不做分离的话，随着时间推移代码会难以维护。因此就想把静态内容放和后端的接口分开放置，来达到分离的效果。<br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>希望spring有如下URL结构  </p><p>/index.html – 静态页<br>/api/user – rest控制器的所有api放在api下</p><p>因为是针对所有的RestControllers增加api，而静态页不变，所以有以下两种思路：</p><ul><li>基于RestController类增加Spring配置</li><li>重写RestController注解</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="基于RestController类增加Spring配置"><a href="#基于RestController类增加Spring配置" class="headerlink" title="基于RestController类增加Spring配置"></a>基于RestController类增加Spring配置</h3><p>目录结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcRegistrationsAdapter <span class="title">webMvcRegistrationsHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcRegistrationsAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">getRequestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RequestMappingHandlerMapping() &#123;</span><br><span class="line">                    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String API_BASE_PATH = <span class="string">"api"</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, RequestMappingInfo mapping)</span> </span>&#123;</span><br><span class="line">                        Class&lt;?&gt; beanType = method.getDeclaringClass();</span><br><span class="line">                        <span class="keyword">if</span> (AnnotationUtils.findAnnotation(beanType, RestController.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            PatternsRequestCondition apiPattern = <span class="keyword">new</span> PatternsRequestCondition(API_BASE_PATH)</span><br><span class="line">                                    .combine(mapping.getPatternsCondition());</span><br><span class="line"> </span><br><span class="line">                            mapping = <span class="keyword">new</span> RequestMappingInfo(mapping.getName(), apiPattern,</span><br><span class="line">                                    mapping.getMethodsCondition(), mapping.getParamsCondition(),</span><br><span class="line">                                    mapping.getHeadersCondition(), mapping.getConsumesCondition(),</span><br><span class="line">                                    mapping.getProducesCondition(), mapping.getCustomCondition());</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">super</span>.registerHandlerMethod(handler, method, mapping);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写RestController注解"><a href="#重写RestController注解" class="headerlink" title="重写RestController注解"></a>重写RestController注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestApiController &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@AliasFor</span>(annotation = RequestMapping.class, attribute = <span class="string">"value"</span>)</span><br><span class="line"> String[] value();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestApiController</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        User.setText(<span class="string">"User api"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于某些原因，我们会把前端和后端的放在一个站点上，但如果前后端不做分离的话，随着时间推移代码会难以维护。因此就想把静态内容放和后端的接口分开放置，来达到分离的效果。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,restful,base path,基础路径" scheme="/tags/java-spring-restful-base-path-%E5%9F%BA%E7%A1%80%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>spring中如何穿透多层共享公用信息</title>
    <link href="/2018/11/26/spring-penetrate-layers/"/>
    <id>/2018/11/26/spring-penetrate-layers/</id>
    <published>2018-11-26T05:54:44.920Z</published>
    <updated>2017-11-13T06:07:10.219Z</updated>
    
    <content type="html"><![CDATA[<p>在实际应用中较多使用的还是是三层架构，主要是因为在程序员圈中，易理解，通用性高。不过各人理解不同使用起来存在差异，就比方说公用信息共享的问题，展示层共享较好理解，那业务层和数据层怎共享呢？<br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如何在各层之间共享公用信息？即要兼顾性能，还要考虑效率和易维护性。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先来说说疑虑，很长一段时间，因为三层都是以子项目来划分，共享公用信息就不自觉的使用方法传参的方式实现，随得需求和时间的增长，各个方法都会带上公用信息参数。如此一来，<strong>自上而下的公用信息从展示一直传递到数据层</strong>。问题解决了，但带来了一个新的重复的问题：即所有用到公用信息的地方都得增加该参数。</p><p>传参的方式还可以用继承基类的方式实现，即所有的<strong>参数继承某个基类，基类中有共享信息的引用</strong>，但此方案还是换汤不换药，仅是传参数少了，重复的问题依然存在。</p><p>以上两种方案都未能较好的解决共享公用信息的问题，以致于觉得问题出在架构层，把三层换成微内核心架构或者域驱动模型架构。但是无论架构怎么变，层之间的共享信息问题似乎总是存在，只是重复率高低问题。</p><p>最近从更高的层面来了看待这个问题，就迎刃而解了。一个程序启动于一个主进程，进程中可以启动多个线程。也就是主进程就是一直存在的，若<strong>主进程中共享公用信息</strong>，那么就可以达到穿透多层共享公用信息的问题。</p><p>spring中则是通过公用子项目，初始化一个对象到应用上下文（理解为主进程），在需要的任何层注入该对象即达到了共享公用信息的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际应用中较多使用的还是是三层架构，主要是因为在程序员圈中，易理解，通用性高。不过各人理解不同使用起来存在差异，就比方说公用信息共享的问题，展示层共享较好理解，那业务层和数据层怎共享呢？&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,share,base path,基础路径" scheme="/tags/java-spring-share-base-path-%E5%9F%BA%E7%A1%80%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>在Linux中后台运行进程的几种方法</title>
    <link href="/2018/11/26/run-backgroud-process-sereral-ways/"/>
    <id>/2018/11/26/run-backgroud-process-sereral-ways/</id>
    <published>2018-11-26T05:54:44.871Z</published>
    <updated>2018-02-13T04:30:33.113Z</updated>
    
    <content type="html"><![CDATA[<p>第二次碰到需要在后台运行进程，主要解决用telnet/ssh登录Linux服务器后，让一些程序一直运行，不受关闭终端/网络断开连接影响而不能使用。以下给出了多种方法，分别适用于不同场景。</p><a id="more"></a><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup 的用途就是让提交的命令忽略 hangup 信号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nohup ping lexiangmiao.com &amp; </span><br><span class="line"></span><br><span class="line">nohup ping lexiangmiao.com &gt;log.txt&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">ps -ef |grep lexiangmiao.com</span><br></pre></td></tr></table></figure></p><h2 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h2><p>用一新的会话运行程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setsid ping lexiangmiao.com</span><br><span class="line"></span><br><span class="line">ps -ef |grep lexiangmiao.com</span><br></pre></td></tr></table></figure></p><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>使用()和&amp;小技巧可以实现后台稳定运行</p><p>()可以运行多个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端关闭（收到 HUP即hangup信号）后就其子进程也关闭了</span></span><br><span class="line">ping lexiangmiao.com &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了</span></span><br><span class="line">(ping lexiangmiao.com &amp;)</span><br><span class="line">ps -ef |grep lexiangmiao.com</span><br></pre></td></tr></table></figure><h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -r testLargeFile largeFile &amp;</span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># 指jobs查出的编号</span></span><br><span class="line"><span class="built_in">disown</span> -h %1</span><br></pre></td></tr></table></figure><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？</p><p>用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">screen -r Urumchi</span><br><span class="line">ping www.ibm.com &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看依赖关系树</span></span><br><span class="line">pstree -H 9488</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。</p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">ref</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二次碰到需要在后台运行进程，主要解决用telnet/ssh登录Linux服务器后，让一些程序一直运行，不受关闭终端/网络断开连接影响而不能使用。以下给出了多种方法，分别适用于不同场景。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="linux,process,后台运行" scheme="/tags/linux-process-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>研发人员的绩效考核</title>
    <link href="/2018/11/26/research-and-development-personnel-performance-appraisal/"/>
    <id>/2018/11/26/research-and-development-personnel-performance-appraisal/</id>
    <published>2018-11-26T05:54:44.852Z</published>
    <updated>2018-01-17T03:11:09.813Z</updated>
    
    <content type="html"><![CDATA[<p>很多企业的绩效考核工作常常会面临这样的问题：相对其他部门，研发部门的考核指标提取、考核方式确定都有一定的难度。这也是人力资源专业人员和研发部门管理者困惑的难题。<br><a id="more"></a></p><p>曾经有企业试图对研发人员实行完全的定量考核，甚至提出以编写软件代码的行数作为一个重要考核指标，结果员工开始将一个命令可以解决的问题，拆分为几个命令，于是 “大家都很忙，疲于写程序，工作结果完全超过了预期目标，但是软件的功能却没有实现”，完全背离了绩效考核设计的初衷，考核不得不紧急叫停。虽然这种方式停止了，但如何公正客观地评价研发人员工作业绩的问题却依然摆在管理者面前。</p><h2 id="研发人员考核难在哪里"><a href="#研发人员考核难在哪里" class="headerlink" title="研发人员考核难在哪里"></a>研发人员考核难在哪里</h2><p>研发人员考核的困难主要集中于以下几点：</p><ul><li>绩效指标提取困难，由于研发人员工作本身的独特性以及工作成果不易衡量，因此难以提炼直观量化的数字性指标；</li><li>工作内容界定困难，特别是预研人员，一些成果仅仅是证明某种试试验或测试方法可行与否，证实与证伪具有同样的价值，难以在任务下达之前予以明确；</li><li>定性内容较多，影响考核的公正性；</li><li>考核方式的选取问题，很多企业的研发管理者为了回避考核的难题，而采取背后打分、不沟通的方式。</li></ul><p>面临如此多的问题，如何对研发人员进行业绩评价呢？其实，考核中最为关键的是指标和评价方式，这两者是员工工作的向导和公司的价值取向，出不得偏差，否则就可能事倍功半，甚至劳而无功了。这里，我们也从这两点出发，分析研发人员的指标提炼和评价方式。</p><h2 id="怎样提炼绩效指标"><a href="#怎样提炼绩效指标" class="headerlink" title="怎样提炼绩效指标"></a>怎样提炼绩效指标</h2><p>任何一项工作的展开必然是这样的思路：”正确的行为，沿着正确的道路，达成正确的结果”，提炼绩效指标也需要沿着这样的逻辑关系，从研发成果向前推出成功的路径以及正确的行为要求，具体见下图。</p><p><img src="/gallery/rd1.jpg" alt="绩效考核指标" title="绩效考核指标"></p><p>研发人员的考核指标可以界定为两个方面：一个是效益指标，一个是效率指标。效益指标是研发的成果在市场中产生的价值反映，如产品销售额、市场占有率等。效率指标则是指公司内部的研发效率和阶段成果完成情况，包括路径指标和行为指标，具体如产品开发周期、研发费用、产品规划符合度、批次整改率、单板/整机直通率、产品数据准确率等等。绩效指标提炼的过程实际上就是管理程序和工作流程的分析过程：</p><h2 id="路径指标"><a href="#路径指标" class="headerlink" title="路径指标"></a>路径指标</h2><p>路径指标是衡量研发过程是否符合总体研发规划的过程检测指标。 从研发的整体流程环节看，虽然研发的成果不同，但是他们所遵循的程序是一致的，明确每一环节的关键监控点，也就可以形成考核的路径指标。这些路径指标的达成保证了最终结果的实现。</p><p>产品开发周期、研发费用等指标比较易于理解，产品规划符合度指标虽然不多见，却非常重要，下面是某公司对此的界定（见表一）。</p><p><img src="/gallery/rd1.jpg" alt="绩效路径指标" title="绩效路径指标"></p><h2 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法:"></a>统计方法:</h2><p>1.路标和0级计划、1级计划基本数据和经过更改认可后的数据。</p><p>2.在进行决策点评审（主要是概念决策评审）时，对照路标和0级计划、1级计划，检查是否在规划范围内以及时间偏差，在会议纪要中说明：<br>(1) 本版本是否计入非正常增删版本数；<br>(2) 本版本是否计入未按路标执行的版本数；<br>(3) 本版本启动时间与规划的时间偏差（天）；<br>(4) 本版本与路标偏差的情况分析（包括情况说明、反映出的问题、改进措施等）。</p><h2 id="行为指标"><a href="#行为指标" class="headerlink" title="行为指标"></a>行为指标</h2><p>行为指标是研发过程中对正确职业行为的评价指标。</p><p>正确的路径还需要有正确的行为方式，许多公司重视研发过程性内容的积累和知识共享平台的搭建，这些内容就要求员工在研发的过程中关注文档的积累、数据的准确、程序的明晰记录等等。因此，可以设置文档完整率、项目报告完整性、数据差错分析等指标，以提出对研发人员具体行为的要求，这些也是许多职业化通道方案设计时需要分析的内容。如果公司已经建立了研发人员的职业发展路径标准，许多行为指标是可以从中提炼的。</p><h2 id="效益指标"><a href="#效益指标" class="headerlink" title="效益指标"></a>效益指标</h2><p>作为经济性的组织，任何一个研发成果都必须在市场上实现价值，效益指标就是用来评价产品对公司带来的价值和客户对其的认同度，例如产品销售额、市场占有率、客户满意度、产品故障率等等。由于这些指标具有明显的滞后性，不能即期反映研发的成果，因此，这种指标的使用更多要和公司的中期激励方案相结合，具有明显的项目制考核指标的特点。</p><p>同时，效益指标不适用于研发部门的个人考核，因为研发成果往往是团队合作的产物，作为部门、事业部、项目开发团队的考核更为合适。</p><h2 id="如何选择考核方式"><a href="#如何选择考核方式" class="headerlink" title="如何选择考核方式"></a>如何选择考核方式</h2><p>研发工作由于贡献特点和侧重点不同，在考核方式上可重点区分部门团队考核与员工个人考核两种。</p><h3 id="部门团队考核"><a href="#部门团队考核" class="headerlink" title="部门团队考核"></a>部门团队考核</h3><p>在研发工作中，部门、团队为基本的业务单元，对直接产品和最终产品的市场价值负有责任。因此，对部门、团队考核侧重的要素为效益指标和路径指标。但因为效益指标的滞后性问题，在整体的考核周期的设计上需要认真考虑以下两点：</p><ul><li>对于效益指标，采取按项目周期进行考核的方式。许多研发成果的好坏是在项目结束之后一段时间体现出来，这部分指标的考核要在这个周期之后进行。</li><li>对于路径指标，采取按固定时间段进行考核的方式，多数为季度，以保证产品的研发过程符合公司预定的目标。</li></ul><p>其中，路径指标占整体考核成绩的50％～70％，甚至更高，以体现公司的业绩导向和市场导向。为此，公司在奖金分配制度上也需要做相应的考虑，以配合这样的考核方式。</p><h3 id="员工个人"><a href="#员工个人" class="headerlink" title="员工个人"></a>员工个人</h3><p>由于研发成果更多属于团队合作的结果，每位研发人员只是负责最终成果的某个功能模块或某个环节，甚至有的研发人员不清楚自己的工作输出在最终产品中所起到的作用。他们的考核主要侧重点在于行为指标和路径指标。因此，结合这种工作特点和考核侧重点，可以采用PBC（Personal Business Commitment个人业绩承诺）评价方式。PBC的程序是：设定清晰的目标，并承诺为实现目标采取的具体策略和措施，以及对团队建设的贡献，并通过对这些承诺进行评价来考核研发人员。</p><p>PBC的重要特点就是将目标与实现的行为要素紧密结合起来，更像是一种计划考核，强调了行为和团队合作的重要性。其具体操作方式如下：</p><h2 id="建立PBC目标"><a href="#建立PBC目标" class="headerlink" title="建立PBC目标"></a>建立PBC目标</h2><p>考核周期（一般为季度）之初，直接主管或是项目组组长交流部门或是项目组的工作目标，然后员工根据团队目标制定个人的工作目标。这些目标应该是简洁、易于考核、基于结果的，一般通过WIN、EXECUTE、TEAM三个层次来表达:</p><ul><li>赢的承诺：为了支持部门或是项目组工作目标的完成，你必须做些什么。指标主要是行为指标和路径指标的结合。</li><li>执行的承诺：通过什么方法完成你赢的承诺呢？必须分析为了达成目标，需要采取的策略、方法以及对工具的需求，形成清晰的执行方案，并且有明确的时间限制和规定，若承诺按照计划按时执行，就能保证实现赢的承诺。</li><li>团队的承诺：为了同团队成员更好地合作，更加高效地完成赢和执行的承诺，员工应该做些什么。高效的团队工作需要有好的交流、参与、理解和相互支持，以一个整体去完成工作，保证团队成果的实现。PBC的举例见表二。</li></ul><p><img src="/gallery/rd1.jpg" alt="绩效PBC目标" title="绩效PBC目标"></p><h2 id="过程辅导"><a href="#过程辅导" class="headerlink" title="过程辅导"></a>过程辅导</h2><p>任何绩效考核工作都不是秋后算帐的评判，在工作的执行过程中，主管要即时给予员工支持和辅导，帮助员工解决问题和提升能力，这一点在一般的考核评价方式中都有介绍，在此不再赘述。</p><h2 id="考核评价"><a href="#考核评价" class="headerlink" title="考核评价"></a>考核评价</h2><p>依据考核周期之初确定的业绩承诺，主管对员工的整个工作情况进行评价，员工的绩效考核以目标完成结果为依据，考核的等级将影响员工的价值回报。</p><h2 id="部门团队与个人考核的关系"><a href="#部门团队与个人考核的关系" class="headerlink" title="部门团队与个人考核的关系"></a>部门团队与个人考核的关系</h2><p>部门团队的考核与员工个人的考核虽然在考核周期和侧重点上不同，但两者不是孤立的，只有员工个人的业绩达成了，才能保证整个组织绩效的实现。为此，针对部门团队绩效考核的中期激励方案必须体现出员工个人的价值回报，保证两者成为有机的整体。</p><p><a href="https://www.toutiao.com/a6511671010184397325/?iid=20677887087&amp;app=news_article&amp;wxshare_count=1&amp;tt_from=weixin&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;utm_campaign=client_share" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多企业的绩效考核工作常常会面临这样的问题：相对其他部门，研发部门的考核指标提取、考核方式确定都有一定的难度。这也是人力资源专业人员和研发部门管理者困惑的难题。&lt;br&gt;
    
    </summary>
    
      <category term="management" scheme="/categories/management/"/>
    
    
      <category term="java,class loader,类加载器" scheme="/tags/java-class-loader-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何快速搭建linux运行环境</title>
    <link href="/2018/11/26/quickly-set-up-linux-in-virtualbox/"/>
    <id>/2018/11/26/quickly-set-up-linux-in-virtualbox/</id>
    <published>2018-11-26T05:54:44.837Z</published>
    <updated>2018-02-09T14:54:36.963Z</updated>
    
    <content type="html"><![CDATA[<p>对于程序员来说，很可能用linux作为服务器运行环境，为了提前发现问题不可避免的需要搭建一套linux运行环境，此文给出一个可行、快速且经济的解决方案。</p><a id="more"></a><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>在VirtualBox中安装好CentOS 7 </li><li>可实现主机到虚机的双向复制和文件共享</li></ul><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>win7</li><li>VirtualBox 5.2.6</li><li>CentOS 7 32位镜像</li></ul><h2 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h2><h3 id="1-下载VirtualBox"><a href="#1-下载VirtualBox" class="headerlink" title="1 下载VirtualBox"></a>1 下载VirtualBox</h3><p>打开<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">virtualbox官网</a> ，选择windows hosts下载到本地，安装完成进行到下一步。</p><h3 id="2-下载Linux镜像"><a href="#2-下载Linux镜像" class="headerlink" title="2 下载Linux镜像"></a>2 下载Linux镜像</h3><p>打开<a href="https://www.osboxes.org/virtualbox-images/" target="_blank" rel="noopener">osboxes官网</a> ,打开CentOS链接，找到linux 32bit下载。也可以下载64bit据自身机器情况而定。</p><h3 id="3-创建虚拟电脑"><a href="#3-创建虚拟电脑" class="headerlink" title="3 创建虚拟电脑"></a>3 创建虚拟电脑</h3><p>打开VirtualBox-&gt;新建-&gt;CentOS-&gt;…-&gt;使用已有虚拟硬盘-&gt;选择已下载的Linux镜像*.vdi文件-&gt;..-&gt;直至完成。</p><h3 id="4-系统初始化设置"><a href="#4-系统初始化设置" class="headerlink" title="4 系统初始化设置"></a>4 系统初始化设置</h3><p>按提示进行系统设置，最后输入osboxes.org作为用户密码，登入Linux系统即完成搭建。</p><h3 id="5-安装增强功能"><a href="#5-安装增强功能" class="headerlink" title="5 安装增强功能"></a>5 安装增强功能</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>设备-&gt;安装增强功能-&gt;直至完成。</p><h5 id="设置共享剪切板"><a href="#设置共享剪切板" class="headerlink" title="设置共享剪切板"></a>设置共享剪切板</h5><p>设备-&gt;共享剪切板-&gt;双向</p><h5 id="设置共享目录"><a href="#设置共享目录" class="headerlink" title="设置共享目录"></a>设置共享目录</h5><p>设备-&gt;共享文件夹-&gt;设置共享目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--挂载</span><br><span class="line">mount -t vboxsf hostDirectoryName virtualDirectoryPath</span><br><span class="line">--解挂</span><br><span class="line">umount virtualDirectoryPath</span><br></pre></td></tr></table></figure><h5 id="挂载解决办法"><a href="#挂载解决办法" class="headerlink" title="挂载解决办法"></a>挂载解决办法</h5><p>问题：/sbin/mount.vboxsf: mounting failed with the error: No such device</p><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum update</span><br><span class="line">yum install kernel</span><br><span class="line">yum install kernel-devel</span><br><span class="line">yum install kernel-headers</span><br><span class="line">yum install gcc</span><br><span class="line">yum install make  </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/daiyudong2020/article/details/58073520" target="_blank" rel="noopener">参考</a></p><h2 id="3-延伸阅读"><a href="#3-延伸阅读" class="headerlink" title="3  延伸阅读"></a>3  延伸阅读</h2><h3 id="设置系统启动后进入文本界面："><a href="#设置系统启动后进入文本界面：" class="headerlink" title="设置系统启动后进入文本界面："></a>设置系统启动后进入文本界面：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-default multi-user.target</span><br></pre></td></tr></table></figure><h3 id="设置系统启动后进入图形界面："><a href="#设置系统启动后进入图形界面：" class="headerlink" title="设置系统启动后进入图形界面："></a>设置系统启动后进入图形界面：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-default graphical.target</span><br></pre></td></tr></table></figure><h3 id="重启系统："><a href="#重启系统：" class="headerlink" title="重启系统："></a>重启系统：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot</span><br></pre></td></tr></table></figure><h3 id="以文本界面启动后，执行以下命令启动图形界面："><a href="#以文本界面启动后，执行以下命令启动图形界面：" class="headerlink" title="以文本界面启动后，执行以下命令启动图形界面："></a>以文本界面启动后，执行以下命令启动图形界面：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure><h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><p>Ctrl + Alt + F2  切换到文本界面<br>Ctrl + Alt + F1  切换到图形界面<br>Ctrl + Alt + backspace 重启当前图形界面</p><p><a href="https://www.ifshow.com/centos-7-switching-graphical-and-text-interface/" target="_blank" rel="noopener">参考</a></p><h3 id="进入setting设置termial终端打开快捷键为alt-F12"><a href="#进入setting设置termial终端打开快捷键为alt-F12" class="headerlink" title="进入setting设置termial终端打开快捷键为alt+F12"></a>进入setting设置termial终端打开快捷键为alt+F12</h3><p>Setthings-&gt;Keyboard-&gt;add command-&gt;Name “Terminal” Command “/usr/bin/gnome-terminal”-&gt;Shortcuts-&gt;输入alt+F12。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于程序员来说，很可能用linux作为服务器运行环境，为了提前发现问题不可避免的需要搭建一套linux运行环境，此文给出一个可行、快速且经济的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="linux,VirtualBox,VirtualBox image,CentOS" scheme="/tags/linux-VirtualBox-VirtualBox-image-CentOS/"/>
    
  </entry>
  
  <entry>
    <title>ORM常用的设计模式</title>
    <link href="/2018/11/26/orm-common-pattern/"/>
    <id>/2018/11/26/orm-common-pattern/</id>
    <published>2018-11-26T05:54:44.818Z</published>
    <updated>2018-01-12T09:16:20.151Z</updated>
    
    <content type="html"><![CDATA[<p>ORM(Object Relational Mapping)即对象关系映射，一种用于实现对象语言与不同类型的关系型数据之间的转换。</p><a id="more"></a><p>我们讨论该问题目的在于如何让我们系统中的对象与数据库进行交互。由于数据库与对象之间存在着结构上的差异，Mapping是相当困难的。不推荐开发人员自己进行Mapping Layer的开发，这是危险的也是及其可能失败的。更加推荐购买专业的工具，虽然这些工具通常很昂贵。到目前为止，我所接触的项目确实有Mapping layer，但它并不是典型的Mapping layer between Relational Database and Object，它是处于JSP页面与Database之间的Mapping，用于自动地将用户在页面上填写的数据更新到数据库中。这在Web项目中是很好用的，但目前这个Mapping Layer还不能做到general，它只能适用与特定的Web Application架构。</p><p>下面开始与大家聊聊三种Database Mapping层的常用的系统架构。 </p><h2 id="1-网关模式（Gateway）"><a href="#1-网关模式（Gateway）" class="headerlink" title="1. 网关模式（Gateway）"></a>1. 网关模式（Gateway）</h2><p>之所以称之“网关”，顾名思义，Mapping层扮演着一个代理的角色，应用逻辑层无需知道具体Mapping的细节，而只需通过网关的公共接口，提交数据更新或者数据加载请求，由网关去执行具体的Object到Record或者Record到Object的转换。从而实现了数据层的透明。应用逻辑层所要了解的只有网关的信息和其公共接口。使用公共接口同时有助应用逻辑代码在不同的数据层的复用：无需改变应用逻辑层的任何代码，只需为特定的数据层实现特定的网关。网关模式具体分为两种：Row Data Gateway &amp; Table Data Gateway </p><p>共同的特点： </p><p>对应于数据库中的每个Table，有一个Mapping Class，并且在这个class中每个column有其对应的字段；所有的数据库mapping代码都存在于在Mapping Class之中，使数据库访问代码与应用逻辑完全分离； </p><h3 id="Row-Data-Gateway"><a href="#Row-Data-Gateway" class="headerlink" title="Row Data Gateway"></a>Row Data Gateway</h3><p>Mapping Class是一个对应于数据库中某张表格的一条记录。记录的每个字段对应于Class中的一个Field。所有访问数据的细节都被封装在这个接口中。Row Data Gateway与Transaction Script配合使用，效果很好 </p><p>典型案例: Java中的SessionBean（Transaction Script）和EntityBean（Row Data Gateway） </p><p>适用情况：应用逻辑相对复杂，对象与对象之间交互繁多的大规模系统； </p><h3 id="Table-Data-Gateway："><a href="#Table-Data-Gateway：" class="headerlink" title="Table Data Gateway："></a>Table Data Gateway：</h3><p>这个接口定义了关于某个Table的所有查询（find），更新，插入和删除代码。Table Data Gateway将输入的参数mapping成对应的SQL，并执行SQL，最后返回适当的数据结构。如何返回Query的信息是一个具有欺骗性的决策问题。当需要返回多个记录并且函数只允许返回一个结果时，你将面临着多种选择：Map &amp; Data Transfer Object &amp; Record Set。 </p><p>Map：不是一个好方法，map中的Key常常是一种HardCode； </p><p>Data Transfer Object：是避免map的一个方法，并且可以被重用； </p><p>Record Set：虽然会使Business Logic Layer不能完全与数据库访问层相分离，但是如果我们的开发平台有很多基于Record Set的工具，采用它不失为一个好方法（.NET）。 </p><p>典型案例：Window DNA架构； </p><p>适用情况：以显示信息，修改信息为功能的MIS（信息管理系统）； </p><h2 id="2-活动记录模式（Active-Record）"><a href="#2-活动记录模式（Active-Record）" class="headerlink" title="2. 活动记录模式（Active Record）"></a>2. 活动记录模式（Active Record）</h2><p>将Business Logic与数据库访问放置于同一个Business Object中。这种模式出现的原因是业务逻辑与数据库模型非常相似。Active Record同时负责数据库存取和基于这些数据的应用逻辑的执行。应用程序的所有逻辑可以都在Active Record中，也可以是部分。有一点是默认前提，Active Record的数据结构和数据库Schema必须保持一致（在我看来这是个缺点！） </p><p>Active Record中通常有以下方法： </p><p>从SQL数据集创建Active Record的构建方法； </p><p>静态的finder方法用于封装SQL查询并且返回Active Record记录； </p><p>用Active Record中的数据更新数据库的方法； </p><p>所有字段getting和settting方法； </p><p>实现应用逻辑的方法； </p><p>活动记录模式的优点在于简单，其缺点在于没有隐藏数据库层，从而导致很难应用其他OR Mapping模式在活动记录模式之上。另外一方面，活动记录模式与Row Data Gateway的区别在于数据库存取代码是在Business Object中（Active Record）还是在一个单独的Mapping Class中（Row Data Gateway），当然也有同时存在于两者的情况；如果应用逻辑的复杂程度迫使你适用面向对象的一些机制（Direct relationships，collections and Inheritance），这时直接将数据库存取代码置于Business Object中，由于有大量的转换，会使事情变得混乱，这时应该适用Data Mapper。</p><p>但这并不是个好方法，因为它将面向对象设计和数据库设计紧密耦合在一起，这随着项目进展会使对设计的重构工作变得及其困难。通常我们会将数据库访问代码分离到一个Gateway中。有一种情况例外，当你对Transaction Script &amp; Row Data Gateway的架构进行重构的时候，为了去除Transaction Script中的重复代码，将其放进Row Data Gateway中，这是就转变成Active Record了。 </p><p>适用情况：当应用逻辑不复杂，主要是创建，更新，插入，删除操作，而且操作主要是针对单条记录时； </p><h2 id="3-数据映射模式（Data-Mapper）"><a href="#3-数据映射模式（Data-Mapper）" class="headerlink" title="3. 数据映射模式（Data Mapper）"></a>3. 数据映射模式（Data Mapper）</h2><p>这是最复杂，但最灵活的一种架构模式。使用Data Mapper，Business Objects可以与数据库结构完全的分离，他们无需知道数据库的结构和数据更新的细节。Data Mapper对于那些无法在关系型数据库表示的对象系统特性非常有效，例如Collection成员结构和继承关系。Data Mapper是内存中对象与数据库之间的媒介。它负责双方之间的数据传输。数据映射模式（Data Mapper）与网关模式最大的（Gateway）最大的区别在于依赖和控制的位置相反。在网关模式中，应用逻辑层需要了解数据库中的数据结构，二在数据映射模式中，应用逻辑无需了解数据库设计，提高了应用层（business logic）和数据层（data source）的分离，便于两者的开发和测试。</p><p>面向对象的对象系统与面向关系的关系型数据库是两种异构的结构，因此在对象系统中的很多机制（collections, inheritance等）都无法在关系型数据库中得到直接的表示，这就是数据映射模式产生的原因。在这种情况下，在两种模式下的数据转换变得相当复杂，因此我们有必要将它分层，否则任何一方（对象系统和数据库）的改变都将波及对方。 </p><p>数据映射层的最大目标就是将业务逻辑（domain）和数据层（data source）分离。整个数据映射层（Data Mapper）完全独立于系统其他部分，可以被完全替换或者允许一个逻辑层重用于不同的数据层上。但要实现它有很多重要的问题必须解决，而且不同人可以采用不同的方法实现这个数据映射模式（Data Mapper）。因此这里只介绍几个重要的实现问题。 </p><h3 id="①-Finder方法的处理"><a href="#①-Finder方法的处理" class="headerlink" title="① Finder方法的处理"></a>① Finder方法的处理</h3><p>处理方法： </p><p>在一个独立的Package中，为Finder方法定义一个接口，然后在数据映射层实现这个接口。逻辑层通过接口调用Finder方法，后者通过数据映射层加载数据。 </p><p>原因：之所以使用接口的原因，在于使Finder方法标准化，这样应用逻辑层虽然可能在任何地方都会调用Finder方法取得带有数据的Business Object，但却不依赖于数据映射层。 </p><p>Finder方法：将方法调用转换成SQL查询； </p><p>数据映射层：从数据集中获得数据并创建Business Object； </p><p>遗留问题： </p><p>数据映射层如何知道那些Object被更新了，哪些被创建，哪些被删除了？ </p><p>如何控制每次查询获得的记录数，以尽量减少查询的数目？ </p><p>其他模式如何用在数据映射层（Lazy Load, Registry, Identity Map）? </p><h3 id="②-如何将数据映射到Business-Object的字段中"><a href="#②-如何将数据映射到Business-Object的字段中" class="headerlink" title="② 如何将数据映射到Business Object的字段中"></a>② 如何将数据映射到Business Object的字段中</h3><p>数据映射层需要访问Business Object的所有字段，因此这些方法必须被设置为public，但这不不是我们所预想的。这个问题没有明确的答案，几种可选的方法都有两面性。 </p><ul><li>将数据映射层于逻辑层放置于同一个包下 </li></ul><p>缺点：有可能使事情变得更混乱； </p><ul><li>使用Reflection方法来访问Object的字段 </li></ul><p>缺点：速度慢； </p><p>增加状态标志来保证在数据库加载环境下访问这些字段 </p><p>针对这个问题，在创建Business Object的时候，你有两个选择，使用胖构造函数（这个名词是我自己取的:^)）空构造函数。 </p><ul><li>胖构造函数（Rich Constructor） </li></ul><p>优点：保证Object至少包含必须的数据；对于常量字段，无需setting方法； </p><p>缺点：必须考虑循环引用问题（cyclic reference）； </p><ul><li>空构造函数（Empty Constructor） </li></ul><p>优点：不会出现循环引用问题（cyclic reference）； </p><p>缺点：对于常量字段，仍然需要setting方法，可能引入潜在错误； </p><h3 id="③-基于元数据的映射（Metadata-based-Mapping）"><a href="#③-基于元数据的映射（Metadata-based-Mapping）" class="headerlink" title="③ 基于元数据的映射（Metadata based Mapping）"></a>③ 基于元数据的映射（Metadata based Mapping）</h3><ul><li>显式代码：这要求每个Business Object有一个Mapping class； </li><li>Metadata Mapping：元数据被存储在单独的class和文件中，我倾向于文件，随着xml的广泛使用，以XML形式存储元数据会增强移植性； </li></ul><h2 id="3种OR-Mapping架构模式的取舍和选用"><a href="#3种OR-Mapping架构模式的取舍和选用" class="headerlink" title="3种OR Mapping架构模式的取舍和选用"></a>3种OR Mapping架构模式的取舍和选用</h2><p>OR Mapping架构取决于应用逻辑层的架构。如果使用表模式（Table Module）来组织应用逻辑，那么Table Data Gateway是你的最佳选择；如果使用Transaction Script模式来组织应用逻辑，那么如果开发平台提供了使用数据集的方便就采用Table Data Gateway，否则采用Row Data Gateway；如果是使用Domain Model来建立应用逻辑模型，那么对于复杂的大系统，颖毫不犹豫地选择数据映射模式，对于逻辑简单的小系统，Active Record也是一个可选方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ORM(Object Relational Mapping)即对象关系映射，一种用于实现对象语言与不同类型的关系型数据之间的转换。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="orm,gateway pattern, active record pattern, data mapper pattern,对象关系映射， 网关模式, 活动记录模式 , 数据映射模式" scheme="/tags/orm-gateway-pattern-active-record-pattern-data-mapper-pattern-%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%EF%BC%8C-%E7%BD%91%E5%85%B3%E6%A8%A1%E5%BC%8F-%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F-%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>nodejs常用命令</title>
    <link href="/2018/11/26/nodejs-usefully-command/"/>
    <id>/2018/11/26/nodejs-usefully-command/</id>
    <published>2018-11-26T05:54:44.809Z</published>
    <updated>2018-01-22T04:38:36.864Z</updated>
    
    <content type="html"><![CDATA[<p>收集平时常用的一些nodejs命令。<br><a id="more"></a></p><h2 id="怎样升级node版本"><a href="#怎样升级node版本" class="headerlink" title="怎样升级node版本"></a>怎样升级node版本</h2><h3 id="Linux-Mac"><a href="#Linux-Mac" class="headerlink" title="Linux/Mac"></a><a href="https://stackoverflow.com/questions/10075990/upgrading-node-js-to-latest-version" target="_blank" rel="noopener">Linux/Mac</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line">sudo n 0.12.2</span><br></pre></td></tr></table></figure><p>升级到稳定版本:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n stable</span><br></pre></td></tr></table></figure></p><p>升级到最近版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n latest</span><br></pre></td></tr></table></figure></p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>从node官网下载.msi重新安装即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集平时常用的一些nodejs命令。&lt;br&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="nodejs,nodejs命令" scheme="/tags/nodejs-nodejs%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>mybatis列映射的几种方式</title>
    <link href="/2018/11/26/mybatis-columns-mapping/"/>
    <id>/2018/11/26/mybatis-columns-mapping/</id>
    <published>2018-11-26T05:54:44.788Z</published>
    <updated>2018-01-12T09:20:30.837Z</updated>
    
    <content type="html"><![CDATA[<p>不同于hibernate实现活动记录模式，mybatis实现了数据映射模式，其中列的映射有多种实现方式，有简单的也有复杂的，分别适用不同的业务场景</p><a id="more"></a><h2 id="1-使用注解-Results和-Result"><a href="#1-使用注解-Results和-Result" class="headerlink" title="1. 使用注解@Results和@Result"></a>1. 使用注解@Results和@Result</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM users"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"firstName"</span>, column = <span class="string">"first_name"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"lastName"</span>, column = <span class="string">"last_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM users"</span>)</span><br><span class="line">    <span class="meta">@ResultMap</span>(<span class="string">"BaseResultMap"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML配置如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"package.for.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"firstName"</span>, <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"lastName"</span>, <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>优点</li></ul><p>映射关系简单明了</p><ul><li>缺点</li></ul><p>相同实体类型的返回变多之后，注解的工作量加大，容易不同步和出错</p><p>避免重复的话，需要与XML配置结合，如此一来，由于使用两种方式感觉麻烦了</p><h2 id="2-使用别名"><a href="#2-使用别名" class="headerlink" title="2. 使用别名"></a>2. 使用别名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT first_name as firstName, last_name as lastName FROM users"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(&#123;</span><br><span class="line">            <span class="string">"SELECT"</span>,</span><br><span class="line">            <span class="string">"  first_name as firstName,"</span>,</span><br><span class="line">            <span class="string">"  last_name as lastName"</span>,</span><br><span class="line">            <span class="string">"FROM users"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点</li></ul><p>最直接，简单明了</p><ul><li>缺点</li></ul><p>多人开发，可能带来db命名的不规范</p><h2 id="3-使用全局配置"><a href="#3-使用全局配置" class="headerlink" title="3. 使用全局配置"></a>3. 使用全局配置</h2><p>在application.properties中，增加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.mapUnderscoreToCamelCase=true</span><br></pre></td></tr></table></figure></p><p>或者使用自定义配置Bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">ConfigurationCustomizer <span class="title">mybatisConfigurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">            configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>优点</li></ul><p>全局设置之后，只要遵守下划线映射到驼峰命名规范，就省出了大量的手动映射工作</p><ul><li>缺点</li></ul><p>对已有老系统无按此规则的db，无法映射</p><h2 id="4-使用XML映射"><a href="#4-使用XML映射" class="headerlink" title="4. 使用XML映射"></a>4. 使用XML映射</h2><p>XML配置如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"package.for.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"firstName"</span>, <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"lastName"</span>, <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  SELECT * FROM users WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers1"</span> <span class="attr">resultType</span>=<span class="string">"package.for.User"</span>&gt;</span></span><br><span class="line">  SELECT * FROM users WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>java就不需要再一一配置了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>优点</li></ul><p>字段映射关系和对象完全分离</p><ul><li>缺点</li></ul><p>XML硬编码，维护内容多时容易出错</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上各种方法各有优劣，完全注解方式硬编码少，维护不容易出错。完全XML方式更加灵活，可以发布之后变动。具体使用单个或者混合方式取决于具体业务场景。</p><p>参考:<br><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">MyBatis-Spring-Boot-Starter介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不同于hibernate实现活动记录模式，mybatis实现了数据映射模式，其中列的映射有多种实现方式，有简单的也有复杂的，分别适用不同的业务场景&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,mybatis,columns mapping,列映射" scheme="/tags/java-mybatis-columns-mapping-%E5%88%97%E6%98%A0%E5%B0%84/"/>
    
  </entry>
  
</feed>
