<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Footprint</title>
  
  <subtitle>Jes&#39; footprint</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2017-10-19T01:12:36.551Z</updated>
  <id>/</id>
  
  <author>
    <name>jes shaw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为Spring设置restful基础路径</title>
    <link href="/2018/11/26/spring-restcontrooler-specific-basepath/"/>
    <id>/2018/11/26/spring-restcontrooler-specific-basepath/</id>
    <published>2018-11-26T05:54:44.936Z</published>
    <updated>2017-10-19T01:12:36.551Z</updated>
    
    <content type="html"><![CDATA[<p>由于某些原因，我们会把前端和后端的放在一个站点上，但如果前后端不做分离的话，随着时间推移代码会难以维护。因此就想把静态内容放和后端的接口分开放置，来达到分离的效果。<br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>希望spring有如下URL结构  </p><p>/index.html – 静态页<br>/api/user – rest控制器的所有api放在api下</p><p>因为是针对所有的RestControllers增加api，而静态页不变，所以有以下两种思路：</p><ul><li>基于RestController类增加Spring配置</li><li>重写RestController注解</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="基于RestController类增加Spring配置"><a href="#基于RestController类增加Spring配置" class="headerlink" title="基于RestController类增加Spring配置"></a>基于RestController类增加Spring配置</h3><p>目录结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcRegistrationsAdapter <span class="title">webMvcRegistrationsHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcRegistrationsAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">getRequestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RequestMappingHandlerMapping() &#123;</span><br><span class="line">                    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String API_BASE_PATH = <span class="string">"api"</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, RequestMappingInfo mapping)</span> </span>&#123;</span><br><span class="line">                        Class&lt;?&gt; beanType = method.getDeclaringClass();</span><br><span class="line">                        <span class="keyword">if</span> (AnnotationUtils.findAnnotation(beanType, RestController.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            PatternsRequestCondition apiPattern = <span class="keyword">new</span> PatternsRequestCondition(API_BASE_PATH)</span><br><span class="line">                                    .combine(mapping.getPatternsCondition());</span><br><span class="line"> </span><br><span class="line">                            mapping = <span class="keyword">new</span> RequestMappingInfo(mapping.getName(), apiPattern,</span><br><span class="line">                                    mapping.getMethodsCondition(), mapping.getParamsCondition(),</span><br><span class="line">                                    mapping.getHeadersCondition(), mapping.getConsumesCondition(),</span><br><span class="line">                                    mapping.getProducesCondition(), mapping.getCustomCondition());</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">super</span>.registerHandlerMethod(handler, method, mapping);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写RestController注解"><a href="#重写RestController注解" class="headerlink" title="重写RestController注解"></a>重写RestController注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestApiController &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@AliasFor</span>(annotation = RequestMapping.class, attribute = <span class="string">"value"</span>)</span><br><span class="line"> String[] value();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestApiController</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        User.setText(<span class="string">"User api"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于某些原因，我们会把前端和后端的放在一个站点上，但如果前后端不做分离的话，随着时间推移代码会难以维护。因此就想把静态内容放和后端的接口分开放置，来达到分离的效果。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,restful,base path,基础路径" scheme="/tags/java-spring-restful-base-path-%E5%9F%BA%E7%A1%80%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>spring中如何穿透多层共享公用信息</title>
    <link href="/2018/11/26/spring-penetrate-layers/"/>
    <id>/2018/11/26/spring-penetrate-layers/</id>
    <published>2018-11-26T05:54:44.920Z</published>
    <updated>2017-11-13T06:07:10.219Z</updated>
    
    <content type="html"><![CDATA[<p>在实际应用中较多使用的还是是三层架构，主要是因为在程序员圈中，易理解，通用性高。不过各人理解不同使用起来存在差异，就比方说公用信息共享的问题，展示层共享较好理解，那业务层和数据层怎共享呢？<br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如何在各层之间共享公用信息？即要兼顾性能，还要考虑效率和易维护性。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先来说说疑虑，很长一段时间，因为三层都是以子项目来划分，共享公用信息就不自觉的使用方法传参的方式实现，随得需求和时间的增长，各个方法都会带上公用信息参数。如此一来，<strong>自上而下的公用信息从展示一直传递到数据层</strong>。问题解决了，但带来了一个新的重复的问题：即所有用到公用信息的地方都得增加该参数。</p><p>传参的方式还可以用继承基类的方式实现，即所有的<strong>参数继承某个基类，基类中有共享信息的引用</strong>，但此方案还是换汤不换药，仅是传参数少了，重复的问题依然存在。</p><p>以上两种方案都未能较好的解决共享公用信息的问题，以致于觉得问题出在架构层，把三层换成微内核心架构或者域驱动模型架构。但是无论架构怎么变，层之间的共享信息问题似乎总是存在，只是重复率高低问题。</p><p>最近从更高的层面来了看待这个问题，就迎刃而解了。一个程序启动于一个主进程，进程中可以启动多个线程。也就是主进程就是一直存在的，若<strong>主进程中共享公用信息</strong>，那么就可以达到穿透多层共享公用信息的问题。</p><p>spring中则是通过公用子项目，初始化一个对象到应用上下文（理解为主进程），在需要的任何层注入该对象即达到了共享公用信息的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际应用中较多使用的还是是三层架构，主要是因为在程序员圈中，易理解，通用性高。不过各人理解不同使用起来存在差异，就比方说公用信息共享的问题，展示层共享较好理解，那业务层和数据层怎共享呢？&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,share,base path,基础路径" scheme="/tags/java-spring-share-base-path-%E5%9F%BA%E7%A1%80%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring面试问题</title>
    <link href="/2018/11/26/spring-interview-questions/"/>
    <id>/2018/11/26/spring-interview-questions/</id>
    <published>2018-11-26T05:54:44.896Z</published>
    <updated>2017-10-30T07:04:24.223Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架是最受欢迎的Java企业级web应用框架。<em>依赖注入</em>和<em>面象方面</em>是<em>Spring框架</em>的核心。<br><a id="more"></a></p><p>我最近提交了许多<a href="https://www.journaldev.com/2888/spring-tutorial-spring-core-tutorial" target="_blank" rel="noopener">Spring教程</a>，它将有助于帮你详细的解释Spring面试问题的核心概念。</p><h2 id="Spring面试问题列表"><a href="#Spring面试问题列表" class="headerlink" title="Spring面试问题列表"></a>Spring面试问题列表</h2><ol><li>Spring框架是什么？</li><li>Spring框架有些什么重要的特性和优势？</li><li>你对依赖注入的理解是什么？</li><li>Spring框架中怎么样实现依赖注入？</li><li>使用Spring工具套件有什么好处？</li><li>重要的Spring模块名称有哪些？</li><li>你对面向切面编程的理解是什么？</li><li>AOP中的Aspect, Advice, Pointcut, JointPoint and Advice Arguments是什么？</li><li>Spring AOP 和AspectJ AOP有什么区别？</li><li>Spring IoC容器是什么？</li><li>Spring Bean是什么？</li><li>Spring Bean配置文件的重要性是什么？</li><li>把一个类配置成Spring Bean有些什么不同方法？</li><li>Spring Bean有些什么不同作用域？</li><li><a href="#spring-bean-life-cycle">Spring Bean生命周期是什么？</a></li><li>在Spring Bean中怎么获得ServletContext和ServletConfig对象</li><li>Bean装配和@Autowired注解是什么？</li><li>Spring Bean自动装配有几种不同类型？</li><li>Spring Bean是线程安全的吗？</li><li>在Spring MVC的Controller是什么？</li><li>在Spring中 @Component, @Repository 和 @Service注解有什么区别？</li><li>DispatcherServlet 和 ContextLoaderListener是什么？</li><li>在Spring中的ViewResolver是什么？</li><li>MultipartResolver是什么？什么时候使用？</li><li>Spring MVC框架怎样处理异常？</li><li>在Java程序中怎样创建ApplicationContext？</li><li>能有多个Spring配置文件吗？</li><li>ContextLoaderListener是什么？</li><li>为了创建Spring MVC应用，至少需要配置什么？</li><li><a href="#spring-mvc-architecture">相对与MVC架构，你对Spring MVC框架的理解是怎样的？</a></li><li>Spring MVC应用怎样实现平地化？</li><li>使用Spring怎样创建Restful Web服务并返回JSON？</li><li>你使用过哪些重要的Spring注解？</li><li>我们可以发送一个Object作为Controller handler方法的响应吗？</li><li>Spring MVC应用怎样上传文件？</li><li>Spring Web MVC架构怎样验证表单数据？</li><li>Spring MVC拦截器（Interceptor）是什么？怎样使用？</li><li>Spring JdbcTemplate类是什么？怎样使用？</li><li>Spring Web应用中怎样使用Tomcat JNDI数据资源？</li><li>在Spring中怎样实现事务管理？</li><li>Spring DAO是什么？</li><li>怎样集成Spring和Hibernate框架？</li><li>Spring Security是什么？</li><li>怎样注入一个java.util.Properties到Spring Bean？</li><li>Spring框架使用哪些设计模式？</li><li>Spring框架有些什么最佳实践？</li></ol><h2 id="Spring面试问题及答案"><a href="#Spring面试问题及答案" class="headerlink" title="Spring面试问题及答案"></a>Spring面试问题及答案</h2><h3 id="1-Spring框架是什么？"><a href="#1-Spring框架是什么？" class="headerlink" title="1. Spring框架是什么？"></a>1. Spring框架是什么？</h3><p>Spring是使用最为广泛的Java企业级框架。 Spring框架是“依赖注入”和“面向切面编程”。</p><p>Spring框架可以用于一般的java应用中。通过依赖注入的实现不同组件中的松耦合，使用Spring支持的面向切面编程我们可以像日志和认证那样跨截面执行任务。</p><p>我喜欢Spring是因它提供了许多特性和不同的功能模块，如Spring MVC和Spring JDBC。由于它是开源的，有许多在线资源和活跃的社区，使用Spring框架，在相同的时间内，工作起来更加的容易和有趣。</p><h3 id="2-Spring框架有些什么重要的特性和优势？"><a href="#2-Spring框架有些什么重要的特性和优势？" class="headerlink" title="2. Spring框架有些什么重要的特性和优势？"></a>2. Spring框架有些什么重要的特性和优势？</h3><p>Spring框架是基于“依赖注入”和“面向切面编程”两个设计概念建立。</p><p>Spring框架有如下特性：  </p><ul><li>对开发来讲使用该框架有极少的开销，且它是一个轻量级的框架。  </li><li>依赖注入和控制反转编写的组件是相互独立的，Spring容器负责一起装配组件，帮助实现我们的工作。  </li><li>Spring IoC容器管理Spring Bean的生命周期和规划具体的配置，如JNDI查找。 </li><li>Spring MVC框架可以用于创建web应用，也可以创建返回XML或JSON的web服务。 </li><li>只需要非常少的配置便能支持事务管理，JDBC操作，文件上传，异常处理等。配置你可以使用注解或者配置文件实现。</li></ul><p>使用Spring框架有如下优势：  </p><ul><li>减少在应用中两个不同组件的直接依赖，一般来说Spring IoC容器负责初始化资源或beans并注入它们的依赖。  </li><li>在Spring框架中写单元测试更加容易。因为业务逻辑不直接依赖实际的资源实现类。可以容易的编写测试配置和注入测试目的模拟的beans。  </li><li>减少了重复代码的数量，如初始化对象，打开或关闭资源。我很喜欢JdbcTemplate类，是因为它帮助我们移除了所有来自JDBC编程的重复代码。  </li><li>Spring框架被分成多个模块，它帮助我们保证我们的应用变得轻量级。例如若不需要Spring事件管理特性，则可以不添加它的依赖到项目中。  </li><li>Spring框架支持大部分Java企业级特性，甚至更多。它总是与时俱进，如它有Android的Spring项目，帮助我们写出更好的native android的应用。这些使得Spring框架更完整，不需要因为新需求再引入不同的框架。</li></ul><h3 id="3-你对依赖注入的理解是什么？"><a href="#3-你对依赖注入的理解是什么？" class="headerlink" title="3. 你对依赖注入的理解是什么？"></a>3. 你对依赖注入的理解是什么？</h3><p>依赖注入设计模式允许我们移除硬编码依赖，确保应用松耦合，可扩展，可维护。把依赖解析从编译时移动运行时，我们就能够实现依赖注入模式。</p><p>使用依赖注入有这些好处：分享了关注点，减少了重复代码，组件可配置和更易单元测试。</p><h3 id="4-Spring框架中怎么样实现依赖注入？"><a href="#4-Spring框架中怎么样实现依赖注入？" class="headerlink" title="4. Spring框架中怎么样实现依赖注入？"></a>4. Spring框架中怎么样实现依赖注入？</h3><p>在Spring应用中我们可以基于“Spring XML”以及“注解”配置实现依赖注入。更好的理解，请阅读<a href="https://www.journaldev.com/2410/spring-dependency-injection" target="_blank" rel="noopener">Spring依赖注入实例</a>。</p><h3 id="5-使用Spring工具套件有什么好处？"><a href="#5-使用Spring工具套件有什么好处？" class="headerlink" title="5. 使用Spring工具套件有什么好处？"></a>5. 使用Spring工具套件有什么好处？</h3><p>安装扫描件到Eclipse将获得更多Spring工具套件的特性。无论如何，Eclipse中的Spring工具套件有诸如Maven支持，创建不同Spring项目类型的模板和更好Spring应用性能的tc服务。</p><p>我喜欢Spring工具套件，是因为在使用AOP切入点（pointcuts）和APO通知（advices）时，高亮显示了这些Spring组件。它清楚的显示了哪个方法将来自指定的切入点。因此相较与安装每一件小工具，在开发Spring应用时，我更喜欢使用Spring工具套件。</p><h3 id="6-重要的Spring模块名称有哪些？"><a href="#6-重要的Spring模块名称有哪些？" class="headerlink" title="6. 重要的Spring模块名称有哪些？"></a>6. 重要的Spring模块名称有哪些？</h3><p>Spring框架一些重要的模块如下：  </p><ul><li>Spring Context – 用于依赖注入。  </li><li>Spring AOP –用于面向切面编程。  </li><li>Spring DAO – 用于DAO模式的数据操作。  </li><li>Spring JDBC – 用于JDBC和数据的支持。  </li><li>Spring ORM – 用于ORM工具的支持，如Hibernate。</li><li>Spring Web Module – 用于创建web应用。</li><li>Spring MVC – 为创建web应用，web服务等的MVC实现。</li></ul><h3 id="7-你对面向切面编程的理解是什么？"><a href="#7-你对面向切面编程的理解是什么？" class="headerlink" title="7. 你对面向切面编程的理解是什么？"></a>7. 你对面向切面编程的理解是什么？</h3><p>企业级应用有一些对不同类型的对象和应用模块的公用横向关注点是合适必要的。例始日志，事务管理，数据验证，身份认证等。<br>在面向切面编程中，应用模块是通过类实现的。如AOP应用模块是通过配置在不同类的方法上的模向关注点Aspects实现的。</p><p>AOP从类中分离了横向关注点任务的直接依赖，这在一般的面向对象编程中是不可做到的。例如，你可以把日志从类中分离，但这个类不午不将要调用这些方法记录日志数据（AOP就不需要）。</p><h3 id="8-AOP中的连接点（Joinpoint）-切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？"><a href="#8-AOP中的连接点（Joinpoint）-切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？" class="headerlink" title="8. AOP中的连接点（Joinpoint）, 切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？"></a>8. AOP中的连接点（Joinpoint）, 切点（Pointcut），通知（Advice），引介（Introduction），切面（Aspect），织入（Weaving）是什么？</h3><ul><li>连接点（Joinpoint）<br>程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入通知。连接点由两个信息确定：第一是用方法表示的程序执行点；第二是用相对点表示的方位。连接点是在应用执行过程中能够插入切面的一个点。</li></ul><p>以查电表为例子：电力公司为多个住户提供服务，连接点就是每一家的电表所在的位置（类中的方法的调用前、调用后…）。</p><ul><li>切点（Pointcut）<br>AOP通过“切点”定位特定的连接点。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。其实确切地说，不能称之为查询连接点，因为连接点是方法执行前、执行后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体连接点上，还需要提供方位信息。</li></ul><p>电力公司为每一个抄表员都分别指定某一块区域的住户。切点就是划分的区域。</p><ul><li>通知（Advice）<br>切面的工作被称为通知。是织入到目标类连接点上的一段程序代码。<br>Spring切面可以应用5种类型的通知：<br>-前置通知（Before）：在目标方法被调用之前调用通知功能；<br>-后置通知（After）：在目标方法完成之后调用通知，此时不会关心方 法的输出是什么；<br>-返回通知（After-returning）：在目标方法成功执行之后调用通知；<br>-异常通知（After-throwing）：在目标方法抛出异常后调用通知；<br>-环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调 用之前和调用之后执行自定义的行为。</li></ul><p>抄表员的本职工作是登记用电量，但他们还需要向电力公司汇报的信息。<br>登记用电量是目标对象，汇报的信息就是通知。 </p><ul><li>引介（Introduction）  </li></ul><p>引入允许我们向现有的类添加新方法或属性，是一种特殊的通知。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</p><ul><li>切面（Aspect）</li></ul><p>切面由切点和通知（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义。</p><p>抄表员的开始一天的工作时，他要知道从哪些区域（切点）收集信息，从而进行汇报（通知）。</p><ul><li>织入（Weaving）</li></ul><p>织入是把切面应用到目标对象并创建新的代理对象的过程。<br>AOP有三种织入的方式：<br>a、编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。<br>b、类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增<br>强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。<br>c、运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring<br>AOP就是以这种方式织入切面的。</p><h3 id="9-Spring-AOP-和AspectJ-AOP有什么区别？"><a href="#9-Spring-AOP-和AspectJ-AOP有什么区别？" class="headerlink" title="9. Spring AOP 和AspectJ AOP有什么区别？"></a>9. Spring AOP 和AspectJ AOP有什么区别？</h3><p>AspectJ是面向方向的一个工业标准级实现，而Spring仅实现了一些案例的AOP。Spring AOP 和AspectJ AOP主要有以下区别：</p><ul><li>相较与AspectJ，Spring AOP使用更简单，因为不需要担心织入（weaving）处理。 </li><li>Spring AOP支持AspectJ 注解,因此你熟悉AspectJ，使用Spring AOP也是容易的。</li><li>Spring AOP仅支持基于代理的AOP，因此它仅能应用到方法执行连接点上。AspectJ支持所有种类的切点。</li><li>Spring AOP缺点之一是它通过Spring上下文仅能应用到beans创建时。</li></ul><h3 id="10-Spring-IoC容器是什么？"><a href="#10-Spring-IoC容器是什么？" class="headerlink" title="10. Spring IoC容器是什么？"></a>10. Spring IoC容器是什么？</h3><p>控制反转（Inversion of Control）是在两对象依赖之间实现松耦合的机制。为了实现松耦合和在运行时对象的动态绑定，对象定义依赖是通过其他装配对象被注入的。Spring IoC容器是注入依赖到某个对象和待我们使用的一种程序。</p><p>Spring框架的IoC容器类由<code>org.springframework.beans</code>和<code>org.springframework.context</code>包组成。提供给我们多种不同的方式实现对象依赖的解耦。</p><p>一些常用的应用上下文实现如下：</p><ul><li><code>AnnotationConfigApplicationContext</code>: 对于基于注角配置的独立java应用程序。</li><li><code>ClassPathXmlApplicationContext</code>: 对于基于XML配置的独立java应用程序。</li><li><code>FileSystemXmlApplicationContext</code>: 除xml配置可以在文件系统中的从任何地方加载之外，与<code>ClassPathXmlApplicationContext</code>类似。</li><li><code>AnnotationConfigWebApplicationContext</code> 和 <code>XmlWebApplicationContext</code>：对于web应用程序。</li></ul><h3 id="11-Spring-Bean是什么？"><a href="#11-Spring-Bean是什么？" class="headerlink" title="11. Spring Bean是什么？"></a>11. Spring Bean是什么？</h3><p>Spring IoC容器初始化任何普通的java类被称为Spring Bean。我们使用Spring ApplicationContext得到Spring Bean实例.</p><p>Spring IoC容器管理Spring Bean生命周期，bean作用域并在bean中注入任何所需要的依赖关系。</p><h3 id="12-Spring-Bean配置文件的重要性是什么？"><a href="#12-Spring-Bean配置文件的重要性是什么？" class="headerlink" title="12. Spring Bean配置文件的重要性是什么？"></a>12. Spring Bean配置文件的重要性是什么？</h3><p>我们使用Spring Bean配置文件定义的所有beans将通过Spring Context初始化。在我们创建Spring ApplicationContext的实例时，它将读取spring bean xml文件和初始化所有的实例。一旦ApplicationContext初始化成功，我们就能够使用它得到不同的bean实例了。</p><p>除了Spring Bean配置外，该文件还包含Spring MVC拦截器，视图解析器和其他元素，以支持基于注释的配置。</p><h3 id="13-把一个类配置成Spring-Bean有些什么不同方法？"><a href="#13-把一个类配置成Spring-Bean有些什么不同方法？" class="headerlink" title="13. 把一个类配置成Spring Bean有些什么不同方法？"></a>13. 把一个类配置成Spring Bean有些什么不同方法？</h3><p>有以下三种方案配置Spring Bean：</p><p><strong>XML 配置</strong>: 这是非常受欢迎的配置方式，我们可以使用在context文件中的元素来配置Spring Bean。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"com.journaldev.spring.beans.MyBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>基于Java的配置</strong>：如果仅使用注释，则可以使用@Bean注释配置Spring Bean。 此注释与@Configuration类配合使用即配置成Spring bean。 示例配置如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.journaldev.spring.main"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyService();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了从spring context得到这个bean，我们需要使用所以代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(</span><br><span class="line">MyConfiguration.class);</span><br><span class="line">MyService service = ctx.getBean(MyService.class);</span><br></pre></td></tr></table></figure><p><strong>基于注解的配置</strong>：我们还可以使用@Component，@Service，@Repository和@Controller注释与类配置为spring bean。 对于这些，我们需要提供基本的包位置来扫描这些类。 例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.journaldev.spring"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="14-Spring-Bean有些什么不同作用域？"><a href="#14-Spring-Bean有些什么不同作用域？" class="headerlink" title="14. Spring Bean有些什么不同作用域？"></a>14. Spring Bean有些什么不同作用域？</h3><p>Spring Beans定义了5种作用域。</p><p><strong>singleton</strong>: 将为每个容器创建一个Bean的一个实例。 这是Spring bean的默认作用域。 在使用此作用域时，确保spring bean没有共享实例变量，否则可能导致数据不一致性问题，因为它不是线程安全的。<br><strong>prototype</strong>: 每次请求bean时都会创建一个新的实例。<br><strong>request</strong>: 这与prototype作用域相同，但它意在用于Web应用程序。 将为每个HTTP请求创建一个新的bean实例。该作用域仅在基于web的Spring上下文中才有效。该作用域仅在基于web的Spring上下文中才有效。<br><strong>session</strong>: 将为容器的每个HTTP会话创建一个新的bean。该作用域仅在基于web的Spring上下文中才有效。<br><strong>global-session</strong>: 这用于为Portlet应用程序创建全局会话bean。该作用域仅在Portlet上下文中才有效。<br>Spring框架是可扩展的，我们也可以创建我们自己的作用域，但是大多数时候，我们使用框架提供的作用域就够了。</p><p>要设置Spring bean作用域，我们可以在bean元素或@Scope注解中使用“scope”属性来进行基于注解的配置。</p><p><a name="spring-bean-life-cycle"></a></p><h3 id="15-Spring-Bean生命周期是什么？"><a href="#15-Spring-Bean生命周期是什么？" class="headerlink" title="15. Spring Bean生命周期是什么？"></a>15. Spring Bean生命周期是什么？</h3><p>Spring Beans通过Spring容器被初始化并所有依赖也被注入。在上下文多销毁时，所有初始化的beans也销毁。这在大多数情况下运行良好，但有时我们希望初始化其他资源或进行一些验证，然后才能使我们的bean准备被使用。Spring框架提供了对Spring bean中的初始化后和销毁前方法的支持。</p><p>我们可以通过两种方法来实现 - 通过在Spring bean配置中实现InitializingBean和DisposableBean接口或使用init-method和destroy-method属性。有关更多详细信息，请参阅<a href="https://www.journaldev.com/2637/spring-bean-life-cycle" target="_blank" rel="noopener">Spring Bean生命周期方法</a>。</p><h3 id="16-在Spring-Bean中怎么获得ServletContext和ServletConfig对象"><a href="#16-在Spring-Bean中怎么获得ServletContext和ServletConfig对象" class="headerlink" title="16. 在Spring Bean中怎么获得ServletContext和ServletConfig对象"></a>16. 在Spring Bean中怎么获得ServletContext和ServletConfig对象</h3><p>在Spring Bean中有两种方法获得容器指定的对象。</p><ol><li>实现Spring * Aware接口。对于这些ServletContextAware和ServletConfigAware接口，有关这些aware接口的完整示例，请阅读<a href="https://www.journaldev.com/2637/spring-bean-life-cycle" target="_blank" rel="noopener">Spring Aware Interfaces</a>。   </li><li>使用@Autowired注释与类型为ServletContext和ServletConfig的Bean变量。 它们只能在servlet容器的特定环境中工作。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ServletContext servletContext;</span><br></pre></td></tr></table></figure></li></ol><h3 id="17-Bean装配和-Autowired注解是什么？"><a href="#17-Bean装配和-Autowired注解是什么？" class="headerlink" title="17. Bean装配和@Autowired注解是什么？"></a>17. Bean装配和@Autowired注解是什么？</h3><p>spring bean依赖注入的处理，在初始化它时被称作spring bean装配。</p><p>通常来讲显示的装配所有的bean依赖是最佳实践，但spring框架也支持自动装配。我们也可以使用@Autowired注解和域或方法通过类型的方式自动装配。为了使此注解工作，我们还需要在spring bean配置文件中启用基于注释的配置。 这可以通过上下文来完成：annotation-config元素。</p><p>有关@Autowired注释的更多详细信息，请阅读<a href="https://www.journaldev.com/2623/spring-autowired-annotation" target="_blank" rel="noopener">Spring Autowire示例</a>。</p><h3 id="18-Spring-Bean自动装配有几种不同类型？"><a href="#18-Spring-Bean自动装配有几种不同类型？" class="headerlink" title="18. Spring Bean自动装配有几种不同类型？"></a>18. Spring Bean自动装配有几种不同类型？</h3><p>spring框架有4种类型的自动装配：</p><ol><li>据名称自动装配  </li><li>据类型自动装配  </li><li>据构造类自动装配  </li><li>据@Autowired和@Qualifier注解自动装配<br>Prior to Spring 3.1, autowire by autodetect was also supported that was similar to autowire by constructor or byType. For more details about these options, please read Spring Bean Autowiring.</li></ol><p>在Spring 3.1之前，据自动探测自动装配也被支持，它类似于构造器或按类型自动装配。有关这些选项的更多详细信息，请参阅<a href="https://www.journaldev.com/2623/spring-autowired-annotation" target="_blank" rel="noopener">Spring Bean自动装配</a>。</p><h3 id="19-Spring-Bean是线程安全的吗？"><a href="#19-Spring-Bean是线程安全的吗？" class="headerlink" title="19. Spring Bean是线程安全的吗？"></a>19. Spring Bean是线程安全的吗？</h3><p>Spring bean的默认作用域是单例的，因此每个上下文只有一个实例。 这意味着所有类级别的变量在任何线程可以更新它，导致数据不一致。 因此，在默认模式下，spring bean不是线程安全的。</p><p>但是我们可以改变spring bean的作用域到request, prototype or session，在牺牲性能的基础上，来实现线程安全。 这是一个设计决策，并根据项目要求。</p><h3 id="20-在Spring-MVC的Controller是什么？"><a href="#20-在Spring-MVC的Controller是什么？" class="headerlink" title="20. 在Spring MVC的Controller是什么？"></a>20. 在Spring MVC的Controller是什么？</h3><p>就像MVC设计模式一样，Controller是负责处理所有客户端请求的类，并将它们分发到配置的资源去处理它。在Spring MVC中，org.springframework.web.servlet.DispatcherServlet是基于spring bean配置初始化上下文的前端控制器类。</p><p>Controller类负责根据请求映射来处理不同类型的客户端请求。 我们可以使用@Controller注解创建一个控制器类。 通常它与@RequestMapping注释一起使用来指定特定URI映射的处理程序方法。</p><h3 id="21-在Spring中-Component-Repository-和-Service注解有什么区别？"><a href="#21-在Spring中-Component-Repository-和-Service注解有什么区别？" class="headerlink" title="21. 在Spring中 @Component, @Repository 和 @Service注解有什么区别？"></a>21. 在Spring中 @Component, @Repository 和 @Service注解有什么区别？</h3><p><code>@Component</code>注解用于指示该类是一个组件。 当使用基于注解的配置时，这些类将自动检测并配置为bean被使用。</p><p><code>@Controller</code>注解是一种特定类型的组件，用于MVC应用程序，大多与@RequestMapping注解一起使用。</p><p><code>@Repository</code>注解用于指示组件用作存储库，以及用于存储/检索/搜索数据的机制。 我们可以使用DAO模式实现类应用此注解。</p><p><code>@Service</code>注解用于表示该类是一个服务。 通常会提供一些服务的业务门面类使用该注解。</p><p>为了类可以自动检测到，我们可以使用任何以上注解，但不同的类型的注解被提供后，你可以轻松区分类的意图。</p><h3 id="22-DispatcherServlet-和-ContextLoaderListener是什么？"><a href="#22-DispatcherServlet-和-ContextLoaderListener是什么？" class="headerlink" title="22. DispatcherServlet 和 ContextLoaderListener是什么？"></a>22. DispatcherServlet 和 ContextLoaderListener是什么？</h3><p><code>DispatcherServlet</code>是Spring MVC应用程序中的前台控制器，它加载spring bean配置文件并初始化配置的所有bean。 如果注解已启用，它还会扫描程序包和配置使用<code>@Component</code>，<code>@Controller</code>，<code>@Repository</code>或<code>@Service</code>注解的任何bean。</p><p><code>ContextLoaderListener</code>是启动和关闭Spring的根<code>WebApplicationContext</code>的侦听器。 重要的功能是将<code>ApplicationContext</code>的生命周期与<code>ServletContext</code>的生命周期结合起来，并自动创建<code>ApplicationContext</code>。 我们可以跨越不同spring上下文中,使用它定义共享bean。</p><h3 id="23-在Spring中的ViewResolver是什么？"><a href="#23-在Spring中的ViewResolver是什么？" class="headerlink" title="23. 在Spring中的ViewResolver是什么？"></a>23. 在Spring中的ViewResolver是什么？</h3><p><code>ViewResolver</code>实现被用于按名称解析视图页面。 通常我们在spring bean配置文件中配置它。 例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>InternalResourceViewResolver</code>是<code>ViewResolver</code>接口的实现之一，我们通过bean属性提供了view pages目录和后缀位置。 因此，如果控制器处理程序方法返回“home”，则视图解析器将使用位于/WEB-INF/views/home.jsp的视图页面。</p><h3 id="24-MultipartResolver是什么？什么时候使用？"><a href="#24-MultipartResolver是什么？什么时候使用？" class="headerlink" title="24. MultipartResolver是什么？什么时候使用？"></a>24. MultipartResolver是什么？什么时候使用？</h3><p><code>MultipartResolver</code>接口用于上传文件 - <code>CommonsMultipartResolver</code>和<code>StandardServletMultipartResolver</code>是由spring框架提供的用于文件上传的两个实现。 默认情况下，没有配置多部分解析器，但是要使用它们来上传文件，我们需要在spring bean配置中定义一个名为“multipartResolver”的bean，其类型为MultipartResolver。</p><p>一旦配置完成后，任何多部分请求将由配置的<code>MultipartResolver</code>解析，并传递一个包装的<code>HttpServletRequest</code>。 然后在控制器类中使用它来获取文件并处理它。 这里提供一个完整的例子，请阅读<a href="https://www.journaldev.com/2573/spring-mvc-file-upload-example-single-multiple-files" target="_blank" rel="noopener">Spring MVC文件上传示例</a>。</p><h3 id="25-Spring-MVC框架怎样处理异常？"><a href="#25-Spring-MVC框架怎样处理异常？" class="headerlink" title="25. Spring MVC框架怎样处理异常？"></a>25. Spring MVC框架怎样处理异常？</h3><p>Spring MVC框架提供了以下方法来帮助我们实现强大的异常处理。</p><ol><li><strong>基于控制器</strong> - 我们可以在控制器类中定义异常处理程序方法。 我们需要的是使用@ExceptionHandler注解来注解这些方法。</li><li><strong>全局异常处理程序</strong> - 异常处理是一个横切关注的问题，Spring提供了<code>@ControllerAdvice</code>注解，让我们可以使用任何类来定义我们的全局异常处理程序。  </li><li><strong><code>HandlerExceptionResolver</code>实现</strong> - 对于一般异常，大多数时候我们提供静态页面。 Spring Framework提供了<code>HandlerExceptionResolver</code>接口，我们可以实现这个接口来创建全局异常处理程序。 这种额外的方法来定义全局异常处理程序的原因是Spring框架还提供了我们可以在spring bean配置文件中定义的默认实现类，以获得Spring框架异常处理的好处。</li></ol><p>有关完整的示例，请参阅<a href="https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver" target="_blank" rel="noopener">Spring异常处理</a>示例。</p><h3 id="26-在Java程序中怎样创建ApplicationContext？"><a href="#26-在Java程序中怎样创建ApplicationContext？" class="headerlink" title="26. 在Java程序中怎样创建ApplicationContext？"></a>26. 在Java程序中怎样创建ApplicationContext？</h3><p>在独立的java程序中创建<code>ApplicationContext</code>有以下几种方法。</p><ol><li><strong><code>AnnotationConfigApplicationContext</code></strong>：如果我们在独立的Java应用程序中使用Spring，并使用注解进行配置，那么我们可以使用它来初始化容器并获取bean对象。  </li><li><strong><code>ClassPathXmlApplicationContext</code></strong>：如果我们在独立应用程序中有spring bean配置xml文件，那么我们可以使用此类来加载文件并获取容器对象。  </li><li><strong><code>FileSystemXmlApplicationContext</code></strong>：类似于<code>ClassPathXmlApplicationContext</code>，除了可以从文件系统中的任何位置之外的任何地方加载xml配置文件。 </li></ol><h3 id="27-能有多个Spring配置文件吗？"><a href="#27-能有多个Spring配置文件吗？" class="headerlink" title="27. 能有多个Spring配置文件吗？"></a>27. 能有多个Spring配置文件吗？</h3><p>对于Spring MVC应用程序，我们可以通过contextConfigLocation定义多个Spring上下文配置文件。 该位置字符串可以由多个位置组成，并以任意数量的逗号和空格分隔。 例如;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/appServlet/servlet-context.xml,/WEB-INF/spring/appServlet/servlet-jdbc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们还可以定义多个根级Spring配置，并通过上下文参数加载它们。 例如;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/root-context.xml /WEB-INF/spring/root-security.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>另一个选择是在上下文配置文件中使用import元素来导入其他配置，例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans:import</span> <span class="attr">resource</span>=<span class="string">"spring-jdbc.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="28-ContextLoaderListener是什么？"><a href="#28-ContextLoaderListener是什么？" class="headerlink" title="28. ContextLoaderListener是什么？"></a>28. ContextLoaderListener是什么？</h3><p>ContextLoaderListener是用于加载根上下文的侦听器类，并定义将对所有其他上下文可见的spring bean配置。 它在web.xml文件中配置为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="29-为了创建Spring-MVC应用，至少需要配置什么？"><a href="#29-为了创建Spring-MVC应用，至少需要配置什么？" class="headerlink" title="29. 为了创建Spring MVC应用，至少需要配置什么？"></a>29. 为了创建Spring MVC应用，至少需要配置什么？</h3><p>要创建一个简单的Spring MVC应用程序，我们需要执行以下任务。</p><ol><li>在项目中添加spring-context和spring-webmvc依赖项。</li><li>在web.xml文件中配置DispatcherServlet，以通过spring容器处理请求。</li><li>Spring bean配置文件来定义bean，如果使用注解，那么必须在这里配置。 此外，我们还需要为视图页面配置视图解析器。</li><li>控制器类与请求映射定义为处理客户端请求。<br>以上步骤应该足以创建一个简单的Spring MVC Hello World应用程序。</li></ol><p><a name="spring-mvc-architecture"></a></p><h3 id="30-相对与MVC架构，你对Spring-MVC框架的理解是怎样的？"><a href="#30-相对与MVC架构，你对Spring-MVC框架的理解是怎样的？" class="headerlink" title="30. 相对与MVC架构，你对Spring MVC框架的理解是怎样的？"></a>30. 相对与MVC架构，你对Spring MVC框架的理解是怎样的？</h3><p>正如名称所示，Spring MVC建立在Model-View-Controller架构之上。 DispatcherServlet是Spring MVC应用程序中的前端控制器，负责处理所有传入的请求并将其委托给不同的控制器处理程序方法。</p><p>模型可以是Spring框架中的任何Java Bean，就像任何其他MVC框架Spring一样，提供了将表单数据自动绑定到java bean。 我们可以将模型bean设置为在视图页面中使用的属性。</p><p>查看页面可以是JSP，静态HTML等，视图解析器负责查找正确的视图页面。 一旦查看页面被识别到，控制将返回给DispatcherServlet控制器。 DispatcherServlet负责呈现视图，并向客户端返回最终响应。</p><h3 id="31-Spring-MVC应用怎样实现本地化？"><a href="#31-Spring-MVC应用怎样实现本地化？" class="headerlink" title="31. Spring MVC应用怎样实现本地化？"></a>31. Spring MVC应用怎样实现本地化？</h3><p>Spring通过资源包为本地化或i18n提供了极好的支持。 使我们的应用程序本地化所需的基本步骤是：</p><ol><li>为不同的区域设置创建消息资源束，如messages_en.properties，messages_fr.properties等。</li><li>在<code>ResourceBundleMessageSource</code>或<code>ReloadableResourceBundleMessageSource</code>类型的spring bean配置文件中定义messageSource bean。</li><li><p>要更改区域设置支持，请定义类型为CookieLocaleResolver的localeResolver bean并配置LocaleChangeInterceptor拦截器。<br>示例配置可以如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"classpath:messages"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"defaultLocale"</span> <span class="attr">value</span>=<span class="string">"en"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"cookieName"</span> <span class="attr">value</span>=<span class="string">"myAppLocaleCookie"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"cookieMaxAge"</span> <span class="attr">value</span>=<span class="string">"3600"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"paramName"</span> <span class="attr">value</span>=<span class="string">"locale"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在具有键名称的视图页面中使用spring:message元素，DispatcherServlet选择相应的值，并将页面呈现在相应的区域设置中，并作为响应返回。</p></li></ol><p>有关完整的示例，请阅读<a href="https://www.journaldev.com/2610/spring-mvc-internationalization-i18n-and-localization-l10n-example" target="_blank" rel="noopener">Spring本地化</a>示例 。</p><h3 id="32-使用Spring怎样创建Restful-Web服务并返回JSON？"><a href="#32-使用Spring怎样创建Restful-Web服务并返回JSON？" class="headerlink" title="32. 使用Spring怎样创建Restful Web服务并返回JSON？"></a>32. 使用Spring怎样创建Restful Web服务并返回JSON？</h3><p>我们可以使用Spring Framework创建返回JSON数据的Restful Web服务。 Spring提供与<a href="https://www.journaldev.com/2324/jackson-json-java-parser-api-example-tutorial" target="_blank" rel="noopener">Jackson JSON</a> API的集成，我们可以使用它在安静的Web服务中发送JSON响应。</p><p>我们需要执行以下步骤来配置我们的Spring MVC应用程序以发送JSON响应：</p><ol><li><p>添加Jackson JSON依赖项，如果您使用Maven，可以使用以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Jackson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.databind-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Spring bean配置文件中配置RequestMappingHandlerAdapter bean，并将messageConverters属性设置为MappingJackson2HttpMessageConverter bean。 样品配置将是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Configure to plugin JSON as request and response in method handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">beans:list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">beans:ref</span> <span class="attr">bean</span>=<span class="string">"jsonMessageConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">beans:list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans:property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Configure bean to convert JSON to POJO and vice versa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"jsonMessageConverter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在控制器处理程序方法中，使用@ResponseBody注释返回Object作为响应。 示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = EmpRestURIConstants.GET_EMP, method = RequestMethod.GET)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Employee <span class="title">getEmployee</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> empId) </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Start getEmployee. ID="</span>+empId);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> empData.get(empId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>您可以通过任何API调用其余服务，但是如果要使用Spring，那么我们可以使用RestTemplate类来轻松实现。<br>有关一个完整的例子，请阅读<a href="https://www.journaldev.com/2552/spring-rest-example-tutorial-spring-restful-web-services" target="_blank" rel="noopener">Spring Restful Webservice</a>示例 。</p></li></ol><h3 id="33-你使用过哪些重要的Spring注解？"><a href="#33-你使用过哪些重要的Spring注解？" class="headerlink" title="33. 你使用过哪些重要的Spring注解？"></a>33. 你使用过哪些重要的Spring注解？</h3><p>我在项目中使用的一些Spring注解是：</p><p><strong>@Controller</strong> - 用于Spring MVC项目中的控制器类。<br><strong>@RequestMapping</strong> - 用于在控制器处理程序方法中配置URI映射。 这是一个非常重要的注释。<br><strong>@ResponseBody</strong> - 用于发送Object作为响应，通常用于发送XML或JSON数据作为响应。<br><strong>@PathVariable</strong> - 用于将动态值从URI映射到处理程序方法参数。<br><strong>@Autowired</strong> - 用于spring bean的自动装配依赖。<br><strong>@Qualifier</strong> - 与@Autowired注解一起使用，以避免多个Bean类型的实例存在混淆。<br><strong>@Service</strong> - 用于服务类。<br><strong>@Scope</strong> - 用于配置spring bean的作用域。<br><strong>@Configuration</strong>， <strong>@ComponentScan</strong>和<strong>@Bean</strong> - 用于基于Java的配置。<br>用于配置切面和通知的AspectJ注解， <strong>@Aspect</strong> ， <strong>@Before</strong> ， <strong>@After</strong> ， <strong>@Around</strong> ， <strong>@Pointcut</strong>等。</p><h3 id="34-我们可以发送一个Object作为Controller-handler方法的响应吗？"><a href="#34-我们可以发送一个Object作为Controller-handler方法的响应吗？" class="headerlink" title="34. 我们可以发送一个Object作为Controller handler方法的响应吗？"></a>34. 我们可以发送一个Object作为Controller handler方法的响应吗？</h3><p>可以，我们可以使用@ResponseBody注解。 这就是我们如何在restful的Web服务中发送基于JSON或XML的响应。</p><h3 id="35-Spring-MVC应用怎样上传文件？"><a href="#35-Spring-MVC应用怎样上传文件？" class="headerlink" title="35. Spring MVC应用怎样上传文件？"></a>35. Spring MVC应用怎样上传文件？</h3><p>Spring提供内置的支持，可通过MultipartResolver接口实现上传文件。 它非常易于使用，只需要配置更改才能使其正常工作。 显然，我们需要编写控制器处理程序方法来处理传入的文件并进行处理。 有关完整的示例，请参阅<a href="https://www.journaldev.com/2573/spring-mvc-file-upload-example-single-multiple-files" target="_blank" rel="noopener">Spring文件上传</a>示例 。</p><h3 id="36-Spring-Web-MVC架构怎样验证表单数据？"><a href="#36-Spring-Web-MVC架构怎样验证表单数据？" class="headerlink" title="36. Spring Web MVC架构怎样验证表单数据？"></a>36. Spring Web MVC架构怎样验证表单数据？</h3><p>Spring支持基于JSR-303注释的验证，并提供我们可以实现的Validator接口来创建我们自己的自定义验证器。 对于使用基于JSR-303的验证，我们需要使用所需的验证来注释bean变量。</p><p>对于自定义验证器实现，我们需要在controller类中进行配置。 有关完整的示例，请参阅<a href="https://www.journaldev.com/2668/spring-validation-example-mvc-validator" target="_blank" rel="noopener">Spring MVC表单验证</a>示例 。</p><h3 id="37-Spring-MVC拦截器（Interceptor）是什么？怎样使用？"><a href="#37-Spring-MVC拦截器（Interceptor）是什么？怎样使用？" class="headerlink" title="37. Spring MVC拦截器（Interceptor）是什么？怎样使用？"></a>37. Spring MVC拦截器（Interceptor）是什么？怎样使用？</h3><p>Spring MVC拦截器就像Servlet过滤器，允许我们拦截客户端请求并处理它。 我们可以在三个地方拦截客户端请求 - <strong>preHandle</strong> ， <strong>postHandle</strong>和<strong>afterCompletion</strong> 。</p><p>我们可以通过实现HandlerInterceptor接口或扩展抽象类HandlerInterceptorAdapter来创建spring拦截器。</p><p>我们需要在spring bean配置文件中配置拦截器。 我们可以定义拦截器来拦截所有的客户端请求，也可以为特定的URI映射进行配置。 有关详细的示例，请参考<a href="https://www.journaldev.com/2676/spring-mvc-interceptor-example-handlerinterceptor-handlerinterceptoradapter" target="_blank" rel="noopener">Spring MVC拦截器</a>示例 。</p><h3 id="38-Spring-JdbcTemplate类是什么？怎样使用？"><a href="#38-Spring-JdbcTemplate类是什么？怎样使用？" class="headerlink" title="38. Spring JdbcTemplate类是什么？怎样使用？"></a>38. Spring JdbcTemplate类是什么？怎样使用？</h3><p>Spring Framework提供与JDBC API的良好集成，并提供JdbcTemplate实用程序类，我们可以使用它来避免数据库操作逻辑（如打开/关闭连接，ResultSet，PreparedStatement等）的bolier-plate代码。</p><p>对于JdbcTemplate示例，请参考<a href="https://www.journaldev.com/2593/spring-jdbc-example" target="_blank" rel="noopener">Spring JDBC</a>示例 。</p><h3 id="39-Spring-Web应用中怎样使用Tomcat-JNDI数据资源？"><a href="#39-Spring-Web应用中怎样使用Tomcat-JNDI数据资源？" class="headerlink" title="39. Spring Web应用中怎样使用Tomcat JNDI数据资源？"></a>39. Spring Web应用中怎样使用Tomcat JNDI数据资源？</h3><p>对于使用servlet容器配置的JNDI DataSource，我们需要在spring bean配置文件中进行配置，然后将其注入spring beans作为依赖关系。 然后我们可以使用它与JdbcTemplate来执行数据库操作。</p><p>示例配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">id</span>=<span class="string">"dbDataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jndi.JndiObjectFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"jndiName"</span> <span class="attr">value</span>=<span class="string">"java:comp/env/jdbc/MyLocalDB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>有关完整的例子，请参考<a href="https://www.journaldev.com/2597/spring-datasource-jndi-with-tomcat-example" target="_blank" rel="noopener">Spring Tomcat JNDI</a>示例 。</p><h3 id="40-在Spring中怎样实现事务管理？"><a href="#40-在Spring中怎样实现事务管理？" class="headerlink" title="40. 在Spring中怎样实现事务管理？"></a>40. 在Spring中怎样实现事务管理？</h3><p>Spring框架通过声明式事务管理以及编程式事务管理来提供事务管理支持。 声明式事务管理被广泛使用，因为它在大多数情况下易于使用和工作。</p><p>我们使用@Transactional注释的注释方法进行声明式事务管理。 我们需要在Spring bean配置文件中为DataSource配置事务管理器。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="41-Spring-DAO是什么？"><a href="#41-Spring-DAO是什么？" class="headerlink" title="41. Spring DAO是什么？"></a>41. Spring DAO是什么？</h3><p>提供Spring DAO支持，以一致和简单的方式处理JDBC，Hibernate等数据访问技术。 例如，对于各自的技术，我们有<code>JdbcDaoSupport</code> ， <code>HibernateDaoSupport</code> ， <code>JdoDaoSupport</code>和<code>JpaDaoSupport</code> 。</p><p>Spring DAO还提供了异常层次结构的一致性，我们不需要捕获特定的异常。</p><h3 id="42-怎样集成Spring和Hibernate框架？"><a href="#42-怎样集成Spring和Hibernate框架？" class="headerlink" title="42. 怎样集成Spring和Hibernate框架？"></a>42. 怎样集成Spring和Hibernate框架？</h3><p>我们可以使用Spring ORM模块来集成Spring和Hibernate框架，如果您正在使用Hibernate 3+，SessionFactory提供当前会话，那么您应该避免使用<code>HibernateTemplate</code>或<code>HibernateDaoSupport</code>类，并更好地使用依赖注入的DAO模式进行集成。</p><p>Spring ORM还提供对使用Spring声明性事务管理的支持，所以您应该利用这一点，而不是使用hibernate的锅炉代码进行事务管理。</p><p>为了更好地理解，您应该请阅读以下教程：</p><p><a href="https://www.journaldev.com/3524/spring-hibernate-integration-example-tutorial" target="_blank" rel="noopener">Spring Hibernate集成</a>示例<br><a href="https://www.journaldev.com/3531/spring-mvc-hibernate-mysql-integration-crud-example-tutorial" target="_blank" rel="noopener">Spring MVC Hibernate集成</a>示例</p><h3 id="43-Spring-Security是什么？"><a href="#43-Spring-Security是什么？" class="headerlink" title="43. Spring Security是什么？"></a>43. Spring Security是什么？</h3><p>Spring Security框架关注的焦点是在java应用程序中提供身份验证和授权。 它解决了大多数常见的安全漏洞问题，如CSRF攻击。</p><p>通过使用注解,如@EnableWebSecurity ，在Web应用程序中使用Spring Security是很有好处的且易于使用。 您应该通过以下文章来了解如何使用Spring Security框架。</p><p><a href="https://www.journaldev.com/2715/spring-security-example-tutorial" target="_blank" rel="noopener">Servlet Web应用程序中的Spring Security</a><br><a href="https://www.journaldev.com/2736/spring-security-example-userdetailsservice" target="_blank" rel="noopener">Spring MVC和Spring Security集成</a>示例</p><h3 id="44-怎样注入一个java-util-Properties到Spring-Bean？"><a href="#44-怎样注入一个java-util-Properties到Spring-Bean？" class="headerlink" title="44. 怎样注入一个java.util.Properties到Spring Bean？"></a>44. 怎样注入一个java.util.Properties到Spring Bean？</h3><p>我们需要定义propertyConfigurer bean，该bean将从给定的属性文件加载属性。 然后我们可以使用Spring EL支持将属性注入其他bean依赖关系。 例如;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/application.properties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.journaldev.spring.EmployeeDaoImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxReadResults"</span> <span class="attr">value</span>=<span class="string">"$&#123;results.read.max&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果您使用注解来配置spring bean，则可以像下面那样注入属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;maxReadResults&#125;"</span>) </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxReadResults;</span><br></pre></td></tr></table></figure></p><h3 id="45-Spring框架使用哪些设计模式？"><a href="#45-Spring框架使用哪些设计模式？" class="headerlink" title="45. Spring框架使用哪些设计模式？"></a>45. Spring框架使用哪些设计模式？</h3><p>Spring框架正在使用很多设计模式，其中一些常见的是：</p><ol><li>单例模式：创建具有默认范围的bean。</li><li>工厂模式 ：Bean Factory类</li><li>原型模式 ：Bean作用域</li><li>适配器模式 ：Spring Web和Spring MVC</li><li>代理模式 ：Spring Aspect面向编程支持</li><li>模板方法模式 ：JdbcTemplate，HibernateTemplate等</li><li>前端控制器：Spring MVC DispatcherServlet</li><li>数据访问对象：Spring DAO支持</li><li>依赖注入和面向方面的编程</li></ol><h3 id="46-Spring框架有些什么最佳实践？"><a href="#46-Spring框架有些什么最佳实践？" class="headerlink" title="46. Spring框架有些什么最佳实践？"></a>46. Spring框架有些什么最佳实践？</h3><p>Spring Framework的一些最佳实践是：</p><ol><li>避免模​​式引用中的版本号，以确保我们有最新的配置。</li><li>根据spring-jdbc.xml，spring-security.xml等关注的问题来分隔spring bean配置。</li><li>对于在Spring MVC中的多个上下文中使用的spring bean，在根上下文中创建它们并使用listener进行初始化。</li><li>尽可能多地配置bean依赖关系，尽量避免自动装配。</li><li>对于应用程序级属性，最佳方法是创建一个属性文件，并在spring bean配置文件中读取它。</li><li>对于较小的应用程序，注解是有用的，但对于较大的应用程序注解可能会变得很痛苦。 如果我们在xml文件中有所有配置，维护它将会更容易。</li><li>为组件使用正确的注解，轻松了解其意图。 对于服务，使用@Service和DAO bean使用@Repository。</li><li>Spring框架有很多模块，使用你需要的。 删除通过Spring Tool Suite模板创建项目时添加的所有额外的依赖项。</li><li>如果您正在使用Aspects，请确保连接点范围尽可能的窄，以避免对不需要的方法的发送通知。 考虑更容易使用的自定义注解，可以避免任何问题。</li><li>当有实际利益时，使用依赖注入，只是为了松散耦合而不使用它，因为它更难维护。</li></ol><p>这就是Spring Framework面试的问题。 我希望这些问题能帮助您进行Java EE面试。 一旦有新的面试问题我将即时更新！</p><p><a href="https://www.journaldev.com/2696/spring-interview-questions-and-answers" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring框架是最受欢迎的Java企业级web应用框架。&lt;em&gt;依赖注入&lt;/em&gt;和&lt;em&gt;面象方面&lt;/em&gt;是&lt;em&gt;Spring框架&lt;/em&gt;的核心。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,interview,面试" scheme="/tags/java-spring-interview-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot热部署：spring-boot-devtools</title>
    <link href="/2018/11/26/spring-hot-deploy/"/>
    <id>/2018/11/26/spring-hot-deploy/</id>
    <published>2018-11-26T05:54:44.878Z</published>
    <updated>2018-06-22T02:24:26.719Z</updated>
    
    <content type="html"><![CDATA[<p>spring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是热部署。</p><a id="more"></a><p>当我们修改了classpath下的文件（包括类文件、属性文件、页面等）时，会重新启动应用（由于其采用的双类加载器机制，这个启动会非常快，另外也可以选择使用jrebel）。</p><p>spring-boot-devtools使用了两个类加载器来实现重启（restart）机制：</p><p>base类加载器（base ClassLoader）, restart类加载器（restart ClassLoader）。</p><ul><li>base ClassLoader：用于加载不会改变的jar（eg.第三方依赖的jar）</li><li>restart ClassLoader：用于加载我们正在开发的jar（eg.整个项目里我们自己编写的类）。当应用重启后，原先的restart ClassLoader被丢掉、重新new一个restart ClassLoader来加载这些修改过的东西，而base ClassLoader却不需要动一下。这就是devtools重启速度快的原因。</li></ul><p>使用devtools，需要添加其依赖即可 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，<br><code>/META-INF/maven，/META-INF/resources，/resources，/static，/templates，/public</code><br>这些文件夹下的文件修改不会使应用重启，但是会重新加载（devtools内嵌了一个LiveReload server，当资源发生改变时，浏览器刷新）。</p><p>另外，使用Intellij的可能会遇到这个问题，即使项目使用了spring-boot-devtools，修改了类或者html、js等，idea还是不会自动重启，非要手动去make一下或者重启，就更没有使用热部署一样。出现这种情况，并不是你的配置问题，其根本原因是因为Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。</p><p>首先，IDEA设置里面Setting-&gt;Builder,Excution,Deployment-&gt;Compiler的Make project automatically，把这个选项打勾</p><p>然后 Shift+Ctrl+Alt+/(Mac: Shift+Command+Alt+/)，选择Registry<br>把compiler.automake.allow.when.app.running 打勾</p><p>OK了，重启一下项目，然后改一下类里面的内容，IDEA就会自动去make了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;spring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是热部署。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,spring,spring boot,spring-boot-devtools,热部署" scheme="/tags/java-spring-spring-boot-spring-boot-devtools-%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>在Linux中后台运行进程的几种方法</title>
    <link href="/2018/11/26/run-backgroud-process-sereral-ways/"/>
    <id>/2018/11/26/run-backgroud-process-sereral-ways/</id>
    <published>2018-11-26T05:54:44.871Z</published>
    <updated>2018-02-13T04:30:33.113Z</updated>
    
    <content type="html"><![CDATA[<p>第二次碰到需要在后台运行进程，主要解决用telnet/ssh登录Linux服务器后，让一些程序一直运行，不受关闭终端/网络断开连接影响而不能使用。以下给出了多种方法，分别适用于不同场景。</p><a id="more"></a><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup 的用途就是让提交的命令忽略 hangup 信号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nohup ping lexiangmiao.com &amp; </span><br><span class="line"></span><br><span class="line">nohup ping lexiangmiao.com &gt;log.txt&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">ps -ef |grep lexiangmiao.com</span><br></pre></td></tr></table></figure></p><h2 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h2><p>用一新的会话运行程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setsid ping lexiangmiao.com</span><br><span class="line"></span><br><span class="line">ps -ef |grep lexiangmiao.com</span><br></pre></td></tr></table></figure></p><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>使用()和&amp;小技巧可以实现后台稳定运行</p><p>()可以运行多个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端关闭（收到 HUP即hangup信号）后就其子进程也关闭了</span></span><br><span class="line">ping lexiangmiao.com &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了</span></span><br><span class="line">(ping lexiangmiao.com &amp;)</span><br><span class="line">ps -ef |grep lexiangmiao.com</span><br></pre></td></tr></table></figure><h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -r testLargeFile largeFile &amp;</span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># 指jobs查出的编号</span></span><br><span class="line"><span class="built_in">disown</span> -h %1</span><br></pre></td></tr></table></figure><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？</p><p>用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">screen -r Urumchi</span><br><span class="line">ping www.ibm.com &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看依赖关系树</span></span><br><span class="line">pstree -H 9488</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。</p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">ref</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二次碰到需要在后台运行进程，主要解决用telnet/ssh登录Linux服务器后，让一些程序一直运行，不受关闭终端/网络断开连接影响而不能使用。以下给出了多种方法，分别适用于不同场景。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="linux,process,后台运行" scheme="/tags/linux-process-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>研发人员的绩效考核</title>
    <link href="/2018/11/26/research-and-development-personnel-performance-appraisal/"/>
    <id>/2018/11/26/research-and-development-personnel-performance-appraisal/</id>
    <published>2018-11-26T05:54:44.852Z</published>
    <updated>2018-01-17T03:11:09.813Z</updated>
    
    <content type="html"><![CDATA[<p>很多企业的绩效考核工作常常会面临这样的问题：相对其他部门，研发部门的考核指标提取、考核方式确定都有一定的难度。这也是人力资源专业人员和研发部门管理者困惑的难题。<br><a id="more"></a></p><p>曾经有企业试图对研发人员实行完全的定量考核，甚至提出以编写软件代码的行数作为一个重要考核指标，结果员工开始将一个命令可以解决的问题，拆分为几个命令，于是 “大家都很忙，疲于写程序，工作结果完全超过了预期目标，但是软件的功能却没有实现”，完全背离了绩效考核设计的初衷，考核不得不紧急叫停。虽然这种方式停止了，但如何公正客观地评价研发人员工作业绩的问题却依然摆在管理者面前。</p><h2 id="研发人员考核难在哪里"><a href="#研发人员考核难在哪里" class="headerlink" title="研发人员考核难在哪里"></a>研发人员考核难在哪里</h2><p>研发人员考核的困难主要集中于以下几点：</p><ul><li>绩效指标提取困难，由于研发人员工作本身的独特性以及工作成果不易衡量，因此难以提炼直观量化的数字性指标；</li><li>工作内容界定困难，特别是预研人员，一些成果仅仅是证明某种试试验或测试方法可行与否，证实与证伪具有同样的价值，难以在任务下达之前予以明确；</li><li>定性内容较多，影响考核的公正性；</li><li>考核方式的选取问题，很多企业的研发管理者为了回避考核的难题，而采取背后打分、不沟通的方式。</li></ul><p>面临如此多的问题，如何对研发人员进行业绩评价呢？其实，考核中最为关键的是指标和评价方式，这两者是员工工作的向导和公司的价值取向，出不得偏差，否则就可能事倍功半，甚至劳而无功了。这里，我们也从这两点出发，分析研发人员的指标提炼和评价方式。</p><h2 id="怎样提炼绩效指标"><a href="#怎样提炼绩效指标" class="headerlink" title="怎样提炼绩效指标"></a>怎样提炼绩效指标</h2><p>任何一项工作的展开必然是这样的思路：”正确的行为，沿着正确的道路，达成正确的结果”，提炼绩效指标也需要沿着这样的逻辑关系，从研发成果向前推出成功的路径以及正确的行为要求，具体见下图。</p><p><img src="/gallery/rd1.jpg" alt="绩效考核指标" title="绩效考核指标"></p><p>研发人员的考核指标可以界定为两个方面：一个是效益指标，一个是效率指标。效益指标是研发的成果在市场中产生的价值反映，如产品销售额、市场占有率等。效率指标则是指公司内部的研发效率和阶段成果完成情况，包括路径指标和行为指标，具体如产品开发周期、研发费用、产品规划符合度、批次整改率、单板/整机直通率、产品数据准确率等等。绩效指标提炼的过程实际上就是管理程序和工作流程的分析过程：</p><h2 id="路径指标"><a href="#路径指标" class="headerlink" title="路径指标"></a>路径指标</h2><p>路径指标是衡量研发过程是否符合总体研发规划的过程检测指标。 从研发的整体流程环节看，虽然研发的成果不同，但是他们所遵循的程序是一致的，明确每一环节的关键监控点，也就可以形成考核的路径指标。这些路径指标的达成保证了最终结果的实现。</p><p>产品开发周期、研发费用等指标比较易于理解，产品规划符合度指标虽然不多见，却非常重要，下面是某公司对此的界定（见表一）。</p><p><img src="/gallery/rd1.jpg" alt="绩效路径指标" title="绩效路径指标"></p><h2 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法:"></a>统计方法:</h2><p>1.路标和0级计划、1级计划基本数据和经过更改认可后的数据。</p><p>2.在进行决策点评审（主要是概念决策评审）时，对照路标和0级计划、1级计划，检查是否在规划范围内以及时间偏差，在会议纪要中说明：<br>(1) 本版本是否计入非正常增删版本数；<br>(2) 本版本是否计入未按路标执行的版本数；<br>(3) 本版本启动时间与规划的时间偏差（天）；<br>(4) 本版本与路标偏差的情况分析（包括情况说明、反映出的问题、改进措施等）。</p><h2 id="行为指标"><a href="#行为指标" class="headerlink" title="行为指标"></a>行为指标</h2><p>行为指标是研发过程中对正确职业行为的评价指标。</p><p>正确的路径还需要有正确的行为方式，许多公司重视研发过程性内容的积累和知识共享平台的搭建，这些内容就要求员工在研发的过程中关注文档的积累、数据的准确、程序的明晰记录等等。因此，可以设置文档完整率、项目报告完整性、数据差错分析等指标，以提出对研发人员具体行为的要求，这些也是许多职业化通道方案设计时需要分析的内容。如果公司已经建立了研发人员的职业发展路径标准，许多行为指标是可以从中提炼的。</p><h2 id="效益指标"><a href="#效益指标" class="headerlink" title="效益指标"></a>效益指标</h2><p>作为经济性的组织，任何一个研发成果都必须在市场上实现价值，效益指标就是用来评价产品对公司带来的价值和客户对其的认同度，例如产品销售额、市场占有率、客户满意度、产品故障率等等。由于这些指标具有明显的滞后性，不能即期反映研发的成果，因此，这种指标的使用更多要和公司的中期激励方案相结合，具有明显的项目制考核指标的特点。</p><p>同时，效益指标不适用于研发部门的个人考核，因为研发成果往往是团队合作的产物，作为部门、事业部、项目开发团队的考核更为合适。</p><h2 id="如何选择考核方式"><a href="#如何选择考核方式" class="headerlink" title="如何选择考核方式"></a>如何选择考核方式</h2><p>研发工作由于贡献特点和侧重点不同，在考核方式上可重点区分部门团队考核与员工个人考核两种。</p><h3 id="部门团队考核"><a href="#部门团队考核" class="headerlink" title="部门团队考核"></a>部门团队考核</h3><p>在研发工作中，部门、团队为基本的业务单元，对直接产品和最终产品的市场价值负有责任。因此，对部门、团队考核侧重的要素为效益指标和路径指标。但因为效益指标的滞后性问题，在整体的考核周期的设计上需要认真考虑以下两点：</p><ul><li>对于效益指标，采取按项目周期进行考核的方式。许多研发成果的好坏是在项目结束之后一段时间体现出来，这部分指标的考核要在这个周期之后进行。</li><li>对于路径指标，采取按固定时间段进行考核的方式，多数为季度，以保证产品的研发过程符合公司预定的目标。</li></ul><p>其中，路径指标占整体考核成绩的50％～70％，甚至更高，以体现公司的业绩导向和市场导向。为此，公司在奖金分配制度上也需要做相应的考虑，以配合这样的考核方式。</p><h3 id="员工个人"><a href="#员工个人" class="headerlink" title="员工个人"></a>员工个人</h3><p>由于研发成果更多属于团队合作的结果，每位研发人员只是负责最终成果的某个功能模块或某个环节，甚至有的研发人员不清楚自己的工作输出在最终产品中所起到的作用。他们的考核主要侧重点在于行为指标和路径指标。因此，结合这种工作特点和考核侧重点，可以采用PBC（Personal Business Commitment个人业绩承诺）评价方式。PBC的程序是：设定清晰的目标，并承诺为实现目标采取的具体策略和措施，以及对团队建设的贡献，并通过对这些承诺进行评价来考核研发人员。</p><p>PBC的重要特点就是将目标与实现的行为要素紧密结合起来，更像是一种计划考核，强调了行为和团队合作的重要性。其具体操作方式如下：</p><h2 id="建立PBC目标"><a href="#建立PBC目标" class="headerlink" title="建立PBC目标"></a>建立PBC目标</h2><p>考核周期（一般为季度）之初，直接主管或是项目组组长交流部门或是项目组的工作目标，然后员工根据团队目标制定个人的工作目标。这些目标应该是简洁、易于考核、基于结果的，一般通过WIN、EXECUTE、TEAM三个层次来表达:</p><ul><li>赢的承诺：为了支持部门或是项目组工作目标的完成，你必须做些什么。指标主要是行为指标和路径指标的结合。</li><li>执行的承诺：通过什么方法完成你赢的承诺呢？必须分析为了达成目标，需要采取的策略、方法以及对工具的需求，形成清晰的执行方案，并且有明确的时间限制和规定，若承诺按照计划按时执行，就能保证实现赢的承诺。</li><li>团队的承诺：为了同团队成员更好地合作，更加高效地完成赢和执行的承诺，员工应该做些什么。高效的团队工作需要有好的交流、参与、理解和相互支持，以一个整体去完成工作，保证团队成果的实现。PBC的举例见表二。</li></ul><p><img src="/gallery/rd1.jpg" alt="绩效PBC目标" title="绩效PBC目标"></p><h2 id="过程辅导"><a href="#过程辅导" class="headerlink" title="过程辅导"></a>过程辅导</h2><p>任何绩效考核工作都不是秋后算帐的评判，在工作的执行过程中，主管要即时给予员工支持和辅导，帮助员工解决问题和提升能力，这一点在一般的考核评价方式中都有介绍，在此不再赘述。</p><h2 id="考核评价"><a href="#考核评价" class="headerlink" title="考核评价"></a>考核评价</h2><p>依据考核周期之初确定的业绩承诺，主管对员工的整个工作情况进行评价，员工的绩效考核以目标完成结果为依据，考核的等级将影响员工的价值回报。</p><h2 id="部门团队与个人考核的关系"><a href="#部门团队与个人考核的关系" class="headerlink" title="部门团队与个人考核的关系"></a>部门团队与个人考核的关系</h2><p>部门团队的考核与员工个人的考核虽然在考核周期和侧重点上不同，但两者不是孤立的，只有员工个人的业绩达成了，才能保证整个组织绩效的实现。为此，针对部门团队绩效考核的中期激励方案必须体现出员工个人的价值回报，保证两者成为有机的整体。</p><p><a href="https://www.toutiao.com/a6511671010184397325/?iid=20677887087&amp;app=news_article&amp;wxshare_count=1&amp;tt_from=weixin&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;utm_campaign=client_share" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多企业的绩效考核工作常常会面临这样的问题：相对其他部门，研发部门的考核指标提取、考核方式确定都有一定的难度。这也是人力资源专业人员和研发部门管理者困惑的难题。&lt;br&gt;
    
    </summary>
    
      <category term="management" scheme="/categories/management/"/>
    
    
      <category term="java,class loader,类加载器" scheme="/tags/java-class-loader-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何快速搭建linux运行环境</title>
    <link href="/2018/11/26/quickly-set-up-linux-in-virtualbox/"/>
    <id>/2018/11/26/quickly-set-up-linux-in-virtualbox/</id>
    <published>2018-11-26T05:54:44.837Z</published>
    <updated>2018-02-09T14:54:36.963Z</updated>
    
    <content type="html"><![CDATA[<p>对于程序员来说，很可能用linux作为服务器运行环境，为了提前发现问题不可避免的需要搭建一套linux运行环境，此文给出一个可行、快速且经济的解决方案。</p><a id="more"></a><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>在VirtualBox中安装好CentOS 7 </li><li>可实现主机到虚机的双向复制和文件共享</li></ul><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>win7</li><li>VirtualBox 5.2.6</li><li>CentOS 7 32位镜像</li></ul><h2 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h2><h3 id="1-下载VirtualBox"><a href="#1-下载VirtualBox" class="headerlink" title="1 下载VirtualBox"></a>1 下载VirtualBox</h3><p>打开<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">virtualbox官网</a> ，选择windows hosts下载到本地，安装完成进行到下一步。</p><h3 id="2-下载Linux镜像"><a href="#2-下载Linux镜像" class="headerlink" title="2 下载Linux镜像"></a>2 下载Linux镜像</h3><p>打开<a href="https://www.osboxes.org/virtualbox-images/" target="_blank" rel="noopener">osboxes官网</a> ,打开CentOS链接，找到linux 32bit下载。也可以下载64bit据自身机器情况而定。</p><h3 id="3-创建虚拟电脑"><a href="#3-创建虚拟电脑" class="headerlink" title="3 创建虚拟电脑"></a>3 创建虚拟电脑</h3><p>打开VirtualBox-&gt;新建-&gt;CentOS-&gt;…-&gt;使用已有虚拟硬盘-&gt;选择已下载的Linux镜像*.vdi文件-&gt;..-&gt;直至完成。</p><h3 id="4-系统初始化设置"><a href="#4-系统初始化设置" class="headerlink" title="4 系统初始化设置"></a>4 系统初始化设置</h3><p>按提示进行系统设置，最后输入osboxes.org作为用户密码，登入Linux系统即完成搭建。</p><h3 id="5-安装增强功能"><a href="#5-安装增强功能" class="headerlink" title="5 安装增强功能"></a>5 安装增强功能</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>设备-&gt;安装增强功能-&gt;直至完成。</p><h5 id="设置共享剪切板"><a href="#设置共享剪切板" class="headerlink" title="设置共享剪切板"></a>设置共享剪切板</h5><p>设备-&gt;共享剪切板-&gt;双向</p><h5 id="设置共享目录"><a href="#设置共享目录" class="headerlink" title="设置共享目录"></a>设置共享目录</h5><p>设备-&gt;共享文件夹-&gt;设置共享目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--挂载</span><br><span class="line">mount -t vboxsf hostDirectoryName virtualDirectoryPath</span><br><span class="line">--解挂</span><br><span class="line">umount virtualDirectoryPath</span><br></pre></td></tr></table></figure><h5 id="挂载解决办法"><a href="#挂载解决办法" class="headerlink" title="挂载解决办法"></a>挂载解决办法</h5><p>问题：/sbin/mount.vboxsf: mounting failed with the error: No such device</p><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum update</span><br><span class="line">yum install kernel</span><br><span class="line">yum install kernel-devel</span><br><span class="line">yum install kernel-headers</span><br><span class="line">yum install gcc</span><br><span class="line">yum install make  </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/daiyudong2020/article/details/58073520" target="_blank" rel="noopener">参考</a></p><h2 id="3-延伸阅读"><a href="#3-延伸阅读" class="headerlink" title="3  延伸阅读"></a>3  延伸阅读</h2><h3 id="设置系统启动后进入文本界面："><a href="#设置系统启动后进入文本界面：" class="headerlink" title="设置系统启动后进入文本界面："></a>设置系统启动后进入文本界面：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-default multi-user.target</span><br></pre></td></tr></table></figure><h3 id="设置系统启动后进入图形界面："><a href="#设置系统启动后进入图形界面：" class="headerlink" title="设置系统启动后进入图形界面："></a>设置系统启动后进入图形界面：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">set</span>-default graphical.target</span><br></pre></td></tr></table></figure><h3 id="重启系统："><a href="#重启系统：" class="headerlink" title="重启系统："></a>重启系统：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot</span><br></pre></td></tr></table></figure><h3 id="以文本界面启动后，执行以下命令启动图形界面："><a href="#以文本界面启动后，执行以下命令启动图形界面：" class="headerlink" title="以文本界面启动后，执行以下命令启动图形界面："></a>以文本界面启动后，执行以下命令启动图形界面：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure><h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><p>Ctrl + Alt + F2  切换到文本界面<br>Ctrl + Alt + F1  切换到图形界面<br>Ctrl + Alt + backspace 重启当前图形界面</p><p><a href="https://www.ifshow.com/centos-7-switching-graphical-and-text-interface/" target="_blank" rel="noopener">参考</a></p><h3 id="进入setting设置termial终端打开快捷键为alt-F12"><a href="#进入setting设置termial终端打开快捷键为alt-F12" class="headerlink" title="进入setting设置termial终端打开快捷键为alt+F12"></a>进入setting设置termial终端打开快捷键为alt+F12</h3><p>Setthings-&gt;Keyboard-&gt;add command-&gt;Name “Terminal” Command “/usr/bin/gnome-terminal”-&gt;Shortcuts-&gt;输入alt+F12。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于程序员来说，很可能用linux作为服务器运行环境，为了提前发现问题不可避免的需要搭建一套linux运行环境，此文给出一个可行、快速且经济的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="linux,VirtualBox,VirtualBox image,CentOS" scheme="/tags/linux-VirtualBox-VirtualBox-image-CentOS/"/>
    
  </entry>
  
  <entry>
    <title>ORM常用的设计模式</title>
    <link href="/2018/11/26/orm-common-pattern/"/>
    <id>/2018/11/26/orm-common-pattern/</id>
    <published>2018-11-26T05:54:44.818Z</published>
    <updated>2018-01-12T09:16:20.151Z</updated>
    
    <content type="html"><![CDATA[<p>ORM(Object Relational Mapping)即对象关系映射，一种用于实现对象语言与不同类型的关系型数据之间的转换。</p><a id="more"></a><p>我们讨论该问题目的在于如何让我们系统中的对象与数据库进行交互。由于数据库与对象之间存在着结构上的差异，Mapping是相当困难的。不推荐开发人员自己进行Mapping Layer的开发，这是危险的也是及其可能失败的。更加推荐购买专业的工具，虽然这些工具通常很昂贵。到目前为止，我所接触的项目确实有Mapping layer，但它并不是典型的Mapping layer between Relational Database and Object，它是处于JSP页面与Database之间的Mapping，用于自动地将用户在页面上填写的数据更新到数据库中。这在Web项目中是很好用的，但目前这个Mapping Layer还不能做到general，它只能适用与特定的Web Application架构。</p><p>下面开始与大家聊聊三种Database Mapping层的常用的系统架构。 </p><h2 id="1-网关模式（Gateway）"><a href="#1-网关模式（Gateway）" class="headerlink" title="1. 网关模式（Gateway）"></a>1. 网关模式（Gateway）</h2><p>之所以称之“网关”，顾名思义，Mapping层扮演着一个代理的角色，应用逻辑层无需知道具体Mapping的细节，而只需通过网关的公共接口，提交数据更新或者数据加载请求，由网关去执行具体的Object到Record或者Record到Object的转换。从而实现了数据层的透明。应用逻辑层所要了解的只有网关的信息和其公共接口。使用公共接口同时有助应用逻辑代码在不同的数据层的复用：无需改变应用逻辑层的任何代码，只需为特定的数据层实现特定的网关。网关模式具体分为两种：Row Data Gateway &amp; Table Data Gateway </p><p>共同的特点： </p><p>对应于数据库中的每个Table，有一个Mapping Class，并且在这个class中每个column有其对应的字段；所有的数据库mapping代码都存在于在Mapping Class之中，使数据库访问代码与应用逻辑完全分离； </p><h3 id="Row-Data-Gateway"><a href="#Row-Data-Gateway" class="headerlink" title="Row Data Gateway"></a>Row Data Gateway</h3><p>Mapping Class是一个对应于数据库中某张表格的一条记录。记录的每个字段对应于Class中的一个Field。所有访问数据的细节都被封装在这个接口中。Row Data Gateway与Transaction Script配合使用，效果很好 </p><p>典型案例: Java中的SessionBean（Transaction Script）和EntityBean（Row Data Gateway） </p><p>适用情况：应用逻辑相对复杂，对象与对象之间交互繁多的大规模系统； </p><h3 id="Table-Data-Gateway："><a href="#Table-Data-Gateway：" class="headerlink" title="Table Data Gateway："></a>Table Data Gateway：</h3><p>这个接口定义了关于某个Table的所有查询（find），更新，插入和删除代码。Table Data Gateway将输入的参数mapping成对应的SQL，并执行SQL，最后返回适当的数据结构。如何返回Query的信息是一个具有欺骗性的决策问题。当需要返回多个记录并且函数只允许返回一个结果时，你将面临着多种选择：Map &amp; Data Transfer Object &amp; Record Set。 </p><p>Map：不是一个好方法，map中的Key常常是一种HardCode； </p><p>Data Transfer Object：是避免map的一个方法，并且可以被重用； </p><p>Record Set：虽然会使Business Logic Layer不能完全与数据库访问层相分离，但是如果我们的开发平台有很多基于Record Set的工具，采用它不失为一个好方法（.NET）。 </p><p>典型案例：Window DNA架构； </p><p>适用情况：以显示信息，修改信息为功能的MIS（信息管理系统）； </p><h2 id="2-活动记录模式（Active-Record）"><a href="#2-活动记录模式（Active-Record）" class="headerlink" title="2. 活动记录模式（Active Record）"></a>2. 活动记录模式（Active Record）</h2><p>将Business Logic与数据库访问放置于同一个Business Object中。这种模式出现的原因是业务逻辑与数据库模型非常相似。Active Record同时负责数据库存取和基于这些数据的应用逻辑的执行。应用程序的所有逻辑可以都在Active Record中，也可以是部分。有一点是默认前提，Active Record的数据结构和数据库Schema必须保持一致（在我看来这是个缺点！） </p><p>Active Record中通常有以下方法： </p><p>从SQL数据集创建Active Record的构建方法； </p><p>静态的finder方法用于封装SQL查询并且返回Active Record记录； </p><p>用Active Record中的数据更新数据库的方法； </p><p>所有字段getting和settting方法； </p><p>实现应用逻辑的方法； </p><p>活动记录模式的优点在于简单，其缺点在于没有隐藏数据库层，从而导致很难应用其他OR Mapping模式在活动记录模式之上。另外一方面，活动记录模式与Row Data Gateway的区别在于数据库存取代码是在Business Object中（Active Record）还是在一个单独的Mapping Class中（Row Data Gateway），当然也有同时存在于两者的情况；如果应用逻辑的复杂程度迫使你适用面向对象的一些机制（Direct relationships，collections and Inheritance），这时直接将数据库存取代码置于Business Object中，由于有大量的转换，会使事情变得混乱，这时应该适用Data Mapper。</p><p>但这并不是个好方法，因为它将面向对象设计和数据库设计紧密耦合在一起，这随着项目进展会使对设计的重构工作变得及其困难。通常我们会将数据库访问代码分离到一个Gateway中。有一种情况例外，当你对Transaction Script &amp; Row Data Gateway的架构进行重构的时候，为了去除Transaction Script中的重复代码，将其放进Row Data Gateway中，这是就转变成Active Record了。 </p><p>适用情况：当应用逻辑不复杂，主要是创建，更新，插入，删除操作，而且操作主要是针对单条记录时； </p><h2 id="3-数据映射模式（Data-Mapper）"><a href="#3-数据映射模式（Data-Mapper）" class="headerlink" title="3. 数据映射模式（Data Mapper）"></a>3. 数据映射模式（Data Mapper）</h2><p>这是最复杂，但最灵活的一种架构模式。使用Data Mapper，Business Objects可以与数据库结构完全的分离，他们无需知道数据库的结构和数据更新的细节。Data Mapper对于那些无法在关系型数据库表示的对象系统特性非常有效，例如Collection成员结构和继承关系。Data Mapper是内存中对象与数据库之间的媒介。它负责双方之间的数据传输。数据映射模式（Data Mapper）与网关模式最大的（Gateway）最大的区别在于依赖和控制的位置相反。在网关模式中，应用逻辑层需要了解数据库中的数据结构，二在数据映射模式中，应用逻辑无需了解数据库设计，提高了应用层（business logic）和数据层（data source）的分离，便于两者的开发和测试。</p><p>面向对象的对象系统与面向关系的关系型数据库是两种异构的结构，因此在对象系统中的很多机制（collections, inheritance等）都无法在关系型数据库中得到直接的表示，这就是数据映射模式产生的原因。在这种情况下，在两种模式下的数据转换变得相当复杂，因此我们有必要将它分层，否则任何一方（对象系统和数据库）的改变都将波及对方。 </p><p>数据映射层的最大目标就是将业务逻辑（domain）和数据层（data source）分离。整个数据映射层（Data Mapper）完全独立于系统其他部分，可以被完全替换或者允许一个逻辑层重用于不同的数据层上。但要实现它有很多重要的问题必须解决，而且不同人可以采用不同的方法实现这个数据映射模式（Data Mapper）。因此这里只介绍几个重要的实现问题。 </p><h3 id="①-Finder方法的处理"><a href="#①-Finder方法的处理" class="headerlink" title="① Finder方法的处理"></a>① Finder方法的处理</h3><p>处理方法： </p><p>在一个独立的Package中，为Finder方法定义一个接口，然后在数据映射层实现这个接口。逻辑层通过接口调用Finder方法，后者通过数据映射层加载数据。 </p><p>原因：之所以使用接口的原因，在于使Finder方法标准化，这样应用逻辑层虽然可能在任何地方都会调用Finder方法取得带有数据的Business Object，但却不依赖于数据映射层。 </p><p>Finder方法：将方法调用转换成SQL查询； </p><p>数据映射层：从数据集中获得数据并创建Business Object； </p><p>遗留问题： </p><p>数据映射层如何知道那些Object被更新了，哪些被创建，哪些被删除了？ </p><p>如何控制每次查询获得的记录数，以尽量减少查询的数目？ </p><p>其他模式如何用在数据映射层（Lazy Load, Registry, Identity Map）? </p><h3 id="②-如何将数据映射到Business-Object的字段中"><a href="#②-如何将数据映射到Business-Object的字段中" class="headerlink" title="② 如何将数据映射到Business Object的字段中"></a>② 如何将数据映射到Business Object的字段中</h3><p>数据映射层需要访问Business Object的所有字段，因此这些方法必须被设置为public，但这不不是我们所预想的。这个问题没有明确的答案，几种可选的方法都有两面性。 </p><ul><li>将数据映射层于逻辑层放置于同一个包下 </li></ul><p>缺点：有可能使事情变得更混乱； </p><ul><li>使用Reflection方法来访问Object的字段 </li></ul><p>缺点：速度慢； </p><p>增加状态标志来保证在数据库加载环境下访问这些字段 </p><p>针对这个问题，在创建Business Object的时候，你有两个选择，使用胖构造函数（这个名词是我自己取的:^)）空构造函数。 </p><ul><li>胖构造函数（Rich Constructor） </li></ul><p>优点：保证Object至少包含必须的数据；对于常量字段，无需setting方法； </p><p>缺点：必须考虑循环引用问题（cyclic reference）； </p><ul><li>空构造函数（Empty Constructor） </li></ul><p>优点：不会出现循环引用问题（cyclic reference）； </p><p>缺点：对于常量字段，仍然需要setting方法，可能引入潜在错误； </p><h3 id="③-基于元数据的映射（Metadata-based-Mapping）"><a href="#③-基于元数据的映射（Metadata-based-Mapping）" class="headerlink" title="③ 基于元数据的映射（Metadata based Mapping）"></a>③ 基于元数据的映射（Metadata based Mapping）</h3><ul><li>显式代码：这要求每个Business Object有一个Mapping class； </li><li>Metadata Mapping：元数据被存储在单独的class和文件中，我倾向于文件，随着xml的广泛使用，以XML形式存储元数据会增强移植性； </li></ul><h2 id="3种OR-Mapping架构模式的取舍和选用"><a href="#3种OR-Mapping架构模式的取舍和选用" class="headerlink" title="3种OR Mapping架构模式的取舍和选用"></a>3种OR Mapping架构模式的取舍和选用</h2><p>OR Mapping架构取决于应用逻辑层的架构。如果使用表模式（Table Module）来组织应用逻辑，那么Table Data Gateway是你的最佳选择；如果使用Transaction Script模式来组织应用逻辑，那么如果开发平台提供了使用数据集的方便就采用Table Data Gateway，否则采用Row Data Gateway；如果是使用Domain Model来建立应用逻辑模型，那么对于复杂的大系统，颖毫不犹豫地选择数据映射模式，对于逻辑简单的小系统，Active Record也是一个可选方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ORM(Object Relational Mapping)即对象关系映射，一种用于实现对象语言与不同类型的关系型数据之间的转换。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="orm,gateway pattern, active record pattern, data mapper pattern,对象关系映射， 网关模式, 活动记录模式 , 数据映射模式" scheme="/tags/orm-gateway-pattern-active-record-pattern-data-mapper-pattern-%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%EF%BC%8C-%E7%BD%91%E5%85%B3%E6%A8%A1%E5%BC%8F-%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F-%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>nodejs常用命令</title>
    <link href="/2018/11/26/nodejs-usefully-command/"/>
    <id>/2018/11/26/nodejs-usefully-command/</id>
    <published>2018-11-26T05:54:44.809Z</published>
    <updated>2018-01-22T04:38:36.864Z</updated>
    
    <content type="html"><![CDATA[<p>收集平时常用的一些nodejs命令。<br><a id="more"></a></p><h2 id="怎样升级node版本"><a href="#怎样升级node版本" class="headerlink" title="怎样升级node版本"></a>怎样升级node版本</h2><h3 id="Linux-Mac"><a href="#Linux-Mac" class="headerlink" title="Linux/Mac"></a><a href="https://stackoverflow.com/questions/10075990/upgrading-node-js-to-latest-version" target="_blank" rel="noopener">Linux/Mac</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line">sudo n 0.12.2</span><br></pre></td></tr></table></figure><p>升级到稳定版本:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n stable</span><br></pre></td></tr></table></figure></p><p>升级到最近版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n latest</span><br></pre></td></tr></table></figure></p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>从node官网下载.msi重新安装即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集平时常用的一些nodejs命令。&lt;br&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="nodejs,nodejs命令" scheme="/tags/nodejs-nodejs%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>mybatis列映射的几种方式</title>
    <link href="/2018/11/26/mybatis-columns-mapping/"/>
    <id>/2018/11/26/mybatis-columns-mapping/</id>
    <published>2018-11-26T05:54:44.788Z</published>
    <updated>2018-01-12T09:20:30.837Z</updated>
    
    <content type="html"><![CDATA[<p>不同于hibernate实现活动记录模式，mybatis实现了数据映射模式，其中列的映射有多种实现方式，有简单的也有复杂的，分别适用不同的业务场景</p><a id="more"></a><h2 id="1-使用注解-Results和-Result"><a href="#1-使用注解-Results和-Result" class="headerlink" title="1. 使用注解@Results和@Result"></a>1. 使用注解@Results和@Result</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM users"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"firstName"</span>, column = <span class="string">"first_name"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"lastName"</span>, column = <span class="string">"last_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM users"</span>)</span><br><span class="line">    <span class="meta">@ResultMap</span>(<span class="string">"BaseResultMap"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML配置如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"package.for.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"firstName"</span>, <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"lastName"</span>, <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>优点</li></ul><p>映射关系简单明了</p><ul><li>缺点</li></ul><p>相同实体类型的返回变多之后，注解的工作量加大，容易不同步和出错</p><p>避免重复的话，需要与XML配置结合，如此一来，由于使用两种方式感觉麻烦了</p><h2 id="2-使用别名"><a href="#2-使用别名" class="headerlink" title="2. 使用别名"></a>2. 使用别名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT first_name as firstName, last_name as lastName FROM users"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(&#123;</span><br><span class="line">            <span class="string">"SELECT"</span>,</span><br><span class="line">            <span class="string">"  first_name as firstName,"</span>,</span><br><span class="line">            <span class="string">"  last_name as lastName"</span>,</span><br><span class="line">            <span class="string">"FROM users"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点</li></ul><p>最直接，简单明了</p><ul><li>缺点</li></ul><p>多人开发，可能带来db命名的不规范</p><h2 id="3-使用全局配置"><a href="#3-使用全局配置" class="headerlink" title="3. 使用全局配置"></a>3. 使用全局配置</h2><p>在application.properties中，增加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.mapUnderscoreToCamelCase=true</span><br></pre></td></tr></table></figure></p><p>或者使用自定义配置Bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">ConfigurationCustomizer <span class="title">mybatisConfigurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">            configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>优点</li></ul><p>全局设置之后，只要遵守下划线映射到驼峰命名规范，就省出了大量的手动映射工作</p><ul><li>缺点</li></ul><p>对已有老系统无按此规则的db，无法映射</p><h2 id="4-使用XML映射"><a href="#4-使用XML映射" class="headerlink" title="4. 使用XML映射"></a>4. 使用XML映射</h2><p>XML配置如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"package.for.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"firstName"</span>, <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">"lastName"</span>, <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  SELECT * FROM users WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers1"</span> <span class="attr">resultType</span>=<span class="string">"package.for.User"</span>&gt;</span></span><br><span class="line">  SELECT * FROM users WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>java就不需要再一一配置了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>优点</li></ul><p>字段映射关系和对象完全分离</p><ul><li>缺点</li></ul><p>XML硬编码，维护内容多时容易出错</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上各种方法各有优劣，完全注解方式硬编码少，维护不容易出错。完全XML方式更加灵活，可以发布之后变动。具体使用单个或者混合方式取决于具体业务场景。</p><p>参考:<br><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">MyBatis-Spring-Boot-Starter介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不同于hibernate实现活动记录模式，mybatis实现了数据映射模式，其中列的映射有多种实现方式，有简单的也有复杂的，分别适用不同的业务场景&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,mybatis,columns mapping,列映射" scheme="/tags/java-mybatis-columns-mapping-%E5%88%97%E6%98%A0%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>model</title>
    <link href="/2018/11/26/model/"/>
    <id>/2018/11/26/model/</id>
    <published>2018-11-26T05:54:44.759Z</published>
    <updated>2018-04-11T13:49:29.141Z</updated>
    
    <content type="html"><![CDATA[<p>model</p><a id="more"></a><h2 id="后台架构"><a href="#后台架构" class="headerlink" title="后台架构"></a>后台架构</h2><h3 id="数据概述"><a href="#数据概述" class="headerlink" title="数据概述"></a>数据概述</h3><p>今日订单数总数</p><p>今日营业额</p><p>今日ip访问量</p><p>今日新增会员</p><p>今日新增代言人</p><p>今日新增合伙人</p><p>今日新增董事</p><p>今日已发货</p><p>累计营业额</p><p>累计订单数</p><p>累计用户人数</p><p>累计分公司数</p><p>累计董事数</p><p>累计合伙人数</p><p>累计代言人数</p><p>累计用户数</p><p>实时订单地图显示</p><h3 id="订单管理"><a href="#订单管理" class="headerlink" title="订单管理"></a>订单管理</h3><h4 id="待发货"><a href="#待发货" class="headerlink" title="待发货"></a>待发货</h4><p>订单编号</p><p>姓名</p><p>时间</p><p>收货人</p><p>收货电话</p><p>收货地址</p><p>产品名称</p><p>产品数量</p><p>产品型号</p><p>订单留言</p><p>支付方式</p><ul><li><p>支付宝</p></li><li><p>微信支付</p></li><li><p>银联支付</p></li><li><p>预付款支付</p><ul><li>预付款支付不计算业绩</li></ul></li></ul><p>订单处理代理</p><ul><li><p>规则</p><ol><li><p>下级提交上级</p></li><li><p>同级提交上级</p></li><li><p>董事提交公司</p></li><li><p>订单提交第一个预存款级别扣除, 然后订单到仓库</p></li></ol></li></ul><p>预存款扣除金额</p><p>上级处理</p><ul><li><p>未处理</p></li><li><p>已处理</p></li></ul><p>发货状态</p><ul><li>未发货</li></ul><p>物流公司</p><ul><li>无</li></ul><p>快递单号</p><ul><li>无</li></ul><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h4 id="仓库发货订单"><a href="#仓库发货订单" class="headerlink" title="仓库发货订单"></a>仓库发货订单</h4><h4 id="已发货"><a href="#已发货" class="headerlink" title="已发货"></a>已发货</h4><h4 id="已完成订单"><a href="#已完成订单" class="headerlink" title="已完成订单"></a>已完成订单</h4><h4 id="作废订单"><a href="#作废订单" class="headerlink" title="作废订单"></a>作废订单</h4><h4 id="学习订单"><a href="#学习订单" class="headerlink" title="学习订单"></a>学习订单</h4><p>会务费</p><ul><li><p>订单编号</p></li><li><p>姓名</p></li><li><p>时间</p></li><li><p>联系电话</p></li><li><p>产品数量</p></li><li><p>产品型号</p></li><li><p>订单留言</p></li><li><p>支付方式</p><ul><li><p>支付宝</p></li><li><p>微信支付</p></li><li><p>银联支付</p></li></ul></li><li><p>上级名字</p></li><li><p>订单详情</p></li><li><p>会务费</p></li><li><p>课程付费</p></li><li><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul></li></ul><p>课程费</p><ul><li><p>订单编号</p></li><li><p>姓名</p></li><li><p>时间</p></li><li><p>联系电话</p></li><li><p>产品数量</p></li><li><p>产品型号</p></li><li><p>订单留言</p></li><li><p>支付方式</p><ul><li><p>支付宝</p></li><li><p>微信支付</p></li><li><p>银联支付</p></li></ul></li><li><p>上级名字</p></li><li><p>订单详情</p></li><li><p>会务费</p></li><li><p>课程付费</p></li><li><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul></li></ul><h3 id="预存款管理"><a href="#预存款管理" class="headerlink" title="预存款管理"></a>预存款管理</h3><h4 id="预存款审核"><a href="#预存款审核" class="headerlink" title="预存款审核"></a>预存款审核</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>预存款金额</p><p>预存款时间</p><p>公司处理</p><ul><li><p>已处理</p><ul><li>通过审核则计算业绩</li></ul></li><li><p>未处理</p></li></ul><p>公司处理人</p><h4 id="添加预存款"><a href="#添加预存款" class="headerlink" title="添加预存款"></a>添加预存款</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>预存款金额</p><ul><li>添加预存款则计算业绩</li></ul><p>预存款时间</p><p>公司添加人</p><h4 id="预存款消费记录"><a href="#预存款消费记录" class="headerlink" title="预存款消费记录"></a>预存款消费记录</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>预存款金额剩余</p><p>预存款消费记录</p><h3 id="代理管理"><a href="#代理管理" class="headerlink" title="代理管理"></a>代理管理</h3><h4 id="代理管理-1"><a href="#代理管理-1" class="headerlink" title="代理管理"></a>代理管理</h4><h5 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h5><h5 id="备份代理"><a href="#备份代理" class="headerlink" title="备份代理"></a>备份代理</h5><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p>代理级别</p><ul><li><p>代言人</p></li><li><p>合伙人</p></li><li><p>董事</p></li></ul><p>名字/id/电话号码</p><h5 id="代理信息"><a href="#代理信息" class="headerlink" title="代理信息"></a>代理信息</h5><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>钱包</p><ul><li><p>预存款</p><ul><li>购买记录</li></ul></li><li><p>可提现金额</p><ul><li><p>预存款变现</p></li><li><p>营销收入</p></li><li><p>计算方法</p><ol><li><p>有预存款</p><ol><li><p>预存款减去进货金额</p></li><li><p>可提现金额出现支付金额</p></li></ol></li><li><p>没有预存款</p><p> 可提现金额出现支付金额    </p></li></ol></li></ul></li><li><p>营销收入明细</p><ul><li><p>个人销售收入</p><p>  零售价减去进货价</p></li><li><p>代理销售</p><p>  当前级别进货金额减去下级代理进货金额</p></li><li><p>公司返点</p><ul><li><p>返点规则</p><ul><li><p>董事级别</p><ol><li><p>下级董事每销售一盒奖励6元</p></li><li><p>下级董事的下级董事销售一盒奖励6元</p></li><li><p>最多两级董事</p></li><li><p>成为董事业绩断开</p></li></ol></li><li><p>合伙人级别</p><ol><li><p>下级合伙人每销售一盒奖励6元</p></li><li><p>下级合伙人的下级合伙人销售一盒奖励6元</p></li><li><p>最多两级合伙人</p></li><li><p>成为董事业绩断开</p></li><li><p>每位合伙人返点一笔金额则上级董事返点金额里减去相等金额</p></li></ol></li><li><p>代言人没有公司返点</p></li></ul></li></ul></li><li><p>月份收入记录</p></li></ul></li><li><p>提现记录</p></li></ul><p>上级董事</p><p>上级合伙人</p><p>邀请人数</p><p>下级代理树</p><ul><li><p>下级代理/会员列表</p></li><li><p>画出关系树</p></li></ul><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>会员主页</p><ul><li><p>时间</p><ul><li>历史时间</li></ul></li><li><p>BMI</p><ul><li>历史记录</li></ul></li><li><p>体脂率</p><ul><li>历史记录</li></ul></li><li><p>体水分</p><ul><li>历史记录</li></ul></li><li><p>固含量</p><ul><li>历史记录</li></ul></li><li><p>基础代谢</p><ul><li>历史记录</li></ul></li><li><p>内脏脂肪</p><ul><li>历史记录</li></ul></li><li><p>身体年龄</p><ul><li>历史记录</li></ul></li><li><p>蛋白率</p><ul><li>历史记录</li></ul></li><li><p>标准体重</p><ul><li>历史记录</li></ul></li><li><p>脂肪量</p><ul><li>历史记录</li></ul></li><li><p>肌肉量</p><ul><li>历史记录</li></ul></li><li><p>蛋白量</p><ul><li>历史记录</li></ul></li><li><p>肥胖等级</p><ul><li>历史记录</li></ul></li></ul><p>积分</p><p>操作</p><ul><li><p>通过</p></li><li><p>修改</p></li><li><p>删除</p></li></ul><h4 id="代理审核（同上代理信息）"><a href="#代理审核（同上代理信息）" class="headerlink" title="代理审核（同上代理信息）"></a>代理审核（同上代理信息）</h4><h4 id="代理关系"><a href="#代理关系" class="headerlink" title="代理关系"></a>代理关系</h4><p>代理树图</p><h4 id="新晋代理"><a href="#新晋代理" class="headerlink" title="新晋代理"></a>新晋代理</h4><p>新晋统计表格</p><h4 id="代理发展统计"><a href="#代理发展统计" class="headerlink" title="代理发展统计"></a>代理发展统计</h4><p>每月新增代理发展统计曲线图</p><h3 id="分公司管理"><a href="#分公司管理" class="headerlink" title="分公司管理"></a>分公司管理</h3><h4 id="分公司管理-1"><a href="#分公司管理-1" class="headerlink" title="分公司管理"></a>分公司管理</h4><h5 id="添加分公司"><a href="#添加分公司" class="headerlink" title="添加分公司"></a>添加分公司</h5><h5 id="备份分公司"><a href="#备份分公司" class="headerlink" title="备份分公司"></a>备份分公司</h5><h5 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h5><p>代理级别</p><ul><li><p>代言人</p></li><li><p>合伙人</p></li><li><p>董事</p></li></ul><p>名字/id/电话号码</p><h5 id="分公司信息"><a href="#分公司信息" class="headerlink" title="分公司信息"></a>分公司信息</h5><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>钱包</p><ul><li>同前所述</li></ul><p>上级董事</p><p>上级合伙人</p><p>邀请人数</p><p>下级代理树</p><ul><li><p>下级代理/会员列表</p></li><li><p>画出关系树</p></li></ul><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>健康数据</p><ul><li>同前所述</li></ul><h4 id="分公司审核（同上代理信息）"><a href="#分公司审核（同上代理信息）" class="headerlink" title="分公司审核（同上代理信息）"></a>分公司审核（同上代理信息）</h4><h3 id="会员管理"><a href="#会员管理" class="headerlink" title="会员管理"></a>会员管理</h3><p>同前所述 （分公司管理）</p><h3 id="业绩查询"><a href="#业绩查询" class="headerlink" title="业绩查询"></a>业绩查询</h3><h4 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h4><p>时间</p><p>id号</p><p>名字</p><p>电话</p><h4 id="分公司"><a href="#分公司" class="headerlink" title="分公司"></a>分公司</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h4 id="董事"><a href="#董事" class="headerlink" title="董事"></a>董事</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h4 id="合伙人"><a href="#合伙人" class="headerlink" title="合伙人"></a>合伙人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h4 id="代言人"><a href="#代言人" class="headerlink" title="代言人"></a>代言人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级合伙人</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><h3 id="商品管理"><a href="#商品管理" class="headerlink" title="商品管理"></a>商品管理</h3><h4 id="商品管理-1"><a href="#商品管理-1" class="headerlink" title="商品管理"></a>商品管理</h4><h5 id="添加商品"><a href="#添加商品" class="headerlink" title="添加商品"></a>添加商品</h5><p>商品名称</p><p>商品规格</p><p>商品型号</p><p>商品图片</p><p>商品详情</p><p>商品属性</p><ul><li><p>正品销售</p></li><li><p>积分兑换</p></li></ul><p>商品价格</p><ul><li><p>统一零售价</p></li><li><p>代言人价格</p></li><li><p>合伙人价格</p></li><li><p>董事价格</p></li></ul><p>是否计算业绩</p><p>是否扫码发货</p><p>是否上架下架</p><h5 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h5><p>商品名称</p><p>商品规格</p><p>商品型号</p><p>商品属性</p><ul><li><p>正品销售</p></li><li><p>积分兑换</p></li></ul><p>商品价格</p><ul><li><p>统一零售价</p></li><li><p>代言人价格</p></li><li><p>合伙人价格</p></li><li><p>董事价格</p></li></ul><p>是否计算业绩</p><p>是否扫码发货</p><p>是否上架下架</p><p>库存数量</p><ul><li>不可修改</li></ul><p>操作</p><ul><li><p>删除</p></li><li><p>修改</p></li></ul><h4 id="库存管理"><a href="#库存管理" class="headerlink" title="库存管理"></a>库存管理</h4><h5 id="商品列表-1"><a href="#商品列表-1" class="headerlink" title="商品列表"></a>商品列表</h5><p>商品名称</p><p>商品规格</p><p>商品型号</p><p>商品价格</p><ul><li><p>统一零售价</p></li><li><p>代言人价格</p></li><li><p>合伙人价格</p></li><li><p>董事价格</p></li></ul><p>是否计算业绩</p><p>是否扫码发货</p><p>是否上架下架</p><p>库存数量</p><p>入库</p><h5 id="出库发货记录"><a href="#出库发货记录" class="headerlink" title="出库发货记录"></a>出库发货记录</h5><p>每日订单发货详情</p><h3 id="素材管理"><a href="#素材管理" class="headerlink" title="素材管理"></a>素材管理</h3><h4 id="商学院"><a href="#商学院" class="headerlink" title="商学院"></a>商学院</h4><h5 id="添加素材"><a href="#添加素材" class="headerlink" title="添加素材"></a>添加素材</h5><ul><li><p>添加素材</p><ul><li><p>音频</p><ul><li><p>图文标题</p></li><li><p>作者</p></li><li><p>图文封面</p><ul><li>上传图片</li></ul></li><li><p>简介</p></li><li><p>销售模式</p><ul><li><p>作为单篇销售</p><ul><li>价格：</li></ul></li><li><p>作为专栏内内容</p><ul><li>选择专栏</li></ul></li><li><p>代理专项</p><ul><li><p>董事</p></li><li><p>合伙人</p></li><li><p>代言人</p></li></ul></li></ul></li><li><p>是否上架</p></li><li><p>完整音频</p></li><li><p>图文详情</p></li></ul></li><li><p>视频</p><ul><li><p>图文标题</p></li><li><p>作者</p></li><li><p>图文封面</p><ul><li>上传图片</li></ul></li><li><p>简介</p></li><li><p>销售模式</p><ul><li><p>作为单篇销售</p><ul><li>价格：</li></ul></li><li><p>作为专栏内内容</p><ul><li>选择专栏</li></ul></li><li><p>代理专项</p><ul><li><p>董事</p></li><li><p>合伙人</p></li><li><p>代言人</p></li></ul></li></ul></li><li><p>是否上架</p></li><li><p>完整视频</p></li><li><p>图文详情</p></li></ul></li></ul></li></ul><ul><li><p>添加专栏</p><ul><li><p>专栏名称</p></li><li><p>作者</p></li><li><p>专栏封面</p></li><li><p>专栏介绍</p></li><li><p>价格</p></li><li><p>专栏详情介绍</p></li></ul></li></ul><h5 id="素材列表"><a href="#素材列表" class="headerlink" title="素材列表"></a>素材列表</h5><ul><li><p>内容列表</p><ul><li><p>内容名称</p></li><li><p>销售数量</p></li><li><p>状态</p><ul><li><p>已上架</p></li><li><p>未上架</p></li></ul></li><li><p>上架时间</p></li><li><p>操作</p><ul><li><p>编辑</p></li><li><p>删除</p></li></ul></li></ul></li><li><p>专栏列表</p><ul><li><p>专栏名称</p></li><li><p>已更新篇数</p></li><li><p>销售数量</p></li><li><p>状态</p><ul><li><p>已上架</p></li><li><p>未上架</p></li></ul></li><li><p>上架时间</p></li><li><p>操作</p><ul><li><p>编辑</p></li><li><p>删除</p></li></ul></li></ul></li></ul><h4 id="一键转发朋友圈素材"><a href="#一键转发朋友圈素材" class="headerlink" title="一键转发朋友圈素材"></a>一键转发朋友圈素材</h4><h5 id="添加素材-1"><a href="#添加素材-1" class="headerlink" title="添加素材"></a>添加素材</h5><p>日期</p><p>文字</p><p>图片或视频</p><h5 id="历史素材列表"><a href="#历史素材列表" class="headerlink" title="历史素材列表"></a>历史素材列表</h5><p>搜索</p><ul><li>按日期</li></ul><p>日期</p><p>文字</p><p>图片或视频</p><p>操作</p><ul><li><p>删除</p></li><li><p>修改</p></li></ul><h5 id="晒场"><a href="#晒场" class="headerlink" title="晒场"></a>晒场</h5><p>搜索</p><ul><li><p>id</p></li><li><p>姓名</p></li><li><p>电话</p></li></ul><p>列表</p><ul><li><p>id</p></li><li><p>姓名</p></li><li><p>电话</p></li><li><p>粉丝</p></li><li><p>关注</p></li><li><p>评论</p></li><li><p>帖子内容</p></li><li><p>会员主页</p><ul><li>同前所述</li></ul></li><li><p>推荐精选</p><ul><li><p>推荐</p></li><li><p>正常</p></li></ul></li><li><p>状态</p><ul><li><p>正常</p></li><li><p>举报</p></li></ul></li><li><p>操作</p><ul><li><p>删除</p></li><li><p>操作</p><ul><li>是否推荐精选</li></ul></li><li><p>正常</p></li></ul></li></ul><p>精选</p><ul><li><p>精选列表</p><ul><li>同前列表所述</li></ul></li></ul><p>口碑</p><ul><li><p>口碑列表</p><ul><li>同前列表所述</li></ul></li></ul><p>举报</p><ul><li><p>精选列表</p><ul><li>同前列表所述</li></ul></li></ul><h3 id="积分管理"><a href="#积分管理" class="headerlink" title="积分管理"></a>积分管理</h3><h4 id="积分获得记录"><a href="#积分获得记录" class="headerlink" title="积分获得记录"></a>积分获得记录</h4><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>上级董事</p><p>上级合伙人</p><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>邀请人数积分</p><p>上称次数积分</p><p>购买商品获积分</p><p>获积分赏</p><p>积分</p><ul><li><p>获积分规则</p><ul><li><p>上称获积分</p></li><li><p>分享链接推荐新人注册获积分</p></li><li><p>积分打赏获积分</p></li></ul></li></ul><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h4 id="积分兑换记录"><a href="#积分兑换记录" class="headerlink" title="积分兑换记录"></a>积分兑换记录</h4><p>ID号</p><p>姓名</p><p>电话</p><p>微信号</p><p>注册时间</p><p>级别</p><p>上级董事</p><p>上级合伙人</p><p>状态</p><ul><li><p>正常</p></li><li><p>冻结</p><ul><li>不可以提现</li></ul></li><li><p>待审核</p></li></ul><p>打赏积分使用记录</p><p>兑换商品记录</p><p>积分结余</p><ul><li><p>获积分规则</p><ul><li><p>上称获积分</p></li><li><p>分享链接推荐新人注册获积分</p></li><li><p>积分打赏获积分</p></li></ul></li></ul><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h3 id="财务管理"><a href="#财务管理" class="headerlink" title="财务管理"></a>财务管理</h3><h4 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h4><p>月度营业额</p><ul><li>详情</li></ul><p>月度订单数</p><ul><li>详情</li></ul><p>月度可提现</p><ul><li>详情</li></ul><p>月度已打款</p><ul><li>详情</li></ul><p>月度盈利</p><ul><li>详情</li></ul><h4 id="搜索查找-1"><a href="#搜索查找-1" class="headerlink" title="搜索查找"></a>搜索查找</h4><p>时间</p><p>id号</p><p>名字</p><p>电话</p><h4 id="分公司-1"><a href="#分公司-1" class="headerlink" title="分公司"></a>分公司</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改</li></ul><h4 id="董事-1"><a href="#董事-1" class="headerlink" title="董事"></a>董事</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改</li></ul><h4 id="合伙人-1"><a href="#合伙人-1" class="headerlink" title="合伙人"></a>合伙人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改修改</li></ul><h4 id="代言人-1"><a href="#代言人-1" class="headerlink" title="代言人"></a>代言人</h4><p>ID</p><p>名字</p><p>级别</p><p>上级董事或分公司</p><p>个人销售业绩合计</p><ul><li>订单列表</li></ul><p>下级所有个人销售业绩合计</p><ul><li>名字列表</li></ul><p>预存款月总计</p><p>钱包</p><ul><li>同前所述</li></ul><p>可提现金额</p><p>申请提现金额</p><p>已经打款金额</p><p>打款记录</p><p>打款凭证</p><p>操作</p><ul><li>修改</li></ul><h3 id="管理员管理"><a href="#管理员管理" class="headerlink" title="管理员管理"></a>管理员管理</h3><h4 id="添加管理员"><a href="#添加管理员" class="headerlink" title="添加管理员"></a>添加管理员</h4><p>姓名</p><p>电话</p><p>身份证号码</p><p>职位</p><p>登陆账号</p><p>登陆密码</p><p>使用权限</p><h4 id="管理员列表"><a href="#管理员列表" class="headerlink" title="管理员列表"></a>管理员列表</h4><p>姓名</p><p>电话</p><p>职位</p><p>操作</p><ul><li><p>修改</p></li><li><p>删除</p></li></ul><h3 id="商品防伪"><a href="#商品防伪" class="headerlink" title="商品防伪"></a>商品防伪</h3><h4 id="防伪码生成"><a href="#防伪码生成" class="headerlink" title="防伪码生成"></a>防伪码生成</h4><h5 id="导出唯一防伪码"><a href="#导出唯一防伪码" class="headerlink" title="导出唯一防伪码"></a>导出唯一防伪码</h5><p>一大箱一个大码</p><ul><li>大编码下面N个小编码</li></ul><h4 id="已经入库编码"><a href="#已经入库编码" class="headerlink" title="已经入库编码"></a>已经入库编码</h4><p>扫码入库</p><h4 id="未出库编码"><a href="#未出库编码" class="headerlink" title="未出库编码"></a>未出库编码</h4><p>扫码出库</p><h3 id="投诉建议"><a href="#投诉建议" class="headerlink" title="投诉建议"></a>投诉建议</h3><p>会员投诉</p><p>代理投诉</p><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><h4 id="积分设置"><a href="#积分设置" class="headerlink" title="积分设置"></a>积分设置</h4><p>上称一次获积分</p><p>消费1元获积分</p><p>打赏获积分</p><p>分享链接获积分</p><h4 id="代理返利设置"><a href="#代理返利设置" class="headerlink" title="代理返利设置"></a>代理返利设置</h4><p>分公司奖励</p><p>董事平级奖励</p><h4 id="升级门槛设置（千元）"><a href="#升级门槛设置（千元）" class="headerlink" title="升级门槛设置（千元）"></a>升级门槛设置（千元）</h4><p>分公司</p><ul><li>400k</li></ul><p>董事</p><ul><li>54k</li></ul><p>合伙人</p><ul><li>9k</li></ul><p>代言人</p><ul><li>1.28k</li></ul><h4 id="代理证书设置"><a href="#代理证书设置" class="headerlink" title="代理证书设置"></a>代理证书设置</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;model&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="model" scheme="/tags/model/"/>
    
  </entry>
  
  <entry>
    <title>maven常用命令</title>
    <link href="/2018/11/26/maven-usefully-command/"/>
    <id>/2018/11/26/maven-usefully-command/</id>
    <published>2018-11-26T05:54:44.750Z</published>
    <updated>2017-10-27T09:29:58.798Z</updated>
    
    <content type="html"><![CDATA[<p>收集平时常用的一些maven命令。<br><a id="more"></a></p><h2 id="清除现有jar包"><a href="#清除现有jar包" class="headerlink" title="清除现有jar包"></a>清除现有jar包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clear</span><br></pre></td></tr></table></figure><h2 id="查看依赖关系"><a href="#查看依赖关系" class="headerlink" title="查看依赖关系"></a>查看依赖关系</h2><p>maven存在a-&gt;b-&gt;c和e-&gt;f-&gt;c，但此时c的版本不一致时，就需要查看依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree -Dverbose -Dincludes=DESIRED-groupId:DESIRED-artifactId</span><br><span class="line"></span><br><span class="line">mvn dependency:tree -Dverbose -Dincludes=javax.servlet:javax.servlet-api</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集平时常用的一些maven命令。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="maven,mvn,maven命令" scheme="/tags/maven-mvn-maven%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>maven中重复类冲突解决办法</title>
    <link href="/2018/11/26/maven-duplicate-classes/"/>
    <id>/2018/11/26/maven-duplicate-classes/</id>
    <published>2018-11-26T05:54:44.730Z</published>
    <updated>2017-10-27T09:28:29.728Z</updated>
    
    <content type="html"><![CDATA[<p>maven引入其他jar的时候常会碰到重得类冲突，一般解决思路是查看依赖关系，排出不需要的jar或类。<br><a id="more"></a></p><h2 id="解决步骤如下"><a href="#解决步骤如下" class="headerlink" title="解决步骤如下"></a>解决步骤如下</h2><ol><li>哪两个jar包出现重复类了。</li><li>两个jar是依赖哪个组件引入的。</li><li>通过mvn命令查找依赖关系。 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree -Dverbose -Dincludes=DESIRED-groupId:DESIRED-artifactId</span><br><span class="line"></span><br><span class="line">mvn dependency:tree -Dverbose -Dincludes=javax.servlet:javax.servlet-api</span><br></pre></td></tr></table></figure><h2 id="解决办法有以下3种："><a href="#解决办法有以下3种：" class="headerlink" title="解决办法有以下3种："></a>解决办法有以下3种：</h2><ul><li>两个jar包报重复类，如果其中有个jar包是不需要的，则可以通过<exclusions>的方式把它从依赖树中排除，这样重复类问题就被解决了。</exclusions></li><li>如果两个jar包都是需要的，此时需要改造其中一个jar包，消除重复类问题（比如改变类名或者改变package）。如果是第三方组件测修改版本号。</li><li>还有一类，是不得以而为之的（不推荐），就是重复类的问题很难解决&amp;&amp;评估下来没必要解决，可通过添加白名单的方式略过重复类问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;maven引入其他jar的时候常会碰到重得类冲突，一般解决思路是查看依赖关系，排出不需要的jar或类。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="maven,mvn,maven命令" scheme="/tags/maven-mvn-maven%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>liquibase实现自动升级数据的步骤</title>
    <link href="/2018/11/26/liquibase-upgrade-db-step/"/>
    <id>/2018/11/26/liquibase-upgrade-db-step/</id>
    <published>2018-11-26T05:54:44.709Z</published>
    <updated>2018-02-22T08:52:12.888Z</updated>
    
    <content type="html"><![CDATA[<p>数据库变化常常发生，怎样协调自动完成增量升级是个不少的挑战，以下方案可行</p><a id="more"></a><h2 id="1-配置好mvn对比数据库"><a href="#1-配置好mvn对比数据库" class="headerlink" title="1 配置好mvn对比数据库"></a>1 配置好mvn对比数据库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.liquibase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>liquibase-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;liquibase.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeLogFile</span>&gt;</span>src/main/resources/config/liquibase/master.xml<span class="tag">&lt;/<span class="name">changeLogFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diffChangeLogFile</span>&gt;</span>src/main/resources/config/liquibase/changelog/$&#123;maven.build.timestamp&#125;_changelog.xml<span class="tag">&lt;/<span class="name">diffChangeLogFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:mysql://localhost:3306/lexiangmiaoSite<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultSchemaName</span>&gt;</span>lexiangmiaoSite<span class="tag">&lt;/<span class="name">defaultSchemaName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxxxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">referenceUrl</span>&gt;</span>hibernate:spring:com.lexiangmiao.site.domain?dialect=org.hibernate.dialect.MySQL5InnoDBDialect&amp;amp;hibernate.physical_naming_strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy&amp;amp;hibernate.implicit_naming_strategy=org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy<span class="tag">&lt;/<span class="name">referenceUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logging</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">logging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建支持emoji表情的MySQL数据库 utf8mb4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `lexiangmiao` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure><h2 id="2-使用liquibase比较于当前文件与目标对象的差异"><a href="#2-使用liquibase比较于当前文件与目标对象的差异" class="headerlink" title="2 使用liquibase比较于当前文件与目标对象的差异"></a>2 使用liquibase比较于当前文件与目标对象的差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn liquibase:diff</span><br></pre></td></tr></table></figure><p>生成的差异文档与实际需求存在差异，删除不需要的升级，并把升级文档用作升级即可</p><h2 id="3-嵌入升级文档并运行升级"><a href="#3-嵌入升级文档并运行升级" class="headerlink" title="3 嵌入升级文档并运行升级"></a>3 嵌入升级文档并运行升级</h2><p>运行应用即可升级</p><p><a href="http://www.liquibase.org/documentation/diff.html" target="_blank" rel="noopener">liquibase diff</a></p><p><a href="http://www.jhipster.tech/development/" target="_blank" rel="noopener">jhipster db upgrade</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库变化常常发生，怎样协调自动完成增量升级是个不少的挑战，以下方案可行&lt;/p&gt;
    
    </summary>
    
      <category term="db" scheme="/categories/db/"/>
    
    
      <category term="liquibase,db upgrade,数据库升级" scheme="/tags/liquibase-db-upgrade-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2018/11/26/linux-usefully-command/"/>
    <id>/2018/11/26/linux-usefully-command/</id>
    <published>2018-11-26T05:54:44.684Z</published>
    <updated>2018-05-19T15:32:29.596Z</updated>
    
    <content type="html"><![CDATA[<p>收集平时常用的一些linux命令。<br><a id="more"></a></p><h2 id="ssh几个超时参数"><a href="#ssh几个超时参数" class="headerlink" title="ssh几个超时参数"></a>ssh几个超时参数</h2><h3 id="客户端方案"><a href="#客户端方案" class="headerlink" title="客户端方案"></a>客户端方案</h3><p>Host *<br>    ServerAliveInterval 60</p><h3 id="服务器方案"><a href="#服务器方案" class="headerlink" title="服务器方案"></a>服务器方案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>#ClientAliveInterval 0改为ClientAliveInterval 500     （每500秒往客户端发送会话请求，保持连接）</p><p>#ClientAliveCountMax 3      （去掉注释即可，3表示重连3次失败后，重启SSH会话）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd   <span class="comment">#重启sshd服务</span></span><br></pre></td></tr></table></figure></p><p><a href="http://www.361way.com/ssh-autologout/4679.html" target="_blank" rel="noopener">http://www.361way.com/ssh-autologout/4679.html</a></p><h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  passwd</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集平时常用的一些linux命令。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="/categories/linux/"/>
    
    
      <category term="linux,linux" scheme="/tags/linux-linux/"/>
    
  </entry>
  
  <entry>
    <title>JVM，JRE和JDK</title>
    <link href="/2018/11/26/jvm-jre-jdk/"/>
    <id>/2018/11/26/jvm-jre-jdk/</id>
    <published>2018-11-26T05:54:44.663Z</published>
    <updated>2017-09-26T04:32:36.622Z</updated>
    
    <content type="html"><![CDATA[<p>不要只从编程语言的角度来看Java，这只会看到“冰山一角”<br><a id="more"></a></p><p>这可以用Java SE Technologies中的图来印证： </p><p><img src="/gallery/java-se-platform.jpg" alt="Java SE platform" title="Java SE platform"></p><p>如果你安装JDK，就会安装这全部的东西，而Java Language只是最左上角一小部份。 </p><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p>在上图中，Platforms表示Solaris、Linux、Windows各种作业系统平台，在这些平台上架构了Java虚拟机，也就是JVM，JVM让Java可以跨平台，但是跨平台是怎么一回事？在这之前，你得先了解不能跨平台是怎么一回事。 </p><p>对于电脑而言，只认识一种语言，也就是0、1序列组成的机器指令。 当你使用C/C++等高阶语言编写程序时，其实这些语言，是比较贴近人类可阅读的文法，也就是比较接近英语文法的语言。 这是为了方便人类阅读及编写，电脑其实看不懂C/C++这类语言，为了将C/C++翻译为0、1序列组成的机器指令，你必须有个翻译员，担任翻译员工作的就是编译器（Compiler）。 </p><p>问题在于，每个平台认识的0、1序列并不一样。 某个指令在Windows上也许是0101，在Linux下也许是1010，因此必须使用不同的编译器为不同平台编译出可执行的机器码，在Windows平台上编译好的程序，不能直接拿到Linux等其它平台执行，也就是说，你的应用程序无法达到「编译一次，到处执行」的跨平台目的。 </p><p>Java是个高级语言，要让电脑执行你编写的程序，也得通过编译器的翻译。 不过Java在编译时，并不直接编译为相依于某平台的0、1序列，而是翻译为中介格式的字节码（Byte code）。 </p><p>Java源码扩展名为<em>.java ，经过编译器翻译后为扩展名</em>.class的字节码。 如果想要执行字节码文件，目标平台必须安装JVM（Java Virtual Machine）。 JVM会将字节码翻译为相应平台的机器码。 </p><p>不同的平台必须安装专属该平台的JVM。 这就好比你讲中文（<em>.java），Java编译器帮你翻译为英语（</em>.class），之后这份英语文件，到各国家之后，再由当地看得懂英文的人（JVM）翻译为当地语言（机器码）。 </p><p>所以 <strong>JVM担任的职责之一就是当地翻译员，将字节码文档翻译为当前平台看得懂的0、1序列，有了JVM，你的Java程序就可以达到「编译一次，到处到处执行」的跨平台目的</strong>。 除了了解JVM具有让Java程序跨平台的重要任务之外，编写Java程序时，对JVM的重要认知就是： </p><p>对Java程序而言，只认识一种作业系统，这个系统叫JVM，字节码文件（扩展名为.class的文件）就是JVM的可执行文件。 </p><p>Java程序理想上，并不用理会真正执行于哪个平台，只要知道如何执行于JVM就可以了，至于JVM实际上如何与底层平台作沟通，则是JVM自己的事！ 由于JVM实际上就相当于Java程序的作业系统，JVM就负责了Java程序的各种资源管理。 </p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>之后会学到的第一个Java程序，其中会有这么一段程序码： </p><p>System.out.println(“Hello World”);</p><p>先前曾经谈过，Java是个标准，System、out、println这些名称，都是标准中所规范的名称，实际上必须要有人根据标准编写出System.java，编译为System.class，如此你才能在编写第一个Java程序时，使用System类别（Class）上out物件（Object）的println()方法（Method）。 </p><p>谁来实现System.java？ 谁来编译为.class？ 可能是Oracle、IBM、Apache，无论如何，这些厂商必须根据相关的JSR标准文件，将标准程序库实现出来，如此你编写的第一个Java程序，在Oracle、IBM、Apache等厂商实现的JVM上运行时，引用如System这些标准API，你的第一个Java程序，才可能轻易地运行在不同的平台。 </p><p>在上图中右边可以看到Java SE API ，涵盖了各式常用的程序库，像是通用的群集（Collection）、输入输出、连接数据库的JDBC、编写窗口程序的AWT与Swing等，这些都是在各个JSR标准文件规范之中， </p><p><strong>Java Runtime Environment就是Java执行环境，简称JRE， 包括了Java SE API与JVM</strong>。只要你使用Java SE API中的程序库，在安装有JRE的电脑上就可以直接运行，无需额外在你的程序中再包装标准程序库，而可以由JRE直接提供。 </p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>先前说过，你要在.java中编写Java程序语言，使用编译器编译为.class文档，那么像编译器这样的工具程序是由谁提供？ 答案就是JDK，全名为Java Developer Killer ！ 呃！ 不对！ 是Java Development Kit ！</p><p>正如上图所示，JDK包括了javac、appletviewer、javadoc等工具程序，对于要开发Java程序的人，必须安装的是JDK，如此才有这些工具程序可以使用，JDK本身包括了JRE，如此你才能执行Java程序，所以总结就是 <strong>JDK包括了Java程序语言、工具程序与JRE，JRE则包括了部署技术、Java SE API与JVM</strong> 。</p><p>编写Java程序的人才需要JDK，如果你的程序只是想让朋友执行呢？ 那他只要装JRE就可以了，不用安装JDK，因为他不需要javac这些工具程序，但他需要Java SE API与JVM。</p><p>对初学者来说，JDK确实很不友善，这大概是Java阵营的哲学，假设你懂得如何准备相关开发环境，因此装好JDK之后，该自己设定的变数或选项就要自己设定，JDK不会代劳，过去戏称JDK全名为Java Developer Killer其实是其来于这。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要只从编程语言的角度来看Java，这只会看到“冰山一角”&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="JVM,JRE, JDK,javv虚拟面,java运行时环境,java开发工具包" scheme="/tags/JVM-JRE-JDK-javv%E8%99%9A%E6%8B%9F%E9%9D%A2-java%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83-java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>js对象创建：模式和最佳实践</title>
    <link href="/2018/11/26/js-object-creation-patterns-best-practises/"/>
    <id>/2018/11/26/js-object-creation-patterns-best-practises/</id>
    <published>2018-11-26T05:54:44.648Z</published>
    <updated>2017-11-15T06:00:47.875Z</updated>
    
    <content type="html"><![CDATA[<p>js对象的创建是一个棘手的主题。 这种语言有很多创建对象的风格，新手和老手都会感到不知所措，不知道应该使用哪一种。 但是，尽管每种语法都有不同的语法，但是它们可能比您实现的更类似。 在这篇文章中，我将带您了解各种不同风格的对象创建，以及如何逐步建立对象。<br><a id="more"></a></p><h2 id="对象字面量（Object-Literals）"><a href="#对象字面量（Object-Literals）" class="headerlink" title="对象字面量（Object Literals）"></a>对象字面量（Object Literals）</h2><p>我们游览的第一站是创建对象的绝对最简单的方法，即对象字面量。 js宣称对象可以创建“ex nilo”，无中生有 - 没有类，没有模板，没有原型 - 只是poof，一个包含方法和数据的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  y: <span class="number">3.14</span>,</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  g: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但是缺点是：如果我们需要在其他地方创建相同类型的对象，那么我们最终会复制粘贴对象的方法，数据和初始化。 我们需要一种方法来创建不仅仅是一个对象，而是一个对象的家族。</p><h2 id="工厂函数（Factory-Functions）"><a href="#工厂函数（Factory-Functions）" class="headerlink" title="工厂函数（Factory Functions）"></a>工厂函数（Factory Functions）</h2><p>我们巡演的下一站是工厂函数。这是创建共享相同结构，接口和实现的对象族的绝对最简单的方法。 而不是直接创建对象字面量，而是从函数返回对象字面量。这样，如果我们需要多次或在多个地方创建相同类型的对象，我们只需要调用一个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="number">42</span>,</span><br><span class="line">    y: <span class="number">3.14</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    g: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = thing();</span><br></pre></td></tr></table></figure></p><p>但是缺点是：这种方法会导致内存膨胀，因为每个对象都包含每个函数的唯一副本。 理想情况下，我们希望每个对象只能共享一个函数副本。</p><h2 id="原型链（Prototype-Chains）"><a href="#原型链（Prototype-Chains）" class="headerlink" title="原型链（Prototype Chains）"></a>原型链（Prototype Chains）</h2><p>js为我们提供了一个内置的机制来共享跨对象的数据，称为原型链。当我们访问一个对象的属性时，它可以通过委托给其他对象来满足这个请求。我们可以使用它并更改我们的工厂函数，以便它创建的每个对象只包含该特定对象唯一的数据，并将所有其他属性请求委托给一个共享对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thingPrototype = &#123;</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  g: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(thingPrototype);</span><br><span class="line"></span><br><span class="line">  o.x = <span class="number">42</span>;</span><br><span class="line">  o.y = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = thing();</span><br></pre></td></tr></table></figure></p><p>事实上，这是一种常见的模式，语言已经内置了对它的支持。我们不需要创建自己的共享对象（原型对象）。相反，我们会自动为每个函数创建一个原型对象，我们可以将共享数据放在那里。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thing.prototype.f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">thing.prototype.g = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(thing.prototype);</span><br><span class="line"></span><br><span class="line">  o.x = <span class="number">42</span>;</span><br><span class="line">  o.y = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = thing();</span><br></pre></td></tr></table></figure></p><p>但是有一个缺点。 这将导致一些重复。“thing”函数的第一行和最后一行将在每个这样的委托原型工厂函数中几乎逐字地重复。</p><h2 id="ES5类"><a href="#ES5类" class="headerlink" title="ES5类"></a>ES5类</h2><p>我们可以通过将重复行移动到自己的功能来隔离重复行。这个函数会创建一个委托给其他任意函数原型的对象，然后用新创建的对象作为参数来调用该函数，最后返回该对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line"></span><br><span class="line">  fn.call(o);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Thing.prototype.f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Thing.prototype.g = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = create(Thing);</span><br></pre></td></tr></table></figure></p><p>实际上，这也是一种常见的模式，语言对它有一些内置的支持。我们定义的“create”函数实际上是“new”关键字的基本版本，我们可以用“new”代替“create”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thing.prototype.f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Thing.prototype.g = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Thing();</span><br></pre></td></tr></table></figure></p><p>现在我们已经到达了我们通常所说的ES5类。 它们是将共享数据委托给原型对象并依靠“新”关键字来处理重复性逻辑的对象创建函数。</p><p>但是有一个缺点。 它是冗长而丑陋的，实现继承更加冗长和丑陋。</p><h2 id="ES6类"><a href="#ES6类" class="headerlink" title="ES6类"></a>ES6类</h2><p>相对而言，js最新增加的是ES6类 ，它为执行相同的操作提供了非常简洁的语法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">3.14</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f() &#123;&#125;</span><br><span class="line">  g() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Thing();</span><br></pre></td></tr></table></figure></p><p>对照多年来，我们的js开发人与原型链有着一种关系，现在你可能遇到的<strong>两种最常见的风格是类语法（即：ES5类和ES6类）</strong>，它严重依赖原型链，工厂函数语法，后者通常不依赖于原型链。 这两种风格在性能和功能上有所不同，但只是略有不同。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>今天，js引擎已经非常优化，几乎不可能查看我们的代码和更快速的原因。 衡量至关重要。 但有时甚至测量可能会使我们失败。 通常情况下，每六个星期就会发布一次更新的js引擎，有时候性能会发生重大变化，我们之前采取的任何测量以及我们基于这些测量所做出的任何决定都会直接跳出窗口。所以，我的经验法则是支持最官方和最广泛使用的语法，假设它会受到最严格的审查，并且是大部分时间内性能最高的语法。 现在是类的语法，当我写这个时，类语法比返回文字的工厂函数大约快3倍。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>在ES6中，类和工厂函数之间的功能差异很少。 今天，工厂函数和类都可以通过闭包和类地图来实现真正的私有数据工厂函数。 两者都可以通过将其他属性混合到其自己的对象中来实现多个继承工厂功能，并且还可以通过将其他属性混合到其原型，类工厂或代理中来实现多个继承工厂功能。 如果需要的话，工厂函数和类都可以返回任意的对象。 而且都提供了一个简单的语法。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综合考虑来看，我的首选是类语法。 这是标准的，它简单，干净，速度快，它提供了以前只有工厂才能提供的每一个功能。</p><p><a href="https://www.sitepoint.com/js-object-creation-patterns-best-practises/" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js对象的创建是一个棘手的主题。 这种语言有很多创建对象的风格，新手和老手都会感到不知所措，不知道应该使用哪一种。 但是，尽管每种语法都有不同的语法，但是它们可能比您实现的更类似。 在这篇文章中，我将带您了解各种不同风格的对象创建，以及如何逐步建立对象。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="/categories/js/"/>
    
    
      <category term="js,object create,js对象创建,js类,最佳实践" scheme="/tags/js-object-create-js%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-js%E7%B1%BB-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>js日期格式化</title>
    <link href="/2018/11/26/js-date-format/"/>
    <id>/2018/11/26/js-date-format/</id>
    <published>2018-11-26T05:54:44.640Z</published>
    <updated>2017-10-27T09:29:00.018Z</updated>
    
    <content type="html"><![CDATA[<p>js原生提供了不少的格式化，但因业务需要不能满足需求。因此下面给出一些新的格式化方法，作为原生日期格式化的补充。<br><a id="more"></a></p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>使用以下占位符自定义格式化</p><p>月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.format = <span class="function"><span class="keyword">function</span> (<span class="params">fmt</span>) </span>&#123; <span class="comment">//author: meizz </span></span><br><span class="line">    <span class="keyword">var</span> o = &#123;</span><br><span class="line">        <span class="string">"M+"</span>: <span class="keyword">this</span>.getMonth() + <span class="number">1</span>, <span class="comment">//月份 </span></span><br><span class="line">        <span class="string">"d+"</span>: <span class="keyword">this</span>.getDate(), <span class="comment">//日 </span></span><br><span class="line">        <span class="string">"h+"</span>: <span class="keyword">this</span>.getHours(), <span class="comment">//小时 </span></span><br><span class="line">        <span class="string">"m+"</span>: <span class="keyword">this</span>.getMinutes(), <span class="comment">//分 </span></span><br><span class="line">        <span class="string">"s+"</span>: <span class="keyword">this</span>.getSeconds(), <span class="comment">//秒 </span></span><br><span class="line">        <span class="string">"q+"</span>: <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>), <span class="comment">//季度 </span></span><br><span class="line">        <span class="string">"S"</span>: <span class="keyword">this</span>.getMilliseconds() <span class="comment">//毫秒 </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(fmt)) fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="keyword">this</span>.getFullYear() + <span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span> + k + <span class="string">")"</span>).test(fmt)) fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length == <span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span> + o[k]).substr((<span class="string">""</span> + o[k]).length)));</span><br><span class="line">    <span class="keyword">return</span> fmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="keyword">var</span> now=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.format(<span class="string">"yyyy年MM-dd"</span>));</span><br><span class="line"><span class="comment">//print 2017年01-03</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.format(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)); </span><br><span class="line"><span class="comment">//print 2017-01-03 23:02:03</span></span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用以下占位符自定义格式化</p><p>月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.pattern=<span class="function"><span class="keyword">function</span>(<span class="params">fmt</span>) </span>&#123;         </span><br><span class="line">    <span class="keyword">var</span> o = &#123;         </span><br><span class="line">    <span class="string">"M+"</span> : <span class="keyword">this</span>.getMonth()+<span class="number">1</span>, <span class="comment">//月份         </span></span><br><span class="line">    <span class="string">"d+"</span> : <span class="keyword">this</span>.getDate(), <span class="comment">//日         </span></span><br><span class="line">    <span class="string">"h+"</span> : <span class="keyword">this</span>.getHours()%<span class="number">12</span> == <span class="number">0</span> ? <span class="number">12</span> : <span class="keyword">this</span>.getHours()%<span class="number">12</span>, <span class="comment">//小时         </span></span><br><span class="line">    <span class="string">"H+"</span> : <span class="keyword">this</span>.getHours(), <span class="comment">//小时         </span></span><br><span class="line">    <span class="string">"m+"</span> : <span class="keyword">this</span>.getMinutes(), <span class="comment">//分         </span></span><br><span class="line">    <span class="string">"s+"</span> : <span class="keyword">this</span>.getSeconds(), <span class="comment">//秒         </span></span><br><span class="line">    <span class="string">"q+"</span> : <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth()+<span class="number">3</span>)/<span class="number">3</span>), <span class="comment">//季度         </span></span><br><span class="line">    <span class="string">"S"</span> : <span class="keyword">this</span>.getMilliseconds() <span class="comment">//毫秒         </span></span><br><span class="line">    &#125;;         </span><br><span class="line">    <span class="keyword">var</span> week = &#123;         </span><br><span class="line">    <span class="string">"0"</span> : <span class="string">"/u65e5"</span>,         </span><br><span class="line">    <span class="string">"1"</span> : <span class="string">"/u4e00"</span>,         </span><br><span class="line">    <span class="string">"2"</span> : <span class="string">"/u4e8c"</span>,         </span><br><span class="line">    <span class="string">"3"</span> : <span class="string">"/u4e09"</span>,         </span><br><span class="line">    <span class="string">"4"</span> : <span class="string">"/u56db"</span>,         </span><br><span class="line">    <span class="string">"5"</span> : <span class="string">"/u4e94"</span>,         </span><br><span class="line">    <span class="string">"6"</span> : <span class="string">"/u516d"</span>        </span><br><span class="line">    &#125;;         </span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/(y+)/</span>.test(fmt))&#123;         </span><br><span class="line">        fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="keyword">this</span>.getFullYear()+<span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/(E+)/</span>.test(fmt))&#123;         </span><br><span class="line">        fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, ((<span class="built_in">RegExp</span>.$<span class="number">1.</span>length&gt;<span class="number">1</span>) ? (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length&gt;<span class="number">2</span> ? <span class="string">"/u661f/u671f"</span> : <span class="string">"/u5468"</span>) : <span class="string">""</span>)+week[<span class="keyword">this</span>.getDay()+<span class="string">""</span>]);         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)&#123;         </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span>+ k +<span class="string">")"</span>).test(fmt))&#123;         </span><br><span class="line">            fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length==<span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span>+ o[k]).substr((<span class="string">""</span>+ o[k]).length)));         </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">return</span> fmt;         </span><br><span class="line">&#125;       </span><br><span class="line">     </span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="keyword">var</span> now=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.format(<span class="string">"yyyy年MM-dd"</span>));</span><br><span class="line"><span class="comment">//print 2017年01-03</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.format(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)); </span><br><span class="line"><span class="comment">//print 2017-01-03 23:02:03</span></span><br></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>使用以下占位符自定义格式化</p><p>月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(l)只能用 1 个占位符(是 1-3 位的数字)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.format = <span class="function"><span class="keyword">function</span> (<span class="params">mask</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> zeroize = <span class="function"><span class="keyword">function</span> (<span class="params">value, length</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!length) length = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            value = <span class="built_in">String</span>(value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, zeros = <span class="string">''</span>; i &lt; (length - value.length); i++) &#123;</span><br><span class="line"></span><br><span class="line">                zeros += <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> zeros + value;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask.replace(<span class="regexp">/"[^"]*"|'[^']*'|/</span>b ( ? : d &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">4</span></span><br><span class="line">    &#125; | m &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">4</span></span><br><span class="line">    &#125; | yy( ? : yy) ? | ([hHMstT]) / <span class="number">1</span> ? | [lLZ]) / b / g, <span class="function"><span class="keyword">function</span> (<span class="params">$<span class="number">0</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ($<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getDate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'dd'</span>:</span><br><span class="line">            <span class="keyword">return</span> zeroize(d.getDate());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ddd'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'Sun'</span>, <span class="string">'Mon'</span>, <span class="string">'Tue'</span>, <span class="string">'Wed'</span>, <span class="string">'Thr'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span>][d.getDay()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'dddd'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>, <span class="string">'Saturday'</span>][d.getDay()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getMonth() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'MM'</span>:</span><br><span class="line">            <span class="keyword">return</span> zeroize(d.getMonth() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'MMM'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>][d.getMonth()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'MMMM'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'January'</span>, <span class="string">'February'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'May'</span>, <span class="string">'June'</span>, <span class="string">'July'</span>, <span class="string">'August'</span>, <span class="string">'September'</span>, <span class="string">'October'</span>, <span class="string">'November'</span>, <span class="string">'December'</span>][d.getMonth()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'yy'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">String</span>(d.getFullYear()).substr(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'yyyy'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getFullYear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getHours() % <span class="number">12</span> || <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'hh'</span>:</span><br><span class="line">            <span class="keyword">return</span> zeroize(d.getHours() % <span class="number">12</span> || <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'H'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getHours();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'HH'</span>:</span><br><span class="line">            <span class="keyword">return</span> zeroize(d.getHours());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getMinutes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'mm'</span>:</span><br><span class="line">            <span class="keyword">return</span> zeroize(d.getMinutes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getSeconds();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ss'</span>:</span><br><span class="line">            <span class="keyword">return</span> zeroize(d.getSeconds());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">            <span class="keyword">return</span> zeroize(d.getMilliseconds(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">var</span> m = d.getMilliseconds();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m &gt; <span class="number">99</span>) m = <span class="built_in">Math</span>.round(m / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> zeroize(m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'tt'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getHours() &lt; <span class="number">12</span> ? <span class="string">'am'</span> : <span class="string">'pm'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'TT'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.getHours() &lt; <span class="number">12</span> ? <span class="string">'AM'</span> : <span class="string">'PM'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Z'</span>:</span><br><span class="line">            <span class="keyword">return</span> d.toUTCString().match(<span class="regexp">/[A-Z]+$/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Return quoted strings with the surrounding quotes removed      </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> $<span class="number">0.</span>substr(<span class="number">1</span>, $<span class="number">0.</span>length - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="keyword">var</span> now=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.format(<span class="string">"yyyy年MM-dd"</span>));</span><br><span class="line"><span class="comment">//print 2017年01-03</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.format(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)); </span><br><span class="line"><span class="comment">//print 2017-01-03 23:02:03</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js原生提供了不少的格式化，但因业务需要不能满足需求。因此下面给出一些新的格式化方法，作为原生日期格式化的补充。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="/categories/js/"/>
    
    
      <category term="js,date,日期，格式化" scheme="/tags/js-date-%E6%97%A5%E6%9C%9F%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java Thread wait, notify and notifyAll 示例</title>
    <link href="/2018/11/26/java-thread-wait-notify-and-notifyall-example/"/>
    <id>/2018/11/26/java-thread-wait-notify-and-notifyall-example/</id>
    <published>2018-11-26T05:54:44.620Z</published>
    <updated>2018-01-12T08:16:52.715Z</updated>
    
    <content type="html"><![CDATA[<p>java中的Object类包含三个允许线程就资源的锁定状态进行通信的最终（final）方法，。他们是<code>wait()</code>，<code>notify()</code>，和<code>notifyAll()</code> 。 今天我们将通过java程序来研究wait，notify和notifyAll。</p><a id="more"></a><h2 id="Java多线程面试问题"><a href="#Java多线程面试问题" class="headerlink" title="Java多线程面试问题"></a>Java多线程面试问题</h2><p><a name="menu"></a></p><ol><li><a href="#1">Java中的wait，notify和notifyAll</a><br>1.1 <a href="#1.1">wait</a><br>1.2 <a href="#1.2">notify</a><br>1.3 <a href="#1.3">notifyAll</a><br>1.4 <a href="#1.4">消息</a><br>1.5 <a href="#1.5">等待者</a><br>1.6 <a href="#1.6">通知者</a><br>1.7 <a href="#1.7">等待通知测试</a></li></ol><h2 id="1-Java中的wait，notify和notifyAll"><a href="#1-Java中的wait，notify和notifyAll" class="headerlink" title="1. Java中的wait，notify和notifyAll"></a><a name="1"></a><a href="#menu">1. Java中的wait，notify和notifyAll</a></h2><p>任何对象调用这些方法的当前线程应具有对象监视器，否则会抛出java.lang.IllegalMonitorStateException异常。</p><h3 id="1-1-wait"><a href="#1-1-wait" class="headerlink" title="1.1 wait"></a><a name="1.1"></a><a href="#menu">1.1 wait</a></h3><p>对象wait方法有三种实现，其中一种实现是等待任何其他线程无限期地调用对象的notify或notifyAll方法来唤醒当前线程。 其他两种实现会使当前线程在唤醒之前等待特定的时间。</p><h3 id="1-2-notify"><a href="#1-2-notify" class="headerlink" title="1.2 notify"></a><a name="1.2"></a><a href="#menu">1.2 notify</a></h3><p>notify方法只唤醒等待对象的一个​​线程，并且该线程开始执行。所以如果有多个线程在等待一个对象，这个方法只会唤醒其中的一个。线程的选择取决于线程管理的OS实现。</p><h3 id="1-3-notifyAll"><a href="#1-3-notifyAll" class="headerlink" title="1.3 notifyAll"></a><a name="1.3"></a><a href="#menu">1.3 notifyAll</a></h3><p>notifyAll方法唤醒等待对象的所有线程，但哪一个将首先处理取决于OS实现。</p><p>这些方法可用于实现<strong>生产者消费者问题</strong>，其中消费者线程正在等待队列中的对象，生产者线程将对象放入队列中并通知等待的线程。</p><p>让我们来看一个例子，其中多个线程在同一个对象上工作，我们使用wait，notify和notifyAll方法。</p><h3 id="1-4-消息"><a href="#1-4-消息" class="headerlink" title="1.4 消息"></a><a name="1.4"></a><a href="#menu">1.4 消息</a></h3><p>Java bean将在线程上工作，并调用wait和notify方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg=str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg=str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-5-等待者"><a href="#1-5-等待者" class="headerlink" title="1.5 等待者"></a><a name="1.5"></a><a href="#menu">1.5 等待者</a></h3><p>将等待其他线程调用notify方法来完成处理的类。 请注意，等待者线程使用同步块方式在Message对象上拥有监视器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Message msg;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(Message m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg=m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">synchronized</span> (msg) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(name+<span class="string">" waiting to get notified at time:"</span>+System.currentTimeMillis());</span><br><span class="line">                msg.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name+<span class="string">" waiter thread got notified at time:"</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="comment">//process the message now</span></span><br><span class="line">            System.out.println(name+<span class="string">" processed: "</span>+msg.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-6-通知者"><a href="#1-6-通知者" class="headerlink" title="1.6 通知者"></a><a name="1.6"></a><a href="#menu">1.6 通知者</a></h3><p>一个将要处理消息对象的类，然后调用notify方法来唤醒等待消息对象的线程。请注意，同步块用于拥有Message对象的监视器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notifier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Message msg;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notifier</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name+<span class="string">" started"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (msg) &#123;</span><br><span class="line">                msg.setMsg(name+<span class="string">" Notifier work done"</span>);</span><br><span class="line">                msg.notify();</span><br><span class="line">                <span class="comment">// msg.notifyAll();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-7-等待通知测试"><a href="#1-7-等待通知测试" class="headerlink" title="1.7 等待通知测试"></a><a name="1.7"></a><a href="#menu">1.7 等待通知测试</a></h3><p>测试类将创建Waiter和Notifier的多个线程并启动它们。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">"process it"</span>);</span><br><span class="line">        Waiter waiter = <span class="keyword">new</span> Waiter(msg);</span><br><span class="line">        <span class="keyword">new</span> Thread(waiter,<span class="string">"waiter"</span>).start();</span><br><span class="line">        </span><br><span class="line">        Waiter waiter1 = <span class="keyword">new</span> Waiter(msg);</span><br><span class="line">        <span class="keyword">new</span> Thread(waiter1, <span class="string">"waiter1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        Notifier notifier = <span class="keyword">new</span> Notifier(msg);</span><br><span class="line">        <span class="keyword">new</span> Thread(notifier, <span class="string">"notifier"</span>).start();</span><br><span class="line">        System.out.println(<span class="string">"All the threads are started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们调用上面的程序的时候，我们会看到下面的输出，但是程序不会完成，因为有两个线程在等待Message对象，而notify（）方法只唤醒其中的一个，另一个线程还在等待通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">waiter waiting to get notified at time:<span class="number">1356318734009</span></span><br><span class="line">waiter1 waiting to get notified at time:<span class="number">1356318734010</span></span><br><span class="line">All the threads are started</span><br><span class="line">notifier started</span><br><span class="line">waiter waiter thread got notified at time:<span class="number">1356318735011</span></span><br><span class="line">waiter processed: notifier Notifier work done</span><br></pre></td></tr></table></figure><p>如果我们注释notify（）调用并不注释Notifier类中的notifyAll（）调用，则下面将生成输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">waiter waiting to get notified at time:<span class="number">1356318917118</span></span><br><span class="line">waiter1 waiting to get notified at time:<span class="number">1356318917118</span></span><br><span class="line">All the threads are started</span><br><span class="line">notifier started</span><br><span class="line">waiter1 waiter thread got notified at time:<span class="number">1356318918120</span></span><br><span class="line">waiter1 processed: notifier Notifier work done</span><br><span class="line">waiter waiter thread got notified at time:<span class="number">1356318918120</span></span><br><span class="line">waiter processed: notifier Notifier work done</span><br></pre></td></tr></table></figure></p><p>由于notifyAll（）方法唤醒所有Waiter线程和程序完成，并在执行后终止。 这就是所有在Java的wait，notify和notifyAll方法。</p><p><a href="https://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中的Object类包含三个允许线程就资源的锁定状态进行通信的最终（final）方法，。他们是&lt;code&gt;wait()&lt;/code&gt;，&lt;code&gt;notify()&lt;/code&gt;，和&lt;code&gt;notifyAll()&lt;/code&gt; 。 今天我们将通过java程序来研究wait，notify和notifyAll。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java, Thread, wait, notify, notifyAll, 等待, 通知, 通知所有" scheme="/tags/java-Thread-wait-notify-notifyAll-%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5-%E9%80%9A%E7%9F%A5%E6%89%80%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>java字符串面试问题</title>
    <link href="/2018/11/26/java-string-interview-questions/"/>
    <id>/2018/11/26/java-string-interview-questions/</id>
    <published>2018-11-26T05:54:44.603Z</published>
    <updated>2017-10-11T09:29:51.120Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>字符串是广泛使用的Java类之一。这里我列出了一些重要的Java字符串面试问题及答案。</p><p>这将极大的帮助我们获取字符串相关的全面知识，在面试中回答有关字符串的任何问题。</p><h2 id="Java字符串面试问题列表"><a href="#Java字符串面试问题列表" class="headerlink" title="Java字符串面试问题列表"></a>Java字符串面试问题列表</h2><ol><li>Java中的字符串是什么？它是数据类型的吗？</li><li>创建字符串对象有哪些不同的方式？</li><li>写一个方法检查输入的字符串是否是回文？</li><li>写一个方法从字符串中移出给定的字符？</li><li>怎以确保字符串是大写或者小写？</li><li>字符串的subSequence方法是什么？</li><li>Java编程时怎样比较两个字符串？</li><li>怎样转换字符串到字符？反过来呢？</li><li>怎样转换字符串到字节数据？反过来呢？</li><li>swicth case语句中能使用字符串类型吗？</li><li>写一个程序打印所有字符串排列？</li><li>写一个方法找出给出字符串中最长的回文？</li><li>String, StringBuffer and StringBuilder有什么区别？</li><li>Java中为什么字符串是永恒不变和拒绝继承的？</li><li>Java中怎样分隔字符串？</li><li>为什么存储密码字符数组比字符串更合适？</li><li>Java中怎样检测两个字符串是否相等？</li><li>字符串常量池是什么？</li><li>字符串的<code>intern()</code>方法做了什么？</li><li>Java中的字符串是线程安全的吗？</li><li>Java中为什么字符串是受欢迎的Hasmap key？</li><li>字符串编程？</li></ol><h2 id="Java字符串面试问题及答案"><a href="#Java字符串面试问题及答案" class="headerlink" title="Java字符串面试问题及答案"></a>Java字符串面试问题及答案</h2><h3 id="1-Java中的String是什么？它是数据类型的吗？"><a href="#1-Java中的String是什么？它是数据类型的吗？" class="headerlink" title="1. Java中的String是什么？它是数据类型的吗？"></a>1. Java中的String是什么？它是数据类型的吗？</h3><p>String是一个定义在<code>java.lang</code>包中的Java类。它不是像int或long类似的原始数据类型。字符串(String)类表示了一个字符串。字符串被使用在几乎所有的Java就应用中，这里有一个我们应当知道的有趣的特性。<strong>Java中的字符串是不可变的且无法扩展的。JVM使用字符串常量池存储所有字符串对象。其他有趣的是关于使用双引号初始化字符串的方式和“+”操作符重载</strong>。</p><h3 id="2-创建字符串对象有哪些不同的方式？"><a href="#2-创建字符串对象有哪些不同的方式？" class="headerlink" title="2. 创建字符串对象有哪些不同的方式？"></a>2. 创建字符串对象有哪些不同的方式？</h3><p>可以使用<code>new</code>操作符或者双引号初始化一个字符串对象。也可以使用char数组, byte数组, StringBuffer或StringBuilder构造器初始化后，获取字符串对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>在我们使用双引号创建字符串时，JVM将从字符串常量池中查找，若找到相同的字符串，将直接返回引用，并直接指向它，否则重新创建一个字符串对象，存储在字符串常量池中，并指向它。</p><p>在使用new操作符时，JVM创建了字符串对象，但不存储在字符串常量池中。我们可以使用<code>intern()</code>方法存储它到字符串常量池，若池中存在相等的字符串，将直接返回引用。</p><h3 id="3-写一个方法检查输入的字符串是否是回文？"><a href="#3-写一个方法检查输入的字符串是否是回文？" class="headerlink" title="3. 写一个方法检查输入的字符串是否是回文？"></a>3. 写一个方法检查输入的字符串是否是回文？</h3><p>如果字符串反向后与反向前的值相等，则字符串是回文。如“aba”就是回文。</p><p>字符串类没有提供任何反向字符串的方法，但是StringBuffer和StringBuilder类提供，可以用于检测是否是回文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">    strBuilder.reverse();</span><br><span class="line">    <span class="keyword">return</span> strBuilder.toString().equals(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时面试官会问还有其他方式吗？这时你可以比较字符串中的字符方式来检测是否是回文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    System.out.println(length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) != str.charAt(length - i - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-写一个方法从字符串中移出给定的字符？"><a href="#4-写一个方法从字符串中移出给定的字符？" class="headerlink" title="4. 写一个方法从字符串中移出给定的字符？"></a>4. 写一个方法从字符串中移出给定的字符？</h3><p>可以使用<code>replaceAll</code>方法把字符串多次替换成其他字符串。重点要提出的是接受的参数是字符串类型的，因此我们要使用Character类创建一个字符串类，然后替换成空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">removeChar</span><span class="params">(String str, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> str.replaceAll(Character.toString(c), <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-怎以确保字符串是大写或者小写？"><a href="#5-怎以确保字符串是大写或者小写？" class="headerlink" title="5. 怎以确保字符串是大写或者小写？"></a>5. 怎以确保字符串是大写或者小写？</h3><p>使用<code>toUpperCase</code>和<code>toLowerCase</code>方法就可以得到大写和小写字符串。这两个方法还有带本地参数的变种方法。</p><h3 id="6-字符串的subSequence方法是什么？"><a href="#6-字符串的subSequence方法是什么？" class="headerlink" title="6. 字符串的subSequence方法是什么？"></a>6. 字符串的subSequence方法是什么？</h3><p>Java 1.4 引入了CharSequence接口，字符串类实现了该接口。内部它是调用字符串类的substring方法。</p><h3 id="7-Java编程时怎样比较两个字符串？"><a href="#7-Java编程时怎样比较两个字符串？" class="headerlink" title="7. Java编程时怎样比较两个字符串？"></a>7. Java编程时怎样比较两个字符串？</h3><p>Java字符串实现了Comparable接口，它有两个变种的<code>compareTo()</code>方法。</p><p><code>compareTo(String anotherString)</code>方法是按字典顺序比较字符串和入参字符串的。如果字符串先于输入参，则返回负整数，若字符串在入参之后。则返回正整数，若相等值则返回0，在这种情形时<code>equals(String str)</code>返回true。</p><p><code>compareToIgnoreCase(String str)</code>方法与第一个相似，但忽略了大小写。</p><h3 id="8-怎样转换字符串到字符？反过来呢？"><a href="#8-怎样转换字符串到字符？反过来呢？" class="headerlink" title="8. 怎样转换字符串到字符？反过来呢？"></a>8. 怎样转换字符串到字符？反过来呢？</h3><p>这是一个狡猾的问题，因为字符串是一亿字符序列，我们不能转换它到单个字符串。可以给出索引使用<code>charAt</code>方法得到指定位置的字符，也可以使用<code>toCharArray()</code>转换成字符数组。</p><p>使用new关键字就可以把字符数组转换成字符串。使用<code>Character.toString(char c)</code>转换字符到字符串。</p><h3 id="9-怎样转换字符串到字节数据？反过来呢？"><a href="#9-怎样转换字符串到字节数据？反过来呢？" class="headerlink" title="9. 怎样转换字符串到字节数据？反过来呢？"></a>9. 怎样转换字符串到字节数据？反过来呢？</h3><p>使用字符串的<code>getBytes()</code>方法转换字符串到字节数组，使用字符串构造器<code>new String(byte[] arr)</code>转换字节数组到字符串。</p><h3 id="10-swicth-case语句中能使用字符串类型吗？"><a href="#10-swicth-case语句中能使用字符串类型吗？" class="headerlink" title="10. swicth case语句中能使用字符串类型吗？"></a>10. swicth case语句中能使用字符串类型吗？</h3><p>java 7引入的新特性之一，switch case语句中可以使用字符串类型。因此java 7或更高版本可以使用。</p><h3 id="11-写一个程序打印给出字符串的所有的排列方式？"><a href="#11-写一个程序打印给出字符串的所有的排列方式？" class="headerlink" title="11. 写一个程序打印给出字符串的所有的排列方式？"></a>11. 写一个程序打印给出字符串的所有的排列方式？</h3><p>这是一个狡猾的问题，我们需要递归找出所有的排列，如“AAB”的所有排列是“AAB”，“ABA”和“BAA”。我们需要<code>Set</code>来确保不重复的值。</p><p>首先要获取首个字符与剩下的字符排列做交集。如“ABC”，首字符是A，剩下字符排列是“BC”和“CB”。我们可以把剩下不同的排例插入到首字符。<br>BC -&gt; ABC, BAC, BCA<br>CB -&gt; ACB, CAB, CBA<br>依此类推，递归就实现了以上算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java Program to find all permutations of a String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xxx</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">permutationFinder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; perm = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">//Handling error scenarios</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            perm.add(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span> perm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> initial = str.charAt(<span class="number">0</span>); <span class="comment">// first character</span></span><br><span class="line">        String rem = str.substring(<span class="number">1</span>); <span class="comment">// Full string without first character</span></span><br><span class="line">        Set&lt;String&gt; words = permutationFinder(rem);</span><br><span class="line">        <span class="keyword">for</span> (String strNew : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=strNew.length();i++)&#123;</span><br><span class="line">                perm.add(charInsert(strNew, initial, i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> perm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">charInsert</span><span class="params">(String str, <span class="keyword">char</span> c, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        String begin = str.substring(<span class="number">0</span>, j);</span><br><span class="line">        String end = str.substring(j);</span><br><span class="line">        <span class="keyword">return</span> begin + c + end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"AAC"</span>;</span><br><span class="line">        String s1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String s2 = <span class="string">"ABCD"</span>;</span><br><span class="line">        System.out.println(<span class="string">"\nPermutations for "</span> + s + <span class="string">" are: \n"</span> + permutationFinder(s));</span><br><span class="line">        System.out.println(<span class="string">"\nPermutations for "</span> + s1 + <span class="string">" are: \n"</span> + permutationFinder(s1));</span><br><span class="line">        System.out.println(<span class="string">"\nPermutations for "</span> + s2 + <span class="string">" are: \n"</span> + permutationFinder(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-写一个方法找出给出字符串中最长的回文？"><a href="#12-写一个方法找出给出字符串中最长的回文？" class="headerlink" title="12. 写一个方法找出给出字符串中最长的回文？"></a>12. 写一个方法找出给出字符串中最长的回文？</h3><p>关键点是任何回文从中间开始左右各移动1位，字符相等。若是奇数长度则中间为1位，若是偶数长度中间为2位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromeFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(longestPalindromeString(<span class="string">"1234"</span>));</span><br><span class="line">        System.out.println(longestPalindromeString(<span class="string">"12321"</span>));</span><br><span class="line">        System.out.println(longestPalindromeString(<span class="string">"9912321456"</span>));</span><br><span class="line">        System.out.println(longestPalindromeString(<span class="string">"9912333321456"</span>));</span><br><span class="line">        System.out.println(longestPalindromeString(<span class="string">"12145445499"</span>));</span><br><span class="line">        System.out.println(longestPalindromeString(<span class="string">"1223213"</span>));</span><br><span class="line">        System.out.println(longestPalindromeString(<span class="string">"abb"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> String <span class="title">intermediatePalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length()</span><br><span class="line">                &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindromeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String longest = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//odd cases like 121 奇数长度中间为1位。</span></span><br><span class="line">            String palindrome = intermediatePalindrome(s, i, i);</span><br><span class="line">            <span class="keyword">if</span> (palindrome.length() &gt; longest.length()) &#123;</span><br><span class="line">                longest = palindrome;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//even cases like 1221 偶数长度中间为2位</span></span><br><span class="line">            palindrome = intermediatePalindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (palindrome.length() &gt; longest.length()) &#123;</span><br><span class="line">                longest = palindrome;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-String-StringBuffer-and-StringBuilder有什么区别？"><a href="#13-String-StringBuffer-and-StringBuilder有什么区别？" class="headerlink" title="13. String, StringBuffer and StringBuilder有什么区别？"></a>13. String, StringBuffer and StringBuilder有什么区别？</h3><p>String是永不变化且拒绝扩展的。因此在做String操作时，创建了新的字符串。由于String操作有资源消耗，因此提供了String操作的助手类–StringBuffer和StringBuilder。</p><p>StringBuffer和StringBuilder都是可变的类。因加了同步锁，所以StringBuffer操作时是线程安全的，而StringBuilder不是。因此在多线程操作同一字符串时应当使用StringBuffer，但单线程环境我们应当使用StringBuilder。</p><p>StringBuilder性能优于StringBuffer是因为StringBuilder未加同步锁。</p><h3 id="14-Java中为什么字符串是永恒不变和拒绝继承的？"><a href="#14-Java中为什么字符串是永恒不变和拒绝继承的？" class="headerlink" title="14. Java中为什么字符串是永恒不变和拒绝继承的？"></a>14. Java中为什么字符串是永恒不变和拒绝继承的？</h3><p>字符是永恒不变和拒绝继承有如下好处：</p><ol><li>字符串不可变才使得线程池变为可能。</li><li>因为在存储诸如用户名和密码等第三信息时，任何黑客不能改变它的值。增强了安全性！</li><li>由于字符串不可变，它就可以安全用于多线程中，不需要任何同步。</li><li>字符串不可变性，使得java类加载器可以准确的加载。</li></ol><h3 id="15-Java中怎样分隔字符串？"><a href="#15-Java中怎样分隔字符串？" class="headerlink" title="15. Java中怎样分隔字符串？"></a>15. Java中怎样分隔字符串？</h3><p>基于正规表达式的方式，使用<code>split(String regex)</code>分隔转换成字符串数组。 </p><h3 id="16-为什么存储密码字符数组比字符串更合适？"><a href="#16-为什么存储密码字符数组比字符串更合适？" class="headerlink" title="16. 为什么存储密码字符数组比字符串更合适？"></a>16. 为什么存储密码字符数组比字符串更合适？</h3><ol><li>因为字符串是不可变对象，如果作为普通文本存储密码，那么它会一直存在内存中直至被垃圾收集器回收。因为字符串从字符串池中取出的（如果池中有该字符串就直接从池中获取，否则new 一个出来，然后把它放入池中），这样有很大的机会长期保留在内存中，这样会引发安全问题。因为任何可以访问内存的人能以明码的方式把密码dump出来。另外你还应该始终以加密而不是普通的文本来表示密码。因为字符串是不可变，因此没有任何方法可以改变其内容，任何改变都将产生一个新的字符串，而如果使用char[]，你就可以设置所有的元素为空或者为零（这里意思是说，让认证完后该数组不再使用了，就可以用零或者null覆盖原来的密码，防止别人从内存中dump出来）。所以存储密码用字符数组可以明显的减轻密码被盗的危险。</li><li>Java官方本身也推荐字符数组，JpasswordField的方法getPassword()就是返回一个字符数组，而由于安全原因getText()方法是被废弃掉的，因为它返回一个纯文本字符串。跟随Java 团队的步伐吧，没有错。</li><li>字符串以普通文本打印在log文件或控制台中也易引起危险，但是如果使用数组你不能打印数组的内容，而是它的内存地址。尽管这不是它的真正原因，但仍值得注意。</li></ol><h3 id="17-Java中怎样检测两个字符串是否相等？"><a href="#17-Java中怎样检测两个字符串是否相等？" class="headerlink" title="17. Java中怎样检测两个字符串是否相等？"></a>17. Java中怎样检测两个字符串是否相等？</h3><p>有<code>equal</code>和<code>==</code>操作符实现。使用<code>==</code>操作符除了检查值之外还要检查是否是同一引用，更多时候我们是检查值是否相等。因此我们应当使用<code>equal</code>检查两个字符串是否相等。</p><h3 id="18-字符串常量池是什么？"><a href="#18-字符串常量池是什么？" class="headerlink" title="18. 字符串常量池是什么？"></a>18. 字符串常量池是什么？</h3><p>正如名字所示，字符串常量池是存储在Java堆内存中的一个字符串的常量池。</p><h3 id="19-字符串的intern-方法做了什么？"><a href="#19-字符串的intern-方法做了什么？" class="headerlink" title="19. 字符串的intern()方法做了什么？"></a>19. 字符串的<code>intern()</code>方法做了什么？</h3><p>在做<code>intern</code>调用时，如果字符串池中存在相等值（<code>equals(Object)</code>）的字符串对象，则返回引用。否则创建后添加到字符串池，并引用它。</p><h3 id="20-Java中的字符串是线程安全的吗？"><a href="#20-Java中的字符串是线程安全的吗？" class="headerlink" title="20. Java中的字符串是线程安全的吗？"></a>20. Java中的字符串是线程安全的吗？</h3><p>字符串是不可变的，因此程序中不能改变这个值。因此是编程安全的，可以被安全的用于多线程环境。</p><h3 id="21-Java中为什么字符串是受欢迎的Hasmap-key？"><a href="#21-Java中为什么字符串是受欢迎的Hasmap-key？" class="headerlink" title="21. Java中为什么字符串是受欢迎的Hasmap key？"></a>21. Java中为什么字符串是受欢迎的Hasmap key？</h3><p>由于字符串不可变，它的hascode是在创建时缓存的，它也不需要再次计算。也使得他在处理时比其他key对象更快。这也是为什么字符串最常用来当做HasMap key的原因。</p><h3 id="22-字符串编程？"><a href="#22-字符串编程？" class="headerlink" title="22. 字符串编程？"></a>22. 字符串编程？</h3><h4 id="1-如下程序的输出"><a href="#1-如下程序的输出" class="headerlink" title="1. 如下程序的输出?"></a>1. 如下程序的输出?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"pankaj"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"PANKAJ"</span>);</span><br><span class="line">        System.out.println(s1 = s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单但狡猾的问题，不要忘记<code>==</code>操作符。</p><h4 id="2-如下程序的输出"><a href="#2-如下程序的输出" class="headerlink" title="2. 如下程序的输出?"></a>2. 如下程序的输出?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"String"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuffer sb)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"StringBuffer"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().foo(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现编译错误“The method foo(String) is ambiguous for the type Test”。入参没有明确类型。</p><h4 id="3-如下代码段将输出什么"><a href="#3-如下代码段将输出什么" class="headerlink" title="3. 如下代码段将输出什么?"></a>3. 如下代码段将输出什么?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure><p>输出“false”，因为<code>new</code>操作符强行创建了引用，<code>==</code>操作会比较引用。</p><h4 id="4-如下代码段将输出什么"><a href="#4-如下代码段将输出什么" class="headerlink" title="4. 如下代码段将输出什么?"></a>4. 如下代码段将输出什么?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer s2 = <span class="keyword">new</span> StringBuffer(s1);</span><br><span class="line">System.out.println(s1.equals(s2));</span><br></pre></td></tr></table></figure><p>输出“false”，因为<code>equals</code>方法实现会使用<code>instanceof</code>操作检查类型，相同类型且值相等则返回true，否返回false。</p><h4 id="5-如下代码段将输出什么"><a href="#5-如下代码段将输出什么" class="headerlink" title="5. 如下代码段将输出什么?"></a>5. 如下代码段将输出什么?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">s2.intern();</span><br><span class="line">System.out.println(s1 ==s2);</span><br></pre></td></tr></table></figure><p>输出“false”，<code>intern()</code>返回了引用，但需再次分配给s2，若<code>s2 = s2.intern()</code>，则输出“true”。</p><h4 id="6-如下代码段创建了多少个String对象？"><a href="#6-如下代码段创建了多少个String对象？" class="headerlink" title="6. 如下代码段创建了多少个String对象？"></a>6. 如下代码段创建了多少个String对象？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);  </span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure><p>答案是3个。<br>第1个 - 第1行, 存储在字符串常量池的“Hello” 对象。<br>第2个 - 第1行, 在堆内存的“Hello”字符串对象。<br>第3个 - 第2行, 在堆内存的“Hello”字符串对象（内存地址与上一行的不一样），这里的“Hello”字符重用了字符串常量中的字符串。 </p><p><a href="https://www.journaldev.com/1321/java-string-interview-questions-and-answers" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;字符串是广泛使用的Java类之一。这里我列出了一些重要的Java字符串面试问题及答案。&lt;/p&gt;
&lt;p&gt;这将极大的帮助我们获取字符串相关的全面知识，在面试中回答有关字符串的任何问题。&lt;/p&gt;
&lt;h2 id=&quot;Java字符串面试问题列表&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="java,String,interview,字符串,面试" scheme="/tags/java-String-interview-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
